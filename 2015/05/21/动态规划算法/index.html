<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="##1. 动态规划的适用场景动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 ##2. 动态规划的基本思想动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划算法">
<meta property="og:url" content="http://luojinping.com/2015/05/21/动态规划算法/index.html">
<meta property="og:site_name" content="Zane Blog">
<meta property="og:description" content="##1. 动态规划的适用场景动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 ##2. 动态规划的基本思想动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-18T08:52:04.973Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态规划算法">
<meta name="twitter:description" content="##1. 动态规划的适用场景动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 ##2. 动态规划的基本思想动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其">
  <link rel="alternate" href="/atom.xml" title="Zane Blog" type="application/atom+xml">
  <link rel="canonical" href="http://luojinping.com/2015/05/21/动态规划算法/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>动态规划算法 | Zane Blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zane Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">业精于勤荒于嬉，形成思毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2015/05/21/动态规划算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">动态规划算法

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: May 21 2015 23:13:37" itemprop="dateCreated datePublished" datetime="2015-05-21T23:13:37+08:00">May 21 2015</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: Aug 18 2019 16:52:04" itemprop="dateModified" datetime="2019-08-18T16:52:04+08:00">Aug 18 2019</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>##1. 动态规划的适用场景<br>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>##2. 动态规划的基本思想<br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<p>###2.1 重叠子问题<br>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<p>###2.2 最优子结构<br>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p>
<p>##3. 动态规划的三要素</p>
<ul>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li>
</ul>
<p>##4. 动态规划算法的设计步骤：</p>
<ol>
<li>刻画最优解的结构特征（寻找最优子结构）</li>
<li>递归地定义最优解的值（确定状态转移方程）</li>
<li>计算最优解的值（有两种方法：带备忘录自顶向下法、自底向上法）</li>
<li>利用计算出的信息构造一个最优解（通常是将具体的最优解输出）</li>
</ol>
<p>##5. 一般的解法<br>把动态规划的解法分为自顶向下和自底向上两种方式。<br>自顶向下的方式其实就是使用递归来求解子问题，最终解只需要调用递归式，子问题逐步往下层递归的求解。我们可以使用缓存把每次求解出来的子问题缓存起来，下次调用的时候就不必再递归计算了。<br>自底向上是另一种求解动态规划问题的方法，它不使用递归式，而是直接使用循环来计算所有可能的结果，往上层逐渐累加子问题的解。</p>
<p>##6. LeetCode题<br><strong>1. House Robber题目，转化过来的意思是，一个数组nums[]，求最大的不存在相邻元素的子数组的和。</strong></p>
<p>用动态规划的递归解法,自顶向下。时间复杂度O(nlogn)，空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Time Limit Exceeded</span><br><span class="line">public int robRecursiveDP(int[] nums, int length) &#123;</span><br><span class="line">    if (length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (length == 1) &#123;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (length == 2) &#123;</span><br><span class="line">        return Math.max(nums[0], nums[1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob1 = robRecursiveDP(nums, length - 1);</span><br><span class="line">    int rob2 = robRecursiveDP(nums, length - 2);</span><br><span class="line"></span><br><span class="line">    if (rob1 == rob2) &#123;</span><br><span class="line">        return rob1 + nums[length - 1];</span><br><span class="line">    &#125; else if (rob1 &gt; rob2) &#123;</span><br><span class="line">        return Math.max(rob2 + nums[length - 1], rob1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;data error&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>动态规划的状态转移方程：<br>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);<br>dp[i][1] = num[i - 1] + dp[i - 1][0];</p>
<p>用动态规划的自底向上解法, 时间复杂度O(n)，空间复杂度O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 300ms</span><br><span class="line">public int robDP(int[] num) &#123;</span><br><span class="line">    // dp[i][1] means we rob the current house and dp[i][0] means we don&apos;t</span><br><span class="line">    int[][] dp = new int[num.length + 1][2];</span><br><span class="line">    for (int i = 1; i &lt;= num.length; i++) &#123;</span><br><span class="line">        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);</span><br><span class="line">        dp[i][1] = num[i - 1] + dp[i - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(dp[num.length][0], dp[num.length][1]);</span><br></pre></td></tr></table></figure>

<p>用带备忘录的自底向上动态规划的解法, 时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 250ms</span><br><span class="line">public int rob(int[] num) &#123;</span><br><span class="line">	int prevNo = 0;</span><br><span class="line">    int prevYes = 0;</span><br><span class="line">    for (int n : num) &#123;</span><br><span class="line">        int temp = prevNo;</span><br><span class="line">        prevNo = Math.max(prevNo, prevYes);</span><br><span class="line">        prevYes = n + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(prevNo, prevYes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. House Robber2题目，转化过来的意思是，一个数组nums[], 首尾看成相邻，求最大的不存在相邻元素的子数组的和。</strong></p>
<p>Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.<br>For example, 1 -&gt; 2 -&gt; 3 -&gt; 1 becomes 2 -&gt; 3 if 1 is not robbed.<br>Since every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int robCycle(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums.length == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nums.length == 2) &#123;</span><br><span class="line">            return Math.max(nums[0], nums[1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Math.max(rob(Arrays.copyOfRange(nums, 0, nums.length - 1)),</span><br><span class="line">                rob(Arrays.copyOfRange(nums, 1, nums.length)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Maximum Subarray题目，求最大连续子数组和。</strong></p>
<p>不用动态规划的解法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int sumMax = nums[0], sum = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        if (sum &lt; num) &#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum &gt;= sumMax) &#123;</span><br><span class="line">            sumMax = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sumMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划的状态转移方程：dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1]);</p>
<p>用动态规划的自底向上解法, 时间复杂度O(n)，空间复杂度O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArrayDP(int[] nums) &#123;</span><br><span class="line">    int sumMax = nums[0];</span><br><span class="line">    int[] dp = new int[nums.length + 1];</span><br><span class="line">    for (int i = 1; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1]);</span><br><span class="line">        sumMax = Math.max(sumMax, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sumMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用带备忘录的自底向上动态规划的解法, 时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArrayDPWithMem(int[] nums) &#123;</span><br><span class="line">    int sumMax = nums[0], sumPre = 0;</span><br><span class="line">    for (int i = 1; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        sumPre = Math.max(sumPre + nums[i - 1], nums[i - 1]);</span><br><span class="line">        sumMax = Math.max(sumMax, sumPre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sumMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. Interleaving String题目，Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</strong><br>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,<br>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
<p>动态规划的递归调用解法，时间复杂度不符合要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterleaveRecursiveDP(String s1, String s2, String s3) &#123;</span><br><span class="line">    if (s3.length() != s1.length() + s2.length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (s1.length() == 0 &amp;&amp; s2.length() == 0 &amp;&amp; s3.length() == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else if (s3.length() == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String newS3 = s3.substring(0, s3.length() - 1);</span><br><span class="line">    String newS1 = s1.length() &gt; 0 ? s1.substring(0, s1.length() - 1) : &quot;&quot;;</span><br><span class="line">    String newS2 = s2.length() &gt; 0 ? s2.substring(0, s2.length() - 1) : &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean equalS1 = s1.length() &gt; 0 &amp;&amp; (s1.charAt(s1.length() - 1) == s3.charAt(s3.length() -</span><br><span class="line">            1));</span><br><span class="line">    boolean equalS2 = s2.length() &gt; 0 &amp;&amp; s2.charAt(s2.length() - 1) == s3.charAt(s3.length() -</span><br><span class="line">            1);</span><br><span class="line"></span><br><span class="line">    if (equalS1 &amp;&amp; !equalS2) &#123;</span><br><span class="line">        return isInterleaveRecursiveDP(newS1, s2, newS3);</span><br><span class="line">    &#125; else if (!equalS1 &amp;&amp; equalS2) &#123;</span><br><span class="line">        return isInterleaveRecursiveDP(s1, newS2, newS3);</span><br><span class="line">    &#125; else if (equalS1 &amp;&amp; equalS2) &#123;</span><br><span class="line">        return isInterleaveRecursiveDP(newS1, s2, newS3) || isInterleaveRecursiveDP(s1, newS2, newS3);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划带备忘录自底向上的解法，难点就在于如何将解法1的递归公式转化为动态转移方程，下述代码构造的二维数组很好地诠释了这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterleaveDP(String s1, String s2, String s3) &#123;</span><br><span class="line">    if (s3.length() != s1.length() + s2.length())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    boolean[][] table = new boolean[s1.length() + 1][s2.length() + 1];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; s1.length() + 1; i++)</span><br><span class="line">        for (int j = 0; j &lt; s2.length() + 1; j++) &#123;</span><br><span class="line">            if (i == 0 &amp;&amp; j == 0)</span><br><span class="line">                table[i][j] = true;</span><br><span class="line">            else if (i == 0)</span><br><span class="line">                table[i][j] = (table[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1));</span><br><span class="line">            else if (j == 0)</span><br><span class="line">                table[i][j] = (table[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1));</span><br><span class="line">            else</span><br><span class="line">                table[i][j] = (table[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) ||</span><br><span class="line">                        (table[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(i + j - 1)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return table[s1.length()][s2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2015/04/13/Java线程中断/" rel="next" title="Java线程中断">
                  <i class="fa fa-chevron-left"></i> Java线程中断
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2015/06/19/AbstractQueuedSynchronizer详解/" rel="prev" title="AbstractQueuedSynchronizer详解">
                  AbstractQueuedSynchronizer详解 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jinping Luo</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>




        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinping Luo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
