
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Zane Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Jinping Luo">
    
    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zane Blog">
<meta property="og:url" content="http://luojinping.com/page/4/">
<meta property="og:site_name" content="Zane Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zane Blog">
<meta name="twitter:description">


    
    <link rel="alternative" href="/atom.xml" title="Zane Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a2d87d3add52ff134d9fac6cc16e4800";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Zane Blog" title="Zane Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Zane Blog">Zane Blog</a></h1>
				<h2 class="blog-motto">业精于勤荒于嬉，形成思毁于随</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:luojinping.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/19/AbstractQueuedSynchronizer详解/" title="AbstractQueuedSynchronizer详解" itemprop="url">AbstractQueuedSynchronizer详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-06-19T02:43:07.000Z" itemprop="datePublished"> Published Jun 19 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="AQS简介">AQS简介</h1>
<h2 id="AQS介绍">AQS介绍</h2>
<p>AbstractQueuedSynchronizer提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。该同步器（以下简称同步器）利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。然而多线程环境中对状态的操纵必须确保原子性，因此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()</div><div class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.<span class="keyword">setState</span>(<span class="keyword">int</span>)</div><div class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(<span class="keyword">int</span>, <span class="keyword">int</span>)</div></pre></td></tr></table></figure>

<p>子类推荐被定义为自定义同步装置的内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干acquire之类的方法来供使用。该同步器即可以作为排他模式也可以作为共享模式，当它被定义为一个排他模式时，其他线程对其的获取就被阻止，而共享模式对于多个线程获取都可以成功。</p>
<h2 id="AQS用处">AQS用处</h2>
<p><img src="/img/AQS_uses.jpg" alt=""></p>
<h2 id="同步器与锁">同步器与锁</h2>
<p><strong>同步器是实现锁的关键，利用同步器将锁的语义实现，然后在锁的实现中聚合同步器。</strong> 可以这样理解：锁的API是面向使用者的，它定义了与锁交互的公共行为，而每个锁需要完成特定的操作也是透过这些行为来完成的（比如：可以允许两个线程进行加锁，排除两个以上的线程），但是实现是依托给同步器来完成；同步器面向的是线程访问和资源控制，它定义了线程对资源是否能够获取以及线程的排队等操作。<strong>锁和同步器很好的隔离了二者所需要关注的领域，严格意义上讲，同步器可以适用于除了锁以外的其他同步设施上（包括锁）。</strong><br>同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的主要包含以下成员变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">Node</span> {</div><div class="line">    <span class="title">int</span> waitStatus;</div><div class="line">    <span class="title">Node</span> prev;</div><div class="line">    <span class="title">Node</span> next;</div><div class="line">    <span class="title">Node</span> nextWaiter;</div><div class="line">    <span class="title">Thread</span> thread;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上五个成员变量主要负责保存该节点的线程引用，同步等待队列（以下简称sync队列）的前驱和后继节点，同时也包括了同步状态。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int waitStatus</td>
<td>表示节点的状态。其中包含的状态有： <br>CANCELLED，值为1，表示当前的线程被取消；<br>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；<br>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；<br>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；<br>值为0，表示当前节点在sync队列中，等待着获取锁。</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点。</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>存储condition队列中的后继节点。</td>
</tr>
<tr>
<td>Thread thread</td>
<td>入队列时的当前线程。</td>
</tr>
</tbody>
</table>
<p>节点成为sync队列和condition队列构建的基础，在同步器中就包含了sync队列。同步器拥有三个成员变量：sync队列的头结点head、sync队列的尾节点tail和状态state。对于锁的获取，请求形成节点，将其挂载在尾部，而锁资源的转移（释放再获取）是从头部开始向后进行。对于同步器维护的状态state，多个线程对其的获取将会产生一个链式的结构。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/10/21.png" alt=""></p>
<h2 id="API说明">API说明</h2>
<p><br>实现自定义同步器时，需要使用同步器提供的getState()、setState()和compareAndSetState()方法来操纵状态的变迁。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>排它的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>释放状态。</td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td>共享的模式下获取状态。</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享的模式下释放状态。</td>
</tr>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>在排它模式下，状态是否被占用。</td>
</tr>
</tbody>
</table>
<p>实现这些方法必须是非阻塞而且是线程安全的，推荐使用该同步器的父类java.util.concurrent.locks.AbstractOwnableSynchronizer来设置当前的线程。<br>开始提到同步器内部基于一个FIFO队列，对于一个独占锁的获取和释放有以下伪码可以表示。<br>获取一个排他锁。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(获取锁) {</div><div class="line">    <span class="keyword">if</span> (获取到) {</div><div class="line">        退出<span class="keyword">while</span>循环</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span>(当前线程没有入队列) {</div><div class="line">            那么入队列</div><div class="line">        }</div><div class="line">        阻塞当前线程</div><div class="line">    }</div><div class="line">}</div><div class="line">释放一个排他锁。</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (释放成功) {</div><div class="line">    删除头结点</div><div class="line">    激活原头结点的后继节点</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Mutex_示例">Mutex 示例</h2>
<p><br>下面通过一个排它锁的例子来深入理解一下同步器的工作原理，而只有掌握同步器的工作原理才能够更加深入了解其他的并发组件。<br>排他锁的实现，一次只能一个线程获取到锁。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Mutex implements Lock, java.io.Serializable {</div><div class="line">   <span class="comment">// 内部类，自定义同步器</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</div><div class="line">     <span class="comment">// 是否处于占用状态</span></div><div class="line">     <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span>() {</div><div class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">     }</div><div class="line">     <span class="comment">// 当状态为0的时候获取锁</span></div><div class="line">     <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span>(<span class="keyword">int</span> acquires) {</div><div class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       }</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     }</div><div class="line">     <span class="comment">// 释放锁，将状态设置为0</span></div><div class="line">     <span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span>(<span class="keyword">int</span> releases) {</div><div class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">       setState(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     }</div><div class="line">     <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></div><div class="line">     Condition newCondition() { <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); }</div><div class="line">   }</div><div class="line">   <span class="comment">// 仅需要将操作代理到Sync上即可</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>()                { sync.acquire(<span class="number">1</span>); }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span>()          { <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span>()              { sync.release(<span class="number">1</span>); }</div><div class="line">   <span class="keyword">public</span> Condition <span class="title">newCondition</span>()   { <span class="keyword">return</span> sync.newCondition(); }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span>()         { <span class="keyword">return</span> sync.isHeldExclusively(); }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span>() { <span class="keyword">return</span> sync.hasQueuedThreads(); }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">   }</div><div class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span>(<span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">       <span class="keyword">throws</span> InterruptedException {</div><div class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">   }</div><div class="line"> }</div></pre></td></tr></table></figure>

<p>可以看到Mutex将Lock接口均代理给了同步器的实现。<br>使用方将Mutex构造出来之后，调用lock获取锁，调用unlock进行解锁。下面以Mutex为例子，详细分析以下同步器的实现逻辑。</p>
<h1 id="独占模式">独占模式</h1>
<h2 id="acquire">acquire</h2>
<p>实现分析<br>public final void acquire(int arg)<br>该方法以排他的方式获取锁，对中断不敏感，完成synchronized语义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span>(<span class="keyword">int</span> arg) {</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &&</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>尝试获取（调用tryAcquire更改状态，需要保证原子性）；<br>在tryAcquire方法中使用了同步器提供的对state操作的方法，利用compareAndSet保证只有一个线程能够对状态进行成功修改，而没有成功修改的线程将进入sync队列排队。</li>
<li>如果获取不到，将当前线程构造成节点Node并加入sync队列；<br>进入队列的每个线程都是一个节点Node，从而形成了一个双向队列，类似CLH队列，这样做的目的是线程间的通信会被限制在较小规模（也就是两个节点左右）。</li>
<li>再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态。<br>使用LockSupport将当前线程unpark，关于LockSupport后续会详细介绍。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) {</div><div class="line">	Node node = new Node(Thread.currentThread(), mode);</div><div class="line">	// 快速尝试在尾部添加</div><div class="line">	Node pred = tail;</div><div class="line">	if (pred != null) {</div><div class="line">		node.prev = pred;</div><div class="line">		if (compareAndSetTail(pred, node)) {</div><div class="line">			pred.next = node;</div><div class="line">			return node;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	enq(node);</div><div class="line">	return node;</div><div class="line">}</div><div class="line"></div><div class="line">private Node enq(final Node node) {</div><div class="line">	for (;;) {</div><div class="line">		Node t = tail;</div><div class="line">		if (t == null) { // Must initialize</div><div class="line">			if (compareAndSetHead(new Node()))</div><div class="line">				tail = head;</div><div class="line">		} else {</div><div class="line">			node.prev = t;</div><div class="line">			if (compareAndSetTail(t, node)) {</div><div class="line">			t.next = node;</div><div class="line">			return t;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>使用当前线程构造Node；<br>对于一个节点需要做的是将当节点前驱节点指向尾节点（current.prev = tail），尾节点指向它（tail = current），原有的尾节点的后继节点指向它（t.next = current）而这些操作要求是原子的。上面的操作是利用尾节点的设置来保证的，也就是compareAndSetTail来完成的。</li>
</ol>
<ul>
<li>先行尝试在队尾添加；<br>如果尾节点已经有了，然后做如下操作：<ol>
<li>分配引用T指向尾节点；<br></li>
<li>将节点的前驱节点更新为尾节点（current.prev = tail）；</li>
<li>如果尾节点是T，那么将当尾节点设置为该节点（tail = current，原子更新）；</li>
<li>T的后继节点指向当前节点（T.next = current）。<br><br>注意第3点是要求原子的。<br>这样可以以最短路径O(1)的效果来完成线程入队，是最大化减少开销的一种方式。</li>
</ol>
</li>
<li>如果队尾添加失败或者是第一个入队的节点。<br>如果是第1个节点，也就是sync队列没有初始化，那么会进入到enq这个方法，进入的线程可能有多个，或者说在addWaiter中没有成功入队的线程都将进入enq这个方法。<br>可以看到enq的逻辑是确保进入的Node都会有机会顺序的添加到sync队列中，而加入的步骤如下：<ol>
<li>如果尾节点为空，那么原子化的分配一个头节点，并将尾节点指向头节点，这一步是初始化；</li>
<li><strong>然后是重复在addWaiter中做的工作，但是在一个for(;;)的循环中，直到当前节点入队为止。</strong></li>
</ol>
</li>
</ul>
<p>进入sync队列之后，接下来就是要进行锁的获取，或者说是访问控制了，只有一个线程能够在同一时刻继续的运行，而其他的进入等待状态。而每个线程都是一个独立的个体，它们自省的观察，当条件满足的时候（自己的前驱是头结点并且原子性的获取了状态），那么这个线程能够继续运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> acquireQueued(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg) {</div><div class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">for</span> (;;) {</div><div class="line">			<span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">			<span class="keyword">if</span> (p == head &&tryAcquire(arg)) {</div><div class="line">				setHead(node);</div><div class="line">				p.<span class="keyword">next</span> = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">				failed = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">return</span> interrupted;</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &&</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">				interrupted = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		<span class="keyword">if</span> (failed)</div><div class="line">			cancelAcquire(node);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>获取当前节点的前驱节点；<br>需要获取当前节点的前驱节点，而头结点所对应的含义是当前占有锁且正在运行。</li>
<li>当前驱节点是头结点并且能够获取状态，代表该当前节点占有锁；<br>如果满足上述条件，那么代表能够占有锁，根据节点对锁占有的含义，设置头结点为当前节点。</li>
<li>否则进入等待状态。<br>如果没有轮到当前节点运行，那么将当前线程从线程调度器上摘下，也就是进入等待状态。<br>这里针对acquire做一下总结：</li>
<li>状态的维护；<br>需要在锁定时，需要维护一个状态(int类型)，而对状态的操作是原子和非阻塞的，通过同步器提供的对状态访问的方法对状态进行操纵，并且利用compareAndSet来确保原子性的修改。</li>
<li>状态的获取；<br>一旦成功的修改了状态，当前线程或者说节点，就被设置为头节点。</li>
<li>sync队列的维护。<br>在获取资源未果的过程中条件不符合的情况下(不该自己，前驱节点不是头节点或者没有获取到资源)进入睡眠状态，停止线程调度器对当前节点线程的调度。<br>这时引入的一个释放的问题，也就是说使睡眠中的Node或者说线程获得通知的关键，就是前驱节点的通知，而这一个过程就是释放，释放会通知它的后继节点从睡眠中返回准备运行。<br>下面的流程图基本描述了一次acquire所需要经历的过程：</li>
</ol>
<p><img src="http://img2.tbcdn.cn/L1/461/1/t_9683_1379328542_928191748.png" alt=""></p>
<p>如上图所示，其中的判定退出队列的条件，判定条件是否满足和休眠当前线程就是完成了自旋spin的过程。</p>
<h2 id="release">release</h2>
<p>public final boolean release(int arg)<br>在unlock方法的实现中，使用了同步器的release方法。相对于在之前的acquire方法中可以得出调用acquire，保证能够获取到锁（成功获取状态），而release则表示将状态设置回去，也就是将资源释放，或者说将锁释放。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span>(<span class="keyword">int</span> arg) {</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> && h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>尝试释放状态；<br>tryRelease能够保证原子化的将状态设置回去，当然需要使用compareAndSet来保证。如果释放状态成功过之后，将会进入后继节点的唤醒过程。</li>
<li>唤醒当前节点的后继节点所包含的线程。<br>通过LockSupport的unpark方法将休眠中的线程唤醒，让其继续acquire状态。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void unparkSuccessor(Node node) {</div><div class="line">	// 将状态设置为同步状态</div><div class="line">	int ws = node.waitStatus;</div><div class="line">	if (ws &lt; 0) 		</div><div class="line">		compareAndSetWaitStatus(node, ws, 0); 	</div><div class="line">	</div><div class="line">	/* </div><div class="line">	* 获取当前节点的后继节点，如果满足状态，那么进行唤醒操作 </div><div class="line">	* 如果没有满足状态，从尾部开始找寻符合要求的节点并将其唤醒 </div><div class="line">	*/</div><div class="line">	</div><div class="line">	Node s = node.next; 	</div><div class="line">	if (s == null || s.waitStatus &gt; 0) {</div><div class="line">		s = null;</div><div class="line">		for (Node t = tail; t != null && t != node; t = t.prev)</div><div class="line">			if (t.waitStatus &lt;= 0)</div><div class="line">				s = t;</div><div class="line">		}</div><div class="line">	if (s != null)</div><div class="line">		LockSupport.unpark(s.thread);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括，该方法取出了当前节点的next引用，然后对其线程(Node)进行了唤醒，这时就只有一个或合理个数的线程被唤醒，被唤醒的线程继续进行对资源的获取与争夺。<br>回顾整个资源的获取和释放过程：<br>在获取时，维护了一个sync队列，每个节点都是一个线程在进行自旋，而依据就是自己是否是首节点的后继并且能够获取资源；<br>在释放时，仅仅需要将资源还回去，然后通知一下后继节点并将其唤醒。<br>这里需要注意，队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。</p>
<h2 id="tryAcquire">tryAcquire</h2>
<p>protected boolean tryAcquire(int arg)<br>tryAcquire是自定义同步器需要实现的方法，也就是自定义同步器非阻塞原子化的获取状态，如果锁该方法一般用于Lock的tryLock实现中，这个特性是synchronized无法提供的。</p>
<p>public final void acquireInterruptibly(int arg)<br>该方法提供获取状态能力，当然在无法获取状态的情况下会进入sync队列进行排队，这类似acquire，但是和acquire不同的地方在于它能够在外界对当前线程进行中断的时候提前结束获取状态的操作，换句话说，就是在类似synchronized获取锁时，外界能够对当前线程进行中断，并且获取锁的这个操作能够响应中断并提前返回。一个线程处于synchronized块中或者进行同步I/O操作时，对该线程进行中断操作，这时该线程的中断标识位被设置为true，但是线程依旧继续运行。<br>如果在获取一个通过网络交互实现的锁时，这个锁资源突然进行了销毁，那么使用acquireInterruptibly的获取方式就能够让该时刻尝试获取锁的线程提前返回。而同步器的这个特性被实现Lock接口中的lockInterruptibly方法。根据Lock的语义，在被中断时，lockInterruptibly将会抛出InterruptedException来告知使用者。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span>(<span class="keyword">int</span> arg)</div><div class="line">	<span class="keyword">throws</span> InterruptedException {</div><div class="line">	<span class="keyword">if</span> (Thread.interrupted())</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">	<span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">		doAcquireInterruptibly(arg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span>(<span class="keyword">int</span> arg)</div><div class="line">	<span class="keyword">throws</span> InterruptedException {</div><div class="line">	<span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">for</span> (;;) {</div><div class="line">			<span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">			<span class="keyword">if</span> (p == head && tryAcquire(arg)) {</div><div class="line">				setHead(node);</div><div class="line">				p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">				failed = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			}</div><div class="line">			<span class="comment">// 检测中断标志位</span></div><div class="line">			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &&</div><div class="line">			parkAndCheckInterrupt())</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">		}</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		<span class="keyword">if</span> (failed)</div><div class="line">			cancelAcquire(node);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>检测当前线程是否被中断；<br>判断当前线程的中断标志位，如果已经被中断了，那么直接抛出异常并将中断标志位设置为false。</li>
<li>尝试获取状态；<br>调用tryAcquire获取状态，如果顺利会获取成功并返回。</li>
<li>构造节点并加入sync队列；<br>获取状态失败后，将当前线程引用构造为节点并加入到sync队列中。退出队列的方式在没有中断的场景下和acquireQueued类似，当头结点是自己的前驱节点并且能够获取到状态时，即可以运行，当然要将本节点设置为头结点，表示正在运行。</li>
<li>中断检测。<br>在每次被唤醒时，进行中断检测，如果发现当前线程被中断，那么抛出InterruptedException并退出循环。</li>
</ol>
<h2 id="doAcquireNanos">doAcquireNanos</h2>
<p>private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException<br>该方法提供了具备有超时功能的获取状态的调用，如果在指定的nanosTimeout内没有获取到状态，那么返回false，反之返回true。可以将该方法看做acquireInterruptibly的升级版，也就是在判断是否被中断的基础上增加了超时控制。<br>针对超时控制这部分的实现，主要需要计算出睡眠的delta，也就是间隔值。间隔可以表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。如果nanosTimeout大于0，那么还需要使当前线程睡眠，反之则返回false。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span>(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line"><span class="keyword">throws</span> InterruptedException {</div><div class="line">	<span class="keyword">long</span> lastTime = System.nanoTime();</div><div class="line">	<span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		<span class="keyword">for</span> (;;) {</div><div class="line">			<span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">			<span class="keyword">if</span> (p == head &&tryAcquire(arg)) {</div><div class="line">				setHead(node);</div><div class="line">				p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">				failed = <span class="keyword">false</span>;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>) 				<span class="keyword">return</span> <span class="keyword">false</span>; 			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) && nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">			LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">			<span class="keyword">long</span> now = System.nanoTime();</div><div class="line">			<span class="comment">//计算时间，当前时间减去睡眠之前的时间得到睡眠的时间，然后被</span></div><div class="line">			<span class="comment">//原有超时时间减去，得到了还应该睡眠的时间</span></div><div class="line">			nanosTimeout -= now - lastTime;</div><div class="line">			lastTime = now;</div><div class="line">			<span class="keyword">if</span> (Thread.interrupted())</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">		}</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		<span class="keyword">if</span> (failed)</div><div class="line">			cancelAcquire(node);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>加入sync队列；<br>将当前线程构造成为节点Node加入到sync队列中。</li>
<li>条件满足直接返回；<br>退出条件判断，如果前驱节点是头结点并且成功获取到状态，那么设置自己为头结点并退出，返回true，也就是在指定的nanosTimeout之前获取了锁。</li>
<li>获取状态失败休眠一段时间；<br>通过LockSupport.unpark来指定当前线程休眠一段时间。</li>
<li>计算再次休眠的时间；<br>唤醒后的线程，计算仍需要休眠的时间，该时间表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。其中now – lastTime表示这次睡眠所持续的时间。</li>
<li>休眠时间的判定。<br>唤醒后的线程，计算仍需要休眠的时间，并无阻塞的尝试再获取状态，如果失败后查看其nanosTimeout是否大于0，如果小于0，那么返回完全超时，没有获取到锁。 如果nanosTimeout小于等于1000L纳秒，则进入快速的自旋过程。那么快速自旋会造成处理器资源紧张吗？结果是不会，经过测算，开销看起来很小，几乎微乎其微。Doug Lea应该测算了在线程调度器上的切换造成的额外开销，因此在短时1000纳秒内就让当前线程进入快速自旋状态，如果这时再休眠相反会让nanosTimeout的获取时间变得更加不精确。<br>上述过程可以如下图所示：</li>
</ol>
<p><img src="http://img2.tbcdn.cn/L1/461/1/t_9683_1379328891_568034081.png" alt=""></p>
<p>上述这个图中可以理解为在类似获取状态需要排队的基础上增加了一个超时控制的逻辑。每次超时的时间就是当前超时剩余的时间减去睡眠的时间，而在这个超时时间的基础上进行了判断，如果大于0那么继续睡眠（等待），可以看出这个超时版本的获取状态只是一个近似超时的获取状态，因此任何含有超时的调用基本结果就是近似于给定超时。</p>
<h1 id="共享模式">共享模式</h1>
<h2 id="acquireShared">acquireShared</h2>
<p>public final void acquireShared(int arg)<br>调用该方法能够以共享模式获取状态，共享模式和之前的独占模式有所区别。以文件的查看为例，如果一个程序在对其进行读取操作，那么这一时刻，对这个文件的写操作就被阻塞，相反，这一时刻另一个程序对其进行同样的读操作是可以进行的。如果一个程序在对其进行写操作，那么所有的读与写操作在这一时刻就被阻塞，直到这个程序完成写操作。<br>以读写场景为例，描述共享和独占的访问模式，如下图所示：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/t_9683_1379328959_1702388031.png" alt=""></p>
<p>上图中，红色代表被阻塞，绿色代表可以通过。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span>(<span class="keyword">int</span> arg) {</div><div class="line">	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)	doAcquireShared(arg); } <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span>(<span class="keyword">int</span> arg) { 	<span class="keyword">final</span> Node node = addWaiter(Node.SHARED); 	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>; 	<span class="keyword">try</span> { 		<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; 		<span class="keyword">for</span> (;;) { 			<span class="keyword">final</span> Node p = node.predecessor(); 			<span class="keyword">if</span> (p == head) { 				<span class="keyword">int</span> r = tryAcquireShared(arg); 				<span class="keyword">if</span> (r &gt;= <span class="number">0</span>) {</div><div class="line">					setHeadAndPropagate(node, r);</div><div class="line">					p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">					<span class="keyword">if</span> (interrupted)</div><div class="line">						selfInterrupt();</div><div class="line">					failed = <span class="keyword">false</span>;</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &&</div><div class="line">parkAndCheckInterrupt())</div><div class="line">			interrupted = <span class="keyword">true</span>;</div><div class="line">		}</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		<span class="keyword">if</span> (failed)</div><div class="line">			cancelAcquire(node);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要包括：</p>
<ol>
<li>尝试获取共享状态；<br>调用tryAcquireShared来获取共享状态，该方法是非阻塞的，如果获取成功则立刻返回，也就表示获取共享锁成功。</li>
<li>获取失败进入sync队列；<br>在获取共享状态失败后，当前时刻有可能是独占锁被其他线程所把持，那么将当前线程构造成为节点（共享模式）加入到sync队列中。</li>
<li>循环内判断退出队列条件；<br>如果当前节点的前驱节点是头结点并且获取共享状态成功，这里和独占锁acquire的退出队列条件类似。</li>
<li>获取共享状态成功；<br>在退出队列的条件上，和独占锁之间的主要区别在于获取共享状态成功之后的行为，而如果共享状态获取成功之后会判断后继节点是否是共享模式，如果是共享模式，那么就直接对其进行唤醒操作，也就是同时激发多个线程并发的运行。</li>
<li>获取共享状态失败。<br>通过使用LockSupport将当前线程从线程调度器上摘下，进入休眠状态。<br>对于上述逻辑中，节点之间的通知过程如下图所示：</li>
</ol>
<p><img src="http://img1.tbcdn.cn/L1/461/1/t_9683_1379329217_1542967524.png" alt=""></p>
<p>上图中，绿色表示共享节点，它们之间的通知和唤醒操作是在前驱节点获取状态时就进行的，红色表示独占节点，它的被唤醒必须取决于前驱节点的释放，也就是release操作，可以看出来图中的独占节点如果要运行，必须等待前面的共享节点均释放了状态才可以。而独占节点如果获取了状态，那么后续的独占式获取和共享式获取均被阻塞。</p>
<h2 id="releaseShared">releaseShared</h2>
<p>public final boolean releaseShared(int arg)<br>调用该方法释放共享状态，每次获取共享状态acquireShared都会操作状态，同样在共享锁释放的时候，也需要将状态释放。比如说，一个限定一定数量访问的同步工具，每次获取都是共享的，但是如果超过了一定的数量，将会阻塞后续的获取操作，只有当之前获取的消费者将状态释放才可以使阻塞的获取操作得以运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span>(<span class="keyword">int</span> arg) {</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上述逻辑主要就是调用同步器的tryReleaseShared方法来释放状态，并同时在doReleaseShared方法中唤醒其后继节点。</p>
<h2 id="一个例子_TwinsLock">一个例子 TwinsLock</h2>
<p>在上述对同步器AbstractQueuedSynchronizer进行了实现层面的分析之后，我们通过一个例子来加深对同步器的理解：<br>设计一个同步工具，该工具在同一时刻，只能有两个线程能够并行访问，超过限制的其他线程进入阻塞状态。<br>对于这个需求，可以利用同步器完成一个这样的设定，定义一个初始状态，为2，一个线程进行获取那么减1，一个线程释放那么加1，状态正确的范围在[0，1，2]三个之间，当在0时，代表再有新的线程对资源进行获取时只能进入阻塞状态（注意在任何时候进行状态变更的时候均需要以CAS作为原子性保障）。由于资源的数量多于1个，同时可以有两个线程占有资源，因此需要实现tryAcquireShared和tryReleaseShared方法，这里谢谢luoyuyou和同事小明指正，已经修改了实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Sync	sync	= <span class="keyword">new</span> Sync(<span class="number">2</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>	serialVersionUID	= -<span class="number">7889272986162341211</span>L;</div><div class="line"></div><div class="line">		Sync(<span class="keyword">int</span> count) {</div><div class="line">			<span class="keyword">if</span> (count &lt;= <span class="number">0</span>) {</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</div><div class="line">			}</div><div class="line">			setState(count);</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span>(<span class="keyword">int</span> reduceCount) {</div><div class="line">			<span class="keyword">for</span> (;;) {</div><div class="line">				<span class="keyword">int</span> current = getState();</div><div class="line">				<span class="keyword">int</span> newCount = current - reduceCount;</div><div class="line">				<span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) {</div><div class="line">					<span class="keyword">return</span> newCount;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span>(<span class="keyword">int</span> returnCount) {</div><div class="line">			<span class="keyword">for</span> (;;) {</div><div class="line">				<span class="keyword">int</span> current = getState();</div><div class="line">				<span class="keyword">int</span> newCount = current + returnCount;</div><div class="line">				<span class="keyword">if</span> (compareAndSetState(current, newCount)) {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>() {</div><div class="line">		sync.acquireShared(<span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">		sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span>() {</div><div class="line">		<span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span>(<span class="keyword">long</span> time, TimeUnit unit) <span class="keyword">throws</span> InterruptedException {</div><div class="line">		<span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span>() {</div><div class="line">		sync.releaseShared(<span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> Condition <span class="title">newCondition</span>() {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>


<p>上述测试用例的逻辑主要包括：</p>
<p>​1. 打印线程<br>Worker在两次睡眠之间打印自身线程，如果一个时刻只能有两个线程同时访问，那么打印出来的内容将是成对出现。<br>​2. 分隔线程<br>不停的打印换行，能让Worker的输出看起来更加直观。<br>该测试的结果是在一个时刻，仅有两个线程能够获得到锁，并完成打印，而表象就是打印的内容成对出现。</p>
<h1 id="总结">总结</h1>
<p>AQS简核心是通过一个共享变量来同步状态，变量的状态由子类去维护，而AQS框架做的是：</p>
<ul>
<li>线程阻塞队列的维护</li>
<li>线程阻塞和唤醒</li>
</ul>
<p>共享变量的修改都是通过Unsafe类提供的CAS操作完成的。<br>AbstractQueuedSynchronizer类的主要方法是acquire和release，典型的模板方法， 下面这4个方法由子类去实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span>(<span class="keyword">int</span> arg)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span>(<span class="keyword">int</span> arg)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span>(<span class="keyword">int</span> arg)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span>(<span class="keyword">int</span> arg)</div></pre></td></tr></table></figure>

<p>acquire方法用来获取锁，返回true说明线程获取成功继续执行，一旦返回false则线程加入到等待队列中，等待被唤醒，release方法用来释放锁。 一般来说实现的时候这两个方法被封装为lock和unlock方法。</p>
<p>refer：</p>
<blockquote>
<p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a><br><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html" target="_blank" rel="external">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html</a><br><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html" target="_blank" rel="external">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/多线程/">多线程</a><a href="/tags/并发/">并发</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/19/AbstractQueuedSynchronizer详解/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/21/动态规划算法/" title="动态规划算法" itemprop="url">动态规划算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-05-21T15:13:37.000Z" itemprop="datePublished"> Published May 21 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_动态规划的适用场景">1. 动态规划的适用场景</h2>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<h2 id="2-_动态规划的基本思想">2. 动态规划的基本思想</h2>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<h3 id="2-1_重叠子问题">2.1 重叠子问题</h3>
<p>动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<h3 id="2-2_最优子结构">2.2 最优子结构</h3>
<p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p>
<h2 id="3-_动态规划的三要素">3. 动态规划的三要素</h2>
<ul>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
<li>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</li>
</ul>
<h2 id="4-_动态规划算法的设计步骤：">4. 动态规划算法的设计步骤：</h2>
<ol>
<li>刻画最优解的结构特征（寻找最优子结构）</li>
<li>递归地定义最优解的值（确定状态转移方程）</li>
<li>计算最优解的值（有两种方法：带备忘录自顶向下法、自底向上法）</li>
<li>利用计算出的信息构造一个最优解（通常是将具体的最优解输出）</li>
</ol>
<h2 id="5-_一般的解法">5. 一般的解法</h2>
<p>把动态规划的解法分为自顶向下和自底向上两种方式。<br>自顶向下的方式其实就是使用递归来求解子问题，最终解只需要调用递归式，子问题逐步往下层递归的求解。我们可以使用缓存把每次求解出来的子问题缓存起来，下次调用的时候就不必再递归计算了。<br>自底向上是另一种求解动态规划问题的方法，它不使用递归式，而是直接使用循环来计算所有可能的结果，往上层逐渐累加子问题的解。</p>
<h2 id="6-_LeetCode题">6. LeetCode题</h2>
<p><strong>1. House Robber题目，转化过来的意思是，一个数组nums[]，求最大的不存在相邻元素的子数组的和。</strong></p>
<p>用动态规划的递归解法,自顶向下。时间复杂度O(nlogn)，空间复杂度O(1)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//Time Limit Exceeded</div><div class="line">public <span class="keyword">int</span> robRecursiveDP(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> <span class="keyword">length</span>) {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">length</span> == <span class="number">0</span>) {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">length</span> == <span class="number">1</span>) {</div><div class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">length</span> == <span class="number">2</span>) {</div><div class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rob1 = robRecursiveDP(nums, <span class="keyword">length</span> - <span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> rob2 = robRecursiveDP(nums, <span class="keyword">length</span> - <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rob1 == rob2) {</div><div class="line">        <span class="keyword">return</span> rob1 + nums[<span class="keyword">length</span> - <span class="number">1</span>];</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (rob1 &gt; rob2) {</div><div class="line">        <span class="keyword">return</span> Math.max(rob2 + nums[<span class="keyword">length</span> - <span class="number">1</span>], rob1);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        System.out.println(<span class="string">"data error"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>动态规划的状态转移方程：<br>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);<br>dp[i][1] = num[i - 1] + dp[i - 1][0];</p>
<p>用动态规划的自底向上解法, 时间复杂度O(n)，空间复杂度O(n)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 300ms</span></div><div class="line">public <span class="keyword">int</span> robDP(<span class="keyword">int</span>[] num) {</div><div class="line">    <span class="comment">// dp[i][1] means we rob the current house and dp[i][0] means we don't</span></div><div class="line">    <span class="keyword">int</span>[][] dp = new <span class="keyword">int</span>[num.<span class="built_in">length</span> + <span class="number">1</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.<span class="built_in">length</span>; i++) {</div><div class="line">        dp[i][<span class="number">0</span>] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</div><div class="line">        dp[i][<span class="number">1</span>] = num[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(dp[num.<span class="built_in">length</span>][<span class="number">0</span>], dp[num.<span class="built_in">length</span>][<span class="number">1</span>]);</div></pre></td></tr></table></figure>

<p>用带备忘录的自底向上动态规划的解法, 时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 250ms</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span>(<span class="keyword">int</span>[] num) {</div><div class="line">	<span class="keyword">int</span> prevNo = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> prevYes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) {</div><div class="line">        <span class="keyword">int</span> temp = prevNo;</div><div class="line">        prevNo = Math.max(prevNo, prevYes);</div><div class="line">        prevYes = n + temp;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> Math.max(prevNo, prevYes);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2. House Robber2题目，转化过来的意思是，一个数组nums[], 首尾看成相邻，求最大的不存在相邻元素的子数组的和。</strong></p>
<p>Actually, extending from the logic that if house i is not robbed, then you are free to choose whether to rob house i + 1, you can break the circle by assuming a house is not robbed.<br>For example, 1 -&gt; 2 -&gt; 3 -&gt; 1 becomes 2 -&gt; 3 if 1 is not robbed.<br>Since every house is either robbed or not robbed and at least half of the houses are not robbed, the solution is simply the larger of two cases with consecutive houses, i.e. house i not robbed, break the circle, solve it, or house i + 1 not robbed. Hence, the following solution. I chose i = n and i + 1 = 0 for simpler coding. But, you can choose whichever two consecutive ones.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">int</span> robCycle(<span class="keyword">int</span>[] nums) {</div><div class="line">        <span class="keyword">if</span> (nums.<span class="built_in">length</span> == <span class="number">0</span>) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (nums.<span class="built_in">length</span> == <span class="number">1</span>) {</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nums.<span class="built_in">length</span> == <span class="number">2</span>) {</div><div class="line">            <span class="keyword">return</span> Math.<span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Math.<span class="built_in">max</span>(rob(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.<span class="built_in">length</span> - <span class="number">1</span>)),</div><div class="line">                rob(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.<span class="built_in">length</span>)));</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3. Maximum Subarray题目，求最大连续子数组和。</strong></p>
<p>不用动态规划的解法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxSubArray(<span class="keyword">int</span>[] nums) {</div><div class="line">    <span class="keyword">int</span> sumMax = nums[<span class="number">0</span>], <span class="keyword">sum</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</div><div class="line">        <span class="keyword">sum</span> += num;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">sum</span> &lt; num) {</div><div class="line">            <span class="keyword">sum</span> = num;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">sum</span> &gt;= sumMax) {</div><div class="line">            sumMax = <span class="keyword">sum</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sumMax;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>动态规划的状态转移方程：dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1]);</p>
<p>用动态规划的自底向上解法, 时间复杂度O(n)，空间复杂度O(n)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayDP</span>(<span class="keyword">int</span>[] nums) {</div><div class="line">    <span class="keyword">int</span> sumMax = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) {</div><div class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</div><div class="line">        sumMax = Math.max(sumMax, dp[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sumMax;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>用带备忘录的自底向上动态规划的解法, 时间复杂度O(n)，空间复杂度O(1)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayDPWithMem</span>(<span class="keyword">int</span>[] nums) {</div><div class="line">    <span class="keyword">int</span> sumMax = nums[<span class="number">0</span>], sumPre = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) {</div><div class="line">        sumPre = Math.max(sumPre + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</div><div class="line">        sumMax = Math.max(sumMax, sumPre);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sumMax;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4. Interleaving String题目，Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</strong><br>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,<br>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
<p>动态规划的递归调用解法，时间复杂度不符合要求。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public <span class="type">boolean</span> isInterleaveRecursiveDP(String s1, String s2, String s3) {</div><div class="line">    <span class="keyword">if</span> (s3.<span class="property">length</span>() != s1.<span class="property">length</span>() + s2.<span class="property">length</span>()) {</div><div class="line"><span class="command">        return</span> <span class="constant">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s1.<span class="property">length</span>() == <span class="number">0</span> && s2.<span class="property">length</span>() == <span class="number">0</span> && s3.<span class="property">length</span>() == <span class="number">0</span>) {</div><div class="line"><span class="command">        return</span> <span class="constant">true</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (s3.<span class="property">length</span>() == <span class="number">0</span>) {</div><div class="line"><span class="command">        return</span> <span class="constant">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    String newS3 = s3.substring(<span class="number">0</span>, s3.<span class="property">length</span>() - <span class="number">1</span>);</div><div class="line">    String newS1 = s1.<span class="property">length</span>() &gt; <span class="number">0</span> ? s1.substring(<span class="number">0</span>, s1.<span class="property">length</span>() - <span class="number">1</span>) : <span class="string">""</span>;</div><div class="line">    String newS2 = s2.<span class="property">length</span>() &gt; <span class="number">0</span> ? s2.substring(<span class="number">0</span>, s2.<span class="property">length</span>() - <span class="number">1</span>) : <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="type">boolean</span> equalS1 = s1.<span class="property">length</span>() &gt; <span class="number">0</span> && (s1.charAt(s1.<span class="property">length</span>() - <span class="number">1</span>) == s3.charAt(s3.<span class="property">length</span>() -</div><div class="line">            <span class="number">1</span>));</div><div class="line">    <span class="type">boolean</span> equalS2 = s2.<span class="property">length</span>() &gt; <span class="number">0</span> && s2.charAt(s2.<span class="property">length</span>() - <span class="number">1</span>) == s3.charAt(s3.<span class="property">length</span>() -</div><div class="line">            <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (equalS1 && !equalS2) {</div><div class="line"><span class="command">        return</span> isInterleaveRecursiveDP(newS1, s2, newS3);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!equalS1 && equalS2) {</div><div class="line"><span class="command">        return</span> isInterleaveRecursiveDP(s1, newS2, newS3);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (equalS1 && equalS2) {</div><div class="line"><span class="command">        return</span> isInterleaveRecursiveDP(newS1, s2, newS3) || isInterleaveRecursiveDP(s1, newS2, newS3);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line"><span class="command">        return</span> <span class="constant">false</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>动态规划带备忘录自底向上的解法，难点就在于如何将解法1的递归公式转化为动态转移方程，下述代码构造的二维数组很好地诠释了这一点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public <span class="type">boolean</span> isInterleaveDP(String s1, String s2, String s3) {</div><div class="line">    <span class="keyword">if</span> (s3.<span class="property">length</span>() != s1.<span class="property">length</span>() + s2.<span class="property">length</span>())</div><div class="line"><span class="command">        return</span> <span class="constant">false</span>;</div><div class="line"></div><div class="line">    <span class="type">boolean</span>[][] table = new <span class="type">boolean</span>[s1.<span class="property">length</span>() + <span class="number">1</span>][s2.<span class="property">length</span>() + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; s1.<span class="property">length</span>() + <span class="number">1</span>; i++)</div><div class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; s2.<span class="property">length</span>() + <span class="number">1</span>; j++) {</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> && j == <span class="number">0</span>)</div><div class="line">                table[i][j] = <span class="constant">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">                table[i][j] = (table[i][j - <span class="number">1</span>] && s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</div><div class="line">                table[i][j] = (table[i - <span class="number">1</span>][j] && s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</div><div class="line">            <span class="keyword">else</span></div><div class="line">                table[i][j] = (table[i - <span class="number">1</span>][j] && s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>) ||</div><div class="line">                        (table[i][j - <span class="number">1</span>] && s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>)));</div><div class="line">        }</div><div class="line"><span class="command"></span></div><div class="line">    return table[s1.<span class="property">length</span>()][s2.<span class="property">length</span>()];</div><div class="line">}</div></pre></td></tr></table></figure>


        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/21/动态规划算法/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/13/Java线程中断/" title="Java线程中断" itemprop="url">Java线程中断</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-04-13T05:55:58.000Z" itemprop="datePublished"> Published Apr 13 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>一、Java中断的现象<br>首先，看看Thread类里的几个方法：<br>public static boolean interrupted    测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。<br>public boolean isInterrupted()    测试线程是否已经中断。线程的中断状态 不受该方法的影响。<br>public void interrupt()    中断线程。</p>
<p>Thread.interrupt API:<br>Interrupts this thread. First the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p>
<p>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p>
<p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p>
<p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span>() {</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</div><div class="line">            checkAccess();</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (blockerLock) {</div><div class="line">            Interruptible b = blocker;</div><div class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</div><div class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></div><div class="line">                b.interrupt(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        interrupt0();</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>其实，Java的中断是一种协作机制。也就是说调用线程对象的interrupt方法并不一定就中断了正在运行的线程，它只是要求线程自己在合适的时机中断自己。每个线程都有一个boolean的中断状态（不一定就是对象的属性，事实上，该状态也确实不是Thread的字段），interrupt方法仅仅只是将该状态置为true<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) { </div><div class="line">Thread t = <span class="keyword">new</span> MyThread(); </div><div class="line">t.start(); </div><div class="line">t.interrupt(); </div><div class="line">System.out.println(<span class="string">"已调用线程的interrupt方法"</span>); </div><div class="line">} </div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() { </div><div class="line"><span class="keyword">int</span> num = longTimeRunningNonInterruptMethod(<span class="number">2</span>, <span class="number">0</span>); </div><div class="line">System.out.println(<span class="string">"长时间任务运行结束,num="</span> + num); </div><div class="line">System.out.println(<span class="string">"线程的中断状态:"</span> + Thread.interrupted()); </div><div class="line">} </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> longTimeRunningNonInterruptMethod(<span class="keyword">int</span> <span class="keyword">count</span>, <span class="keyword">int</span> initNum) { </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">count</span>; i++) { </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;Integer.MAX_VALUE; j++) { </div><div class="line">initNum ++; </div><div class="line">} </div><div class="line">} </div><div class="line"><span class="keyword">return</span> initNum; </div><div class="line">} </div><div class="line">} </div><div class="line">}</div></pre></td></tr></table></figure>

<p>一般情况下，会打印如下内容：<br>已调用线程的interrupt方法<br>长时间任务运行结束,num=-2<br>线程的中断状态:true<br>可见，interrupt方法并不一定能中断线程。但是，如果改成下面的程序，情况会怎样呢？<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.TimeUnit; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) { </div><div class="line">Thread t = <span class="keyword">new</span> MyThread(); </div><div class="line">t.start(); </div><div class="line">t.interrupt(); </div><div class="line">System.out.println(<span class="string">"已调用线程的interrupt方法"</span>); </div><div class="line">} </div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() { </div><div class="line"><span class="keyword">int</span> num = -<span class="number">1</span>; </div><div class="line"><span class="keyword">try</span> { </div><div class="line">num = longTimeRunningInterruptMethod(<span class="number">2</span>, <span class="number">0</span>); </div><div class="line">} <span class="keyword">catch</span> (InterruptedException e) { </div><div class="line">System.out.println(<span class="string">"线程被中断"</span>); </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </div><div class="line">} </div><div class="line">System.out.println(<span class="string">"长时间任务运行结束,num="</span> + num); </div><div class="line">System.out.println(<span class="string">"线程的中断状态:"</span> + Thread.interrupted()); </div><div class="line">} </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> longTimeRunningInterruptMethod(<span class="keyword">int</span> <span class="keyword">count</span>, <span class="keyword">int</span> initNum) throws InterruptedException{ </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">count</span>; i++) { </div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>); </div><div class="line">} </div><div class="line"><span class="keyword">return</span> initNum; </div><div class="line">} </div><div class="line">} </div><div class="line">}</div></pre></td></tr></table></figure>

<p>经运行可以发现，程序抛出异常停止了，run方法里的后两条打印语句没有执行。那么，区别在哪里？<br>一般说来，如果一个方法声明抛出InterruptedException，表示该方法是可中断的（没有在方法中处理中断却也声明抛出InterruptedException的除外），也就是说可中断方法会对interrupt调用做出响应（例如sleep响应interrupt的操作包括清除中断状态，抛出InterruptedException），如果interrupt调用是在可中断方法之前调用，可中断方法一定会处理中断，像上面的例子，interrupt方法极可能在run未进入sleep的时候就调用了，但sleep检测到中断，就会处理该中断。如果在可中断方法正在执行中的时候调用interrupt，会怎么样呢？这就要看可中断方法处理中断的时机了，只要可中断方法能检测到中断状态为true，就应该处理中断。让我们为开头的那段代码加上中断处理。<br>那么自定义的可中断方法该如何处理中断呢？那就是在适合处理中断的地方检测线程中断状态并处理。<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception { </div><div class="line">Thread t = <span class="keyword">new</span> MyThread(); </div><div class="line">t.start(); </div><div class="line"><span class="comment">// TimeUnit.SECONDS.sleep(1);//如果不能看到处理过程中被中断的情形，可以启用这句再看看效果 </span></div><div class="line">t.interrupt(); </div><div class="line">System.out.println(<span class="string">"已调用线程的interrupt方法"</span>); </div><div class="line">} </div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Thread</span> </span>{ </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() { </div><div class="line"><span class="keyword">int</span> num; </div><div class="line"><span class="keyword">try</span> { </div><div class="line">num = longTimeRunningNonInterruptMethod(<span class="number">2</span>, <span class="number">0</span>); </div><div class="line">} <span class="keyword">catch</span> (InterruptedException e) { </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e); </div><div class="line">} </div><div class="line">System.out.println(<span class="string">"长时间任务运行结束,num="</span> + num); </div><div class="line">System.out.println(<span class="string">"线程的中断状态:"</span> + Thread.interrupted()); </div><div class="line">} </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> longTimeRunningNonInterruptMethod(<span class="keyword">int</span> <span class="keyword">count</span>, <span class="keyword">int</span> initNum) throws InterruptedException { </div><div class="line"><span class="keyword">if</span>(interrupted()) { </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">"正式处理前线程已经被请求中断"</span>); </div><div class="line">} </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">count</span>; i++) { </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;Integer.MAX_VALUE; j++) { </div><div class="line">initNum ++; </div><div class="line">} </div><div class="line"><span class="comment">//假如这就是一个合适的地方 </span></div><div class="line"><span class="keyword">if</span>(interrupted()) { </div><div class="line"><span class="comment">//回滚数据，清理操作等 </span></div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">"线程正在处理过程中被中断"</span>); </div><div class="line">} </div><div class="line">} </div><div class="line"><span class="keyword">return</span> initNum; </div><div class="line">} </div><div class="line">} </div><div class="line">}</div></pre></td></tr></table></figure>

<p>如上面的代码，方法longTimeRunningMethod此时已是一个可中断的方法了。在进入方法的时候判断是否被请求中断，如果是，就不进行相应的处理了；处理过程中，可能也有合适的地方处理中断，例如上面最内层循环结束后。<br>这段代码中检测中断用了Thread的静态方法interrupted，它将中断状态置为false，并将之前的状态返回，而isInterrupted只是检测中断，并不改变中断状态。一般来说，处理过了中断请求，应该将其状态置为false。但具体还要看实际情形。 </p>
<p>二、Java中断的本质<br>在历史上，Java试图提供过抢占式限制中断，但问题多多，例如已被废弃的Thread.stop、Thread.suspend和 Thread.resume等。另一方面，出于Java应用代码的健壮性的考虑，降低了编程门槛，减少不清楚底层机制的程序员无意破坏系统的概率。<br>如今，Java的线程调度不提供抢占式中断，而采用协作式的中断。其实，协作式的中断，原理很简单，就是轮询某个表示中断的标记，我们在任何普通代码的中都可以实现。 例如下面的代码：<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> isInterrupted; </div><div class="line"><span class="comment">//… </span></div><div class="line"><span class="keyword">while</span>(!isInterrupted) { </div><div class="line">compute(); </div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，上述的代码问题也很明显。当compute执行时间比较长时，中断无法及时被响应。另一方面，利用轮询检查标志变量的方式，想要中断wait和sleep等线程阻塞操作也束手无策。<br>如果仍然利用上面的思路，要想让中断及时被响应，必须在虚拟机底层进行线程调度的对标记变量进行检查。是的，JVM中确实是这样做的。下面摘自java.lang.Thread的源代码：<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span>() { </div><div class="line"><span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>); </div><div class="line">} </div><div class="line"><span class="comment">//… </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span>(<span class="keyword">boolean</span> ClearInterrupted);</div></pre></td></tr></table></figure>

<p>可以发现，isInterrupted被声明为native方法，取决于JVM底层的实现。<br>实际上，JVM内部确实为每个线程维护了一个中断标记。但应用程序不能直接访问这个中断变量，必须通过下面几个方法进行操作：<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Thread { </div><div class="line">//设置中断标记 </div><div class="line">public void interrupt() { <span class="keyword">...</span> } </div><div class="line">//获取中断标记的值 </div><div class="line">public boolean isInterrupted() { <span class="keyword">...</span> } </div><div class="line">//清除中断标记，并返回上一次中断标记的值 </div><div class="line">public static boolean interrupted() { <span class="keyword">...</span> } </div><div class="line"><span class="keyword">...</span> </div><div class="line">}</div></pre></td></tr></table></figure>

<p>通常情况下，调用线程的interrupt方法，并不能立即引发中断，只是设置了JVM内部的中断标记。因此，通过检查中断标记，应用程序可以做一些特殊操作，也可以完全忽略中断。</p>
<p>你可能想，如果JVM只提供了这种简陋的中断机制，那和应用程序自己定义中断变量并轮询的方法相比，基本也没有什么优势。</p>
<p>JVM内部中断变量的主要优势，就是对于某些情况，提供了模拟自动“中断陷入”的机制。<br>在执行涉及线程调度的阻塞调用时（例如wait、sleep和join），如果发生中断，被阻塞线程会“尽可能快的”抛出InterruptedException。因此，我们就可以用下面的代码框架来处理线程阻塞中断：<br>代码如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> { </div><div class="line"><span class="comment">//wait、sleep或join </span></div><div class="line">} </div><div class="line"><span class="keyword">catch</span>(InterruptedException e) { </div><div class="line"><span class="comment">//某些中断处理工作 </span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所谓“尽可能快”，我猜测JVM就是在线程调度调度的间隙检查中断变量，速度取决于JVM的实现和硬件的性能。 </p>
<p>三、一些不会抛出 InterruptedException 的线程阻塞操作<br>然而，对于某些线程阻塞操作，JVM并不会自动抛出InterruptedException异常。例如，某些I/O操作和内部锁操作。对于这类操作，可以用其他方式模拟中断：<br>1）java.io中的异步socket I/O<br>读写socket的时候，InputStream和OutputStream的read和write方法会阻塞等待，但不会响应java中断。不过，调用Socket的close方法后，被阻塞线程会抛出SocketException异常。<br>2）利用Selector实现的异步I/O<br>如果线程被阻塞于Selector.select（在java.nio.channels中），调用wakeup方法会引起ClosedSelectorException异常。<br>3）锁获取<br>如果线程在等待获取一个内部锁，我们将无法中断它。但是，利用Lock类的lockInterruptibly方法，我们可以在等待锁的同时，提供中断能力。 </p>
<p>四、两条编程原则<br>另外，在任务与线程分离的框架中，任务通常并不知道自身会被哪个线程调用，也就不知道调用线程处理中断的策略。所以，在任务设置了线程中断标记后，并不能确保任务会被取消。因此，有以下两条编程原则：<br>1）除非你知道线程的中断策略，否则不应该中断它。<br>这条原则告诉我们，不应该直接调用Executer之类框架中线程的interrupt方法，应该利用诸如Future.cancel的方法来取消任务。</p>
<p>2）任务代码不该猜测中断对执行线程的含义。<br>这条原则告诉我们，一般代码遇在到InterruptedException异常时，不应该将其捕获后“吞掉”，而应该继续向上层代码抛出。<br>总之，Java中的非抢占式中断机制，要求我们必须改变传统的抢占式中断思路，在理解其本质的基础上，采用相应的原则和模式来编程。</p>
<p>总结：</p>
<p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制，能够使一个线程终止另一个线程的的工作。—— 『Java并发编程实战』 第7章 取消与关闭 p111</p>
<p>中断是一种协作机制。一个线程不能强制其它线程停止正在执行的操作而去执行其它的操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是如果线程B愿意停下来。—— 『Java并发编程实战』 第5章 基础构建模块 p77</p>
<p>总之，中断只是一种协作机制，需要被中断的线程自己处理中断。停止一个线程最佳实践是 中断 + 条件变量。<br>refer：</p>
<blockquote>
<p><a href="http://www.infoq.com/cn/articles/java-interrupt-mechanism" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-interrupt-mechanism</a><br>《Java Concurrency in Practice》<br>《Concurrent Programming in Java Design principles and patterns》<br><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/misc/threadPrimitiveDeprecation.html" target="_blank" rel="external">http://docs.oracle.com/javase/1.4.2/docs/guide/misc/threadPrimitiveDeprecation.html</a><br><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="external">http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/13/Java线程中断/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/13/-转-数据库的乐观锁和悲观锁/" title="[转]数据库的乐观锁和悲观锁" itemprop="url">[转]数据库的乐观锁和悲观锁</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-04-13T03:06:28.000Z" itemprop="datePublished"> Published Apr 13 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="悲观锁">悲观锁</h4>
<p>悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。</p>
<p><br></p>
<h4 id="乐观锁">乐观锁</h4>
<p>乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。</p>
<p><br></p>
<h4 id="例子">例子</h4>
<p>以版本控制系统为例，来说说两种最基本的并发性问题。  </p>
<p><br></p>
<h6 id="【丢失更新】">【丢失更新】</h6>
<p>  小张想修改源代码里面的a方法，正在她修改的同时，小李打开了这个文件，修改了b方法并且保存了文件，等小张修改完成后，保存文件，小李所做的修改就被覆盖了。 </p>
<p><br></p>
<h6 id="【不一致的读】">【不一致的读】</h6>
<p>  小张想要知道包里面一共有多少个类，包分了a，b两个子包。小张打开a包，看到了7个类。突然小张接到老婆打来的电话，在小张接电话的时候，小李往a包中加了2个类，b包中加了3个类（原先b包中是5个类）。  </p>
<p>小张接完电话后再打开b包，看到了8个类，很自然得出结论：包中一共有15个类。  </p>
<p>很遗憾，15个永远不是正确的答案。在小李修改前，正确答案是12（7+5），修改后是17（9+8）。这两个答案都是正确的，虽然有一个不是当前的。但15不对，因为小张读取的数据是不一致的。  </p>
<p>小结：不一致读指你要读取两种数据，这两种数据都是正确的，但是在同一时刻两者并非都正确。  </p>
<p><br></p>
<h4 id="隔离和不可变">隔离和不可变</h4>
<p><strong> 在企业应用中，解决并发冲突的两种常用手段是隔离和不可变。</strong> </p>
<p>只有当多个活动（进程或者线程）同时访问同一数据时才会引发并发问题。一种很自然的思路就是同一时刻只允许一个活动访问数据。如果小张打开了文件，就不允许其他人打开，或者其他人只能通过只读的方式打开副本，就可以解决这个问题。  </p>
<p>隔离能够有效减少发生错误的可能。我们经常见到程序员陷入到并发问题的泥潭里，每一段代码写完都要考虑并发问题，这样太累了。我们可以利用隔离技术创建出隔离区域，当程序进入隔离区域时不用关心并发问题。好的并发性设计就是创造这样的一些隔离区域，并保证代码尽可能的运行在其中。  </p>
<p>另一种思路：只有当你需要修改共享的数据时才可能引发并发性问题，所以我们可以将要共享的数据制作为“不可变”的，以避免并发性问题。当然我们不可能将所有的数据都做成不可变的，但如果一些数据是不可变的，对它们进行并发操作时我们就可以放松自己的神经了。  </p>
<p><br></p>
<h4 id="乐观并发控制、悲观并发控制">乐观并发控制、悲观并发控制</h4>
<p>如果数据是可变的，并且无法隔离呢？这种情况下最常用的两种控制就是乐观并发控制和悲观并发控制。  </p>
<p>假设小张和小李想要同时修改同一个文件。如果使用乐观锁，俩人都能打开文件进行修改，如果小张先提交了内容，没有问题，他所做的改变会保存到服务器上。但小李提交时就会遇到麻烦，版本控制服务器会检测出两种修改的冲突，小李的提交会被具体，并由小李决定该如何处理这种情况（对于绝大部分版本控制软件来说，会读取并标识出小张做的改变，然后由小李决定是否合并）。  </p>
<p>如果使用的是悲观锁，小张先检出（check out）文件，那么小李就无法再次检出同一文件，直到小张提交了他的改变。  </p>
<p>建议你将乐观锁想成一种检测冲突的手段，而悲观锁是一种避免冲突的手段（严格来说，乐观锁其实不能称之为“锁”，但是这个名字已经流传开了，那就继续使用吧）。一些老的版本控制系统，比如VSS 6.0使用的是悲观锁的机制。而现代的版本控制系统一般两种都支持，默认使用乐观锁。  </p>
<p><strong> 乐观锁可以提高并发访问的效率，但是如果出现了冲突只能向上抛出，然后重来一遍；悲观锁可以避免冲突的发生，但是会降低效率。 </strong></p>
<p>选择使用那一种锁取决于访问频率和一旦产生冲突的严重性。如果系统被并发访问的概率很低，或者冲突发生后的后果不太严重（所谓后果应该指被检测到冲突的提交会失败，必须重来一次），可以使用乐观锁，否则使用悲观锁。  </p>
<p><br></p>
<h4 id="实现">实现</h4>
<p>  我们经常会在访问数据库的时候用到锁，怎么实现乐观锁和悲观锁呢？以Hibernate为例，可以通过为记录添加版本或时间戳字段来实现乐观锁。可以用session.Lock()锁定对象来实现悲观锁（本质上就是执行了SELECT * FROM t FOR UPDATE语句）。 </p>
<p><br></p>
<h6 id="转至：">转至：</h6>
<blockquote>
<p><a href="http://www.cnblogs.com/chenlulouis/archive/2010/08/17/1801358.html" target="_blank" rel="external">http://www.cnblogs.com/chenlulouis/archive/2010/08/17/1801358.html</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/mysql/">mysql</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/13/-转-数据库的乐观锁和悲观锁/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/10/Shell常用技巧/" title="Shell常用技巧" itemprop="url">Shell常用技巧</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-04-10T03:43:31.000Z" itemprop="datePublished"> Published Apr 10 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="grep常用技巧">grep常用技巧</h4>
<p>grep匹配TAB</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">直接<span class="keyword">grep</span> <span class="keyword">tab</span>字符 //命令行下用”ESC TAB”输入</div><div class="line"><span class="keyword">grep</span> $<span class="string">'\t'</span></div></pre></td></tr></table></figure>

<p>grep匹配减号</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> <span class="keyword">file</span> | <span class="keyword">grep</span> -- -<span class="number">1</span></div></pre></td></tr></table></figure>

<p>去除所有空行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> <span class="keyword">file</span> | <span class="keyword">grep</span> -<span class="keyword">v</span> <span class="string">"^$"</span> &gt; file2</div></pre></td></tr></table></figure>

<p>只显示以a开头的行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> <span class="keyword">file</span> | <span class="keyword">grep</span> <span class="string">'^a'</span></div></pre></td></tr></table></figure>

<p>显示log中error附近的内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> <span class="keyword">file</span> | <span class="keyword">grep</span> -C5 <span class="string">"error"</span></div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="awk常用技巧">awk常用技巧</h4>
<p>隔行显示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> <span class="keyword">file</span> | awk <span class="string">'{getline; print $1;}'</span></div></pre></td></tr></table></figure>

<p>取奇数/偶数行数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'NR%2==1'</span> <span class="keyword">file</span>  <span class="comment">//显示奇数行</span></div><div class="line">awk <span class="string">'NR%2==0'</span> <span class="keyword">file</span>  <span class="comment">//显示偶数行</span></div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="vim常用技巧">vim常用技巧</h4>
<p>vim下将x替换成制表符</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="title">s</span></span>/x/^I</div><div class="line">p.s: 直接按TAB就可以啦 ,不需要用转义序列\t的</div></pre></td></tr></table></figure>

<p>vim下将x替换成换行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">%<span class="title">s</span></span>/x/\r</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="sed常用技巧">sed常用技巧</h4>
<p>查看文件选定的行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wc -l  <span class="operator">a</span>.txt <span class="comment"> //统计a.txt 行数</span></div><div class="line">sed -n <span class="string">'190,196p'</span> <span class="operator">a</span>.txt<span class="comment"> //查看第190行到第196行</span></div><div class="line">sed -n <span class="string">'190,1p'</span> <span class="operator">a</span>.txt<span class="comment"> //查看第190行</span></div></pre></td></tr></table></figure>


        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/10/Shell常用技巧/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/04/JVM编码方式未设置引发的乱码/" title="JVM编码方式未设置引发的乱码" itemprop="url">JVM编码方式未设置引发的乱码</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-02-04T14:37:58.000Z" itemprop="datePublished"> Published Feb 4 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h6 id="现象：">现象：</h6>
<p>服务中出现大量乱码数据，并且全部入库。</p>
<h6 id="原因：">原因：</h6>
<p>虽然maven项目的pom.xml文件中已配置成UTF-8，并且打出的jar包编码也是UTF-8，但运行时出现中文全是乱码。<br>发现是系统环境变量中未设置LANG相关变量为UTF-8导致的。</p>
<h6 id="分析：">分析：</h6>
<p>这是表面原因，究其根本，为什么JVM运行jar包的编码方式会依赖系统环境变量呢？查到原因是因为运行jar包时未指定jvm的 file.encoding参数，改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dfile.encoding=UTF-<span class="number">8</span> XXX 后彻底解决。</div></pre></td></tr></table></figure>

<p>但是这样发布服务时就太依赖发布脚本了，那能否在程序中就设置好编码呢？比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"file.encoding"</span>, <span class="string">"UTF-8"</span>);</div></pre></td></tr></table></figure>

<p>其实，这样设置是不生效的，因为JVM在启动时就开始cache编码方式了，程序中再设置已然无效。不过可以在程序每个读写数据的地方都设置编码方式，但是这样未免太工程浩大，而且无法保证每个写代码的人都能做到。所以最后改为依赖在发布脚本中设置编码方式，并且在服务启动时对编码进行检查。</p>
<h6 id="refer:">refer:</h6>
<blockquote>
<p>As Edward Grech points out, in a special case like this, the environment variable JAVA_TOOL_OPTIONS can be used to specify this property, but it’s normally done like this: java -Dfile.encoding=UTF-8 XXX</p>
<p>Charset.defaultCharset() will reflect changes to the file.encoding property, but most of the code in the core Java libraries that need to determine the default character encoding do not use this mechanism.</p>
<p><strong>Important points to note:</strong></p>
<ul>
<li>JVM caches value of default character encoding once JVM starts and so is the case for default constructors of InputStreamReader and other core Java classes. So calling System.setProperty(“file.encoding” , “UTF-16”) may not have desire effect.</li>
<li>Always work with your own character encoding if you can, that is more accurate and precise way of converting bytes to Strings.</li>
</ul>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/02/04/JVM编码方式未设置引发的乱码/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/03/Iterator详解/" title="Iterator详解" itemprop="url">Iterator详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-02-03T02:56:08.000Z" itemprop="datePublished"> Published Feb 3 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Iterator详解">Iterator详解</h1>
<p>Iterator是java中的一个接口，借用源码中的注释：<br>An iterator over a collection.  {@code Iterator} takes the place of {@link Enumeration} in the Java Collections Framework. Iterators differ from enumerations in two ways:</p>
<ul>
<li>Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.</li>
<li>Method names have been improved.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">	... ...	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>需要迭代器的地方实现这个接口。集合的基本类Collection就实现了这个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">	... ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>举例来看下java的ArrayList类迭代器的实现。<br>ArrayList中iterator()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>再来看Itr的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * An optimized version of AbstractList.Itr</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span>() {</div><div class="line">        <span class="keyword">return</span> cursor != size;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> E <span class="title">next</span>() {</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        cursor = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>() {</div><div class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet); <span class="comment">// 见下文代码</span></div><div class="line">            cursor = lastRet;</div><div class="line">            lastRet = -<span class="number">1</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span>(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer) {</div><div class="line">        Objects.requireNonNull(consumer);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        }</div><div class="line">        <span class="keyword">while</span> (i != size && modCount == expectedModCount) {</div><div class="line">            consumer.accept((E) elementData[i++]);</div><div class="line">        }</div><div class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></div><div class="line">        cursor = i;</div><div class="line">        lastRet = i - <span class="number">1</span>;</div><div class="line">        checkForComodification();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> checkForComodification() {</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<p>调ArrayList.this.remove(lastRet)时，remove的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> E <span class="title">remove</span>(<span class="keyword">int</span> index) {</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以使用iterator来遍历List集合时，不能对list增删元素。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/02/03/Iterator详解/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/03/HashMap源码分析/" title="HashMap实现原理" itemprop="url">HashMap实现原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2015-02-02T16:30:01.000Z" itemprop="datePublished"> Published Feb 3 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="HashMap源码分析">HashMap源码分析</h1>
<h2 id="1-_概要">1. 概要</h2>
<ul>
<li>HashMap是基于Map接口实现的，提供了所有Map支持的操作，并且允许key和value为null。HashMap可以近似地认为是HashTable，其差别仅在于前者允许null的key,value，并且操作不是同步的(unsynchronized)。</li>
<li>Iteration遍历整个hashMap的时间与hashMap的capacity(buckets的数量)加上hashMap的size的值是成正比的，所以如果想要高效地遍历HashMap，就不要将capacity的初始值设置的太高，也不要将load factor设置的太低。</li>
<li>衡量HashMap性能的指标只有两个，一个是capacity的初始值，一个是load factor。</li>
<li>capacity是指hash表中buckets的数量，而capacity的初始值是指当hash表被创建时capacity被设定的值。</li>
<li>load factor是用来衡量当hash表扩容之前有多满的指标。load_factor = put_size/size</li>
<li>当hash表的元素超过了阈值(loadFactor*capacity)时会自动将内部数据重建一遍，并将buckets的数量翻倍，这个过程称为rehash。</li>
<li>根据经验来讲，当load factor为0.75时，较好地权衡了时间和空间上的取舍。load factor高虽然能减少空间的消耗但是增加了查询的代价，主要反映在put和get操作。</li>
<li>当设定capacity初始值时需要考虑map中期望地元素个数和load factor，这样能最小化rehash的次数。如果capacity初始值大于最大元素个数除以load factor的值，则永远不会发生load factor操作。</li>
<li>如果有很多mapping都要存放到同一个HashMap，那么在最开始就设置一个充足的capacity比当hash表超过阈值后再rehash要高效地多。</li>
<li><strong>请注意</strong>：所以的实现都不是synchronized的，如果有多个线程同时操作HashMap，并且有线程会修改HashMap的结构时，则必须要对此操作加synchronized标识。增加或删除HashMap中的元素都算是修改HashMap的结构，如果仅仅只是修改某个key的value则不算。</li>
<li>如果没有可以对HashMap做synchronized的对象，那么可以使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(…)</div></pre></td></tr></table></figure>

<p>来生成一个同步操作的Map.</p>
<h2 id="2-_HashMap的实现">2. HashMap的实现</h2>
<h3 id="2-1_Fields">2.1 Fields</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;;<span class="comment">//存储元素的实体数组</span></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//Holds cached entrySet()</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//存放元素的个数</span></div><div class="line"><span class="keyword">int</span> threshold; <span class="comment">//当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量, DEFAULT_INITIAL_CAPACITY</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//加载因子</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//This field is used to make iterators on Collection-views of the HashMap fail-fast</span></div></pre></td></tr></table></figure>

<h3 id="2-2_实现">2.2 实现</h3>
<h4 id="2-2-1_java8的改进点">2.2.1 java8的改进点</h4>
<pre><code> java.util.HashMap 是JDK里散列的一个实现，JDK6里采用位桶+链表的形式实现，Java8里采用的是位桶+链表/红黑树的方式，this will improve <span class="operator">the</span> worst <span class="keyword">case</span> performance <span class="built_in">from</span> O(n) <span class="built_in">to</span> O(<span class="built_in">log</span> n).。
</code></pre><h4 id="2-2-2_访问map的过程">2.2.2 访问map的过程</h4>
<p>仅以put操作为例来说明，put操作的过程：<br>     当未冲突时；put的位置为 (tab.length-1)&amp;key.hashCode()<br>     当冲突时；如果冲突的位置上放的是TreeNode，则加入。否则加入冲突位置的元素链表的最末尾，如果加入后链表长度达到TREEIFY_THRESHOLD，则将链表转为红黑树。<br>     加入操作完成后，如果size大于threshold则resize。</p>
<h4 id="2-2-3_hashCode和size">2.2.3 hashCode和size</h4>
<p>hash函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> hash(Object key) {</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>tab.length的大小为2的幂次方，实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">* Returns a power of two size for the given target capacity.</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> tableSizeFor(<span class="keyword">int</span> cap) {</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="3-_遍历HashMap">3. 遍历HashMap</h2>
<p>当需要取出key-value时，推荐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Iterator iter = map.entrySet().iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) {</div><div class="line">    Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">    Object key = entry.getKey();</div><div class="line">    Object val = entry.getValue();</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="4-_遍历时操作">4. 遍历时操作</h2>
<h3 id="4-1_遍历时remove">4.1 遍历时remove</h3>
<p>Removes the current element. Throws IllegalStateException if an attempt is made to call remove() that is not preceded by a call to next( ).</p>
<h3 id="4-2_keySet的使用">4.2 keySet的使用</h3>
<p>keySet没有实现add(E e)方法，所有当对keySet调用add方法时会抛出UnsupportedOperationException。<br>KeySet继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class KeySet extends AbstractSet&lt;K&gt;</div><div class="line"><span class="keyword">abstract</span> class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt;</div><div class="line"><span class="keyword">abstract</span> class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt;{</div><div class="line">     <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="4-3_直接使用subclass遍历时不允许修改map">4.3 直接使用subclass遍历时不允许修改map</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Instance key : InsMap.keySet()) {</div><div class="line">    keySet.remove(instance2);</div><div class="line">    System.out.println(InsMap.get(key));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>remove后第二遍进入for循环时会抛ConcurrentModificationException。<br>原因是KeySet, Values, EntrySet这三个subclass都不允许在遍历过程中map被修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span>(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action) {</div><div class="line">    Node&lt;K,V&gt;[] tab;</div><div class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> && (tab = table) != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">int</span> mc = modCount;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {</div><div class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</div><div class="line">                action.accept(e);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (modCount != mc)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/02/03/HashMap源码分析/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/12/25/Goog-Engineer-Keys/" title="Good Engineer Keys" itemprop="url">Good Engineer Keys</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2014-12-24T16:30:01.000Z" itemprop="datePublished"> Published Dec 25 2014</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>A good engineer has technical mastery.  A great engineer has these additional qualities:</p>
<ul>
<li><strong>Clear communication of complex ideas.</strong><br>Can the engineer explain themselves to non-technical stakeholders, as well as other engineers?  Many technically proficient engineers are not considered great because they can’t communicate their ideas.</li>
<li><strong>They love to code.</strong><br>Being an engineer is a great high paying job, which is why many good developers do it.  Great engineers would code even if that wasn’t the case.  They keep their skills current, and they have the stamina to power through long hours because they are doing what they love.<br>Desire to simplify instead of making things more complex.  Hard, complex challenges are often fun for developers.  Great engineers want to simplify the problem instead of building something complicated.</li>
<li><strong>A strong business and product sense.</strong><br>In the development of a feature, developers often need to make product decisions that aren’t covered in the spec.  Their ability to make the right call depends on an understanding of why a feature is good for the business, and how products should be built.</li>
<li><strong>They focus on the highest impact items.</strong><br>Good engineers get distracted.  Great engineers spend their time where it matters. </li>
<li><strong>Strong social skills.</strong><br>An engineer needs to effectively interact with people across the company to be great a their job. If they can only interact with other developers, then they are only good at their job.</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/promote/">promote</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/12/25/Goog-Engineer-Keys/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/11/14/hello-world/" title="Hello World" itemprop="url">Hello World</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2014-11-13T16:30:01.000Z" itemprop="datePublished"> Published Nov 14 2014</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p><em>single asterisks</em></p>
<p><strong>double asterisks</strong></p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/test/">test</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/11/14/hello-world/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/java/" title="java">java<sup>15</sup></a></li>
		
			<li><a href="/tags/算法/" title="算法">算法<sup>8</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>6</sup></a></li>
		
			<li><a href="/tags/调试/" title="调试">调试<sup>3</sup></a></li>
		
			<li><a href="/tags/coursera/" title="coursera">coursera<sup>2</sup></a></li>
		
			<li><a href="/tags/网络/" title="网络">网络<sup>2</sup></a></li>
		
			<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>2</sup></a></li>
		
			<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		
			<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
			<li><a href="/tags/安全/" title="安全">安全<sup>1</sup></a></li>
		
			<li><a href="/tags/spark/" title="spark">spark<sup>1</sup></a></li>
		
			<li><a href="/tags/skill/" title="skill">skill<sup>1</sup></a></li>
		
			<li><a href="/tags/Spark/" title="Spark">Spark<sup>1</sup></a></li>
		
			<li><a href="/tags/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		
			<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
		
			<li><a href="/tags/总结/" title="总结">总结<sup>1</sup></a></li>
		
			<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>1</sup></a></li>
		
			<li><a href="/tags/test/" title="test">test<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m ljp215 Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2017 
		
		<a href="http://luojinping.com/about" target="_blank" title="Jinping Luo">Jinping Luo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>





<script type="text/javascript">

var disqus_shortname = 'zane215';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>








<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fnull' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- MathJax End -->

  </body>
 </html>
