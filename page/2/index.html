<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zane Blog">
<meta property="og:url" content="http://luojinping.com/page/2/index.html">
<meta property="og:site_name" content="Zane Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zane Blog">
  <link rel="alternate" href="/atom.xml" title="Zane Blog" type="application/atom+xml">
  <link rel="canonical" href="http://luojinping.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Zane Blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a131554f93a9296cf819d0ecb926fc05";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zane Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">业精于勤荒于嬉，形成思毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2018/01/31/LeetCode-Trapping-Rain-Water/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/01/31/LeetCode-Trapping-Rain-Water/" class="post-title-link" itemprop="url">LeetCode-Trapping-Rain-Water</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：1月 31 2018 8:10:48" itemprop="dateCreated datePublished" datetime="2018-01-31T08:10:48+08:00">1月 31 2018</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 10:50:35" itemprop="dateModified" datetime="2019-08-25T10:50:35+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/01/31/LeetCode-Trapping-Rain-Water/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2018/01/31/LeetCode-Trapping-Rain-Water/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p>** problem link: **<br><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water</a></p>
<p><img src="/img/LeetCode_Trapping_Rain_Water.jpg" alt></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater_42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt;= b) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[a]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[b]);</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="comment">// leftMax is smaller than rightMax, so the (leftMax-A[a]) water can be stored</span></span><br><span class="line">                max += (leftMax - height[a]);</span><br><span class="line">                a++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max += (rightMax - height[b]);</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h2><p>对任意位置 i，在 i 上的积水，由左右两边最高的 bar 决定。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/12/Kafka-Consumer-的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/12/Kafka-Consumer-的实现/" class="post-title-link" itemprop="url">Kafka Consumer 的实现</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 12 2017 15:16:54" itemprop="dateCreated datePublished" datetime="2017-11-12T15:16:54+08:00">11月 12 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 11:49:24" itemprop="dateModified" datetime="2019-08-25T11:49:24+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/12/Kafka-Consumer-的实现/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/12/Kafka-Consumer-的实现/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>说明: kafka 版本号为 0.11.0</em></strong></p>
<h1 id="Consumer-拉取消息的实现"><a href="#Consumer-拉取消息的实现" class="headerlink" title="Consumer 拉取消息的实现"></a>Consumer 拉取消息的实现</h1><p>在 Kafka Consumer 正常消费时，观察其调用堆栈。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"pool-16-thread-7" #154 prio=5 os_prio=0 tid=0x00007ff581c8c000 nid=0x326d runnable [0x00007ff5468e7000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        ...</span><br><span class="line">        at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:433)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:232)</span><br><span class="line">        - locked &lt;0x00000000c2e04f90&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:208)</span><br><span class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:1096)</span><br><span class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1043)</span><br><span class="line">        at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:571)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>对应的代码实现是 <code>org.apache.kafka.clients.consumer.KafkaConsumer#poll</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">            <span class="keyword">long</span> start = time.milliseconds();</span><br><span class="line">            <span class="keyword">long</span> remaining = timeout;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollOnce(remaining);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests())</span><br><span class="line">                        client.pollNoWakeup();</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConsumerRecords&lt;&gt;(records);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">long</span> elapsed = time.milliseconds() - start;</span><br><span class="line">                remaining = timeout - elapsed;</span><br><span class="line">            &#125; <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>org.apache.kafka.clients.consumer.KafkaConsumer#pollOnce</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// ConsumerCoordinator coordinator;</span></span><br><span class="line">        coordinator.poll(time.milliseconds(), timeout);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">        Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</span><br><span class="line">        <span class="keyword">if</span> (!records.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> records;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send any new fetches (won't resend pending fetches)</span></span><br><span class="line">        fetcher.sendFetches();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> fetcher.fetchedRecords();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看到 consumer 每次 poll 时是先从 fetcher 中 fetchedRecords 的，如果拿不到结果，就新发起一个 sendFetches 请求。</p>
<h2 id="Consumer-拉取消息的数量"><a href="#Consumer-拉取消息的数量" class="headerlink" title="Consumer 拉取消息的数量"></a>Consumer 拉取消息的数量</h2><p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#fetchedRecords</code> 可以看到 <code>maxPollRecords</code>(max.poll.records 配置) 变量限制了每次 poll 的消息条数，不管 consumer 对应多少个 partition，从所有 partition 拉取到的消息条数总和不会超过 <code>maxPollRecords</code>。</p>
<p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#sendFetches</code> 可以看到 <code>fetchSize</code>(max.partition.fetch.bytes 配置) 用于每次创建 FetchRequest 时的 <code>org.apache.kafka.common.requests.FetchRequest.PartitionData</code> 的参数设置。<code>fetchSize</code>限制了 consumer 每次从每个 partition 拉取的数据量。<br>不过，还是看代码中的 <code>ConsumerConfig#MAX_PARTITION_FETCH_BYTES_DOC</code> 说明吧：</p>
<blockquote>
<p>The maximum amount of data per-partition the server will return. Records are fetched in batches by the consumer. If the first record batch in the first non-empty partition of the fetch is larger than this limit, the batch will still be returned to ensure that the consumer can make progress. The maximum record batch size accepted by the broker is defined via <code>message.max.bytes</code> (broker config) or <code>max.message.bytes</code> (topic config). See “ + FETCH_MAX_BYTES_CONFIG + “ for limiting the consumer request size.</p>
</blockquote>
<h3 id="poll-和-fetch-的关系"><a href="#poll-和-fetch-的关系" class="headerlink" title="poll 和 fetch 的关系"></a>poll 和 fetch 的关系</h3><p>在满足max.partition.fetch.bytes限制的情况下，假如fetch到了100个record，放到本地缓存后，由于max.poll.records限制每次只能poll出15个record。那么KafkaConsumer就需要执行7次才能将这一次通过网络发起的fetch请求所fetch到的这100个record消费完毕。其中前6次是每次pool中15个record，最后一次是poll出10个record。</p>
<h1 id="Consumer-的心跳机制"><a href="#Consumer-的心跳机制" class="headerlink" title="Consumer 的心跳机制"></a>Consumer 的心跳机制</h1><p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinat</code> 中启动 <code>HeartbeatThread</code> 线程来定时发送心跳和检查 consumer 的状态。<br>每个 Consumer 都有一个 ConsumerCoordinator(继承 AbstractCoordinator)，每个 ConsumerCoordinator 都启动一个 <code>HeartbeatThread</code> 线程来维护心跳，心跳信息存放在 <code>org.apache.kafka.clients.consumer.internals.Heartbeat</code>。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Heartbeat thread for group &#123;&#125; started"</span>, groupId);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        client.pollNoWakeup();</span><br><span class="line">                        <span class="keyword">long</span> now = time.milliseconds();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) &#123;</span><br><span class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></span><br><span class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></span><br><span class="line">                            coordinatorDead();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) &#123;</span><br><span class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></span><br><span class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></span><br><span class="line">                            maybeLeaveGroup();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) &#123;</span><br><span class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></span><br><span class="line">                            <span class="comment">// coordinator disconnected</span></span><br><span class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            heartbeat.sentHeartbeat(now);</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125; <span class="comment">// end synchronized</span></span><br><span class="line">              &#125; <span class="comment">// end while</span></span><br><span class="line">          &#125; <span class="comment">//end try              </span></span><br><span class="line">&#125; <span class="comment">// end run</span></span><br></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sessionTimeout"><a href="#sessionTimeout" class="headerlink" title="sessionTimeout"></a>sessionTimeout</h2><p>如果是 sessionTimeout 则 Mark the current coordinator as dead，此时  会将 consumer 踢掉，重新分配 partition 和 consumer 的对应关系。</p>
<p>在 Kafka Server 端，Consumer 的 Group 定义了五个状态：：<br><img src="/img/kafka_consumer_state_in_server.png" alt="Consumer Group State"></p>
<p>

</p><h2 id="pollTimeout"><a href="#pollTimeout" class="headerlink" title="pollTimeout"></a>pollTimeout</h2><p>如果是 pollTimeout 则 Reset the generation and memberId because we have fallen out of the group，此时 consumer 会退出 group，当再次 poll 时又会 rejoin group 触发 rebalance group。</p>
<h3 id="Rebalance-Generation"><a href="#Rebalance-Generation" class="headerlink" title="Rebalance Generation"></a>Rebalance Generation</h3><p>表示 rebalance 之后的一届成员，主要是用于保护 consumer group，隔离无效 offset 提交。每次 group 进行 rebalance 之后，generation 号都会加 1，表示 group 进入到了一个新的版本，下图所示为 consumer 2 退出后 consumer 4 加入时 Rebalance Generation 的过程：<br><img src="/img/Kafka_Rebalance_Generation.png" alt="Rebalance Generation"></p>
<h1 id="partition-的数量设置"><a href="#partition-的数量设置" class="headerlink" title="partition 的数量设置"></a>partition 的数量设置</h1><ul>
<li><p>一个 partition 只能被 Consumer Group 中的一个 consumer 消费，因此，为了提高并发量，可以提高 partition 的数量，但是这会造成 replica 副本拷贝的网络请求增加，故障恢复时的耗时增加。因为 kafka 使用 batch pull 的方式，所以单个线程的消费速率还是有保障的。并且 partition 数量过多，zk 维护 ISR 列表负载较重。</p>
</li>
<li><p>partiton 数量最好是 consumer 数目的整数倍，比如取 24， consumer 数目的设置就会灵活很多。</p>
</li>
<li><p>consumer 消费消息时不时严格有序的。当从多个 partition 读数据时，kafka 只保证在一个 partition 上数据是有序的，多个 partition 的消息消费很可能就不是严格有序的了。</p>
</li>
</ul>
<h1 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h1><h2 id="heartbeat-interval-ms"><a href="#heartbeat-interval-ms" class="headerlink" title="heartbeat.interval.ms"></a>heartbeat.interval.ms</h2><p>心跳间隔。心跳是在 consumer 与 coordinator 之间进行的。心跳是确定 consumer 存活，加入或者退出 group 的有效手段。<br>这个值必须设置的小于 session.timeout.ms，因为：<br>当 consumer 由于某种原因不能发 heartbeat 到 coordinator 时，并且时间超过 session.timeout.ms 时，就会认为该 consumer 已退出，它所订阅的 partition 会分配到同一 group 内的其它的 consumer 上。</p>
<h3 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h3><p>默认值：3000 (3s)，通常设置的值要低于session.timeout.ms的1/3。</p>
<p>
###session.timeout.ms
consumer session 过期时间。如果超时时间范围内，没有收到消费者的心跳，broker 会把这个消费者置为失效，并触发消费者负载均衡。因为只有在调用 poll 方法时才会发送心跳，更大的 session 超时时间允许消费者在 poll 循环周期内处理消息内容，尽管这会有花费更长时间检测失效的代价。如果想控制消费者处理消息的时间，

</p><h3 id="参数值-1"><a href="#参数值-1" class="headerlink" title="参数值"></a>参数值</h3><p>默认值：10000 (10s)，这个值必须设置在 broker configuration 中的 group.min.session.timeout.ms 与 group.max.session.timeout.ms 之间。</p>
<p>

</p><h2 id="max-poll-interval-ms"><a href="#max-poll-interval-ms" class="headerlink" title="max.poll.interval.ms"></a>max.poll.interval.ms</h2><p>This config sets the maximum delay between client calls to poll(). </p>
<p>When the timeout expires, the consumer will stop sending heartbeats and send an explicit LeaveGroup request. </p>
<p>As soon as the consumer resumes processing with another call to poll(), the consumer will <strong>rejoin the group</strong>. </p>
<p>By increasing the interval between expected polls, you can give the consumer more time to handle a batch of records returned frompoll(long). The drawback is that increasing this value may delay a group rebalance since the consumer will only join the rebalance inside the call to poll. You can use this setting to bound the time to finish a rebalance, but you risk slower progress if the consumer cannot actually call poll often enough.</p>
<p>参数设置大一点可以增加两次 poll 之间处理消息的时间。<br>当 consumer 一切正常(也就是保持着 heartbeat )，且参数的值小于消息处理的时长，会导致 consumer leave group 然后又 rejoin group，触发无谓的 group balance，出现 consumer livelock 现象。</p>
<p>但如果设置的太大，会延迟 group rebalance，因为消费者只会在调用 poll 时加入rebalance。</p>
<p>

</p><h2 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h2><p>Use this setting to limit the total records returned from a single call to poll. This can make it easier to predict the maximum that must be handled within each poll interval. By tuning this value, you may be able to reduce the poll interval, which will reduce the impact of group rebalancing.</p>
<p>0.11.0 Kafka 的默认配置是 </p>
<ul>
<li>max.poll.interval.ms=5min</li>
<li>max.poll.records=500</li>
</ul>
<p>即平均 600ms 要处理完一条消息，如果消息的消费时间高于 600ms，则一定要调整 max.poll.records 或 max.poll.interval.ms。</p>
<h1 id="Kafka-Javadoc-Detecting-Consumer-Failures"><a href="#Kafka-Javadoc-Detecting-Consumer-Failures" class="headerlink" title="Kafka Javadoc - Detecting Consumer Failures"></a>Kafka Javadoc - Detecting Consumer Failures</h1><p>After subscribing to a set of topics, the consumer will automatically join the group when poll(long) is invoked. The poll API is designed to ensure consumer liveness. As long as you continue to call poll, the consumer will stay in the group and continue to receive messages from the partitions it was assigned. Underneath the covers, the consumer sends periodic heartbeats to the server. If the consumer crashes or is unable to send heartbeats for a duration of session.timeout.ms, then the consumer will be considered dead and its partitions will be reassigned.<br>It is also possible that the consumer could encounter a “livelock” situation where it is continuing to send heartbeats, but no progress is being made. To prevent the consumer from holding onto its partitions indefinitely in this case, we provide a liveness detection mechanism using the max.poll.interval.ms setting. Basically if you don’t call poll at least as frequently as the configured max interval, then the client will proactively leave the group so that another consumer can take over its partitions. When this happens, you may see an offset commit failure (as indicated by a CommitFailedException thrown from a call to commitSync()). This is a safety mechanism which guarantees that only active members of the group are able to commit offsets. So to stay in the group, you must continue to call poll. </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cnblogs.com/huxi2b/p/6223228.html" target="_blank" rel="noopener">Kafka消费组(consumer group)</a><br><a href="https://kafka.apache.org/0101/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="noopener">kafka.apache.org javadoc</a><br><a href="http://blog.leanote.com/post/zfb050/Coordinator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">Coordinator实现原理</a><br><a href="http://debugo.com/kafka-params/" target="_blank" rel="noopener">kafka params</a><br><a href="http://blog.csdn.net/u014393917/article/details/52043185" target="_blank" rel="noopener">kafka源码分析之kafka的consumer的负载均衡管理</a><br><a href="http://www.cnblogs.com/devos/p/5656232.html" target="_blank" rel="noopener">Group Management Protocol</a><br><a href="http://matt33.com/2017/01/16/kafka-group/" target="_blank" rel="noopener">Kafka 之 Group 状态变化分析及 Rebalance 过程</a><br><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-62%3A+Allow+consumer+to+send+heartbeats+from+a+background+thread" target="_blank" rel="noopener">KIP-62: Allow consumer to send heartbeats from a background thread</a><br><a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch04.html" target="_blank" rel="noopener">Kafka: The Definitive Guide Chapter 4 - Kafka Consumers</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/12/解决-Kafka-Consumer-卡顿的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/" class="post-title-link" itemprop="url">解决 Kafka Consumer 卡顿的问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 12 2017 15:15:18" itemprop="dateCreated datePublished" datetime="2017-11-12T15:15:18+08:00">11月 12 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 11:48:28" itemprop="dateModified" datetime="2019-08-25T11:48:28+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运行环境说明"><a href="#运行环境说明" class="headerlink" title="运行环境说明"></a>运行环境说明</h1><p><strong><em>kafka 版本号为 0.11.0</em></strong></p>
<p>Kafka Consumer 的参数配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getDefaultConsumerConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; propsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动设置自动提交为false,交由 spring-kafka 启动的invoker执行提交</span></span><br><span class="line">        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        propsMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="string">"30000"</span>);</span><br><span class="line">        propsMap.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="string">"10000"</span>);</span><br><span class="line">        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从partition中获取消息最大大小</span></span><br><span class="line">        propsMap.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, <span class="string">"102400"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> propsMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Consumer-卡顿现象"><a href="#Consumer-卡顿现象" class="headerlink" title="Consumer 卡顿现象"></a>Consumer 卡顿现象</h1><h2 id="Consumer-卡顿时的日志"><a href="#Consumer-卡顿时的日志" class="headerlink" title="Consumer 卡顿时的日志"></a>Consumer 卡顿时的日志</h2><p>每次卡顿不消费时都出现以下日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2017/11/09 19:35:29:DEBUG pool-16-thread-10 org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset 11429299 for partition my_topic-27 returned fetch data (error=NONE, highWaterMark=11429299, lastStableOffset = -1, logStartOffset = 10299493, abortedTransactions = null, recordsSizeInBytes=0)</span><br><span class="line"> 2017/11/09 19:35:29:DEBUG pool-16-thread-10 org.apache.kafka.clients.consumer.internals.Fetcher - Added READ_UNCOMMITTED fetch request for partition my_topic-27 at offset 11429299 to node p-kafka-host-03.ali.keep:9092 (id: 6 rack: null)</span><br><span class="line"> 2017/11/09 19:35:29:DEBUG pool-16-thread-10 org.apache.kafka.clients.consumer.internals.Fetcher - Sending READ_UNCOMMITTED fetch for partitions [my_topic-27] to broker p-kafka-host-03.ali.keep:9092 (id: 6 rack: null)</span><br><span class="line"> 2017/11/09 19:35:29:DEBUG kafka-coordinator-heartbeat-thread | myConsumerGroup org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending Heartbeat request for group myConsumerGroup to coordinator p-kafka-host-02:9092 (id: 2147483642 rack: null)</span><br><span class="line">2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed for group myConsumerGroup since it is rebalancing.</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-18] for group myConsumerGroup</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-13 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-18]</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-13 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-18]</span><br><span class="line">2017/11/09 19:35:29:DEBUG pool-16-thread-4 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed for group myConsumerGroup since it is rebalancing.</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-4 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-21] for group myConsumerGroup</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-4 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-21]</span><br><span class="line">2017/11/09 19:35:29:INFO pool-16-thread-4 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-21]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2017/11/09 19:35:29:DEBUG pool-16-thread-4 org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset 11426689 for partition my_topic-21 returned fetch data (error=NONE, highWaterMark=11426689, lastStableOffset = -1, logStartOffset = 10552294, abortedTransactions = null, recordsSizeInBytes=0)</span><br><span class="line"> 2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Group myConsumerGroup committed offset 11429849 for partition my_topic-18</span><br><span class="line"> 2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining group myConsumerGroup</span><br><span class="line"> 2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending JoinGroup ((type: JoinGroupRequest, groupId=myConsumerGroup, sessionTimeout=30000, rebalanceTimeout=300000, memberId=p-my-consumer-host-03-12-97c12fb0-9bb7-4762-8478-538f06be9e90, protocolType=consumer, groupProtocols=org.apache.kafka.common.requests.JoinGroupRequest$ProtocolMetadata@54371fac)) to coordinator p-kafka-02.ali.keep:9092 (id: 2147483642 rack: null)</span><br></pre></td></tr></table></figure>

<p>其中最重要的部分是：</p>
<blockquote>
<p><strong>2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed for group myConsumerGroup since it is rebalancing.<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-18] for group myConsumerGroup<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-18]<br>…<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining group myConsumerGroup</strong></p>
</blockquote>
<p>那为什么每次会这样呢？我们是有单独的线程在发起心跳的！!!</p>
<h2 id="Consumer-卡顿时的-jstack"><a href="#Consumer-卡顿时的-jstack" class="headerlink" title="Consumer 卡顿时的 jstack"></a>Consumer 卡顿时的 jstack</h2><p>观察日志可以发现，卡顿时 ConsumerCoordinator 在不停地 rejoin group，并且做 rebalance，所以需要对比在正常和卡顿这两种情况下 ConsumerCoordinator 的行为。</p>
<h3 id="正常时的-ConsumerCoordinator"><a href="#正常时的-ConsumerCoordinator" class="headerlink" title="正常时的 ConsumerCoordinator"></a>正常时的 ConsumerCoordinator</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat jstack.normal.log | grep ConsumerCoordinator -B1 | grep -v ConsumerCoordinator | sort | uniq -c</span><br><span class="line">32 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.java:931)</span><br><span class="line">22 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.java:950)</span><br></pre></td></tr></table></figure>

<h3 id="卡顿时的-ConsumerCoordinator"><a href="#卡顿时的-ConsumerCoordinator" class="headerlink" title="卡顿时的 ConsumerCoordinator"></a>卡顿时的 ConsumerCoordinator</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat jstack.pause.log | grep ConsumerCoordinator -B1 | grep -v ConsumerCoordinator | sort | uniq -c</span><br><span class="line">14 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:316)</span><br><span class="line">14 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.java:920)</span><br><span class="line">8 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.java:931)</span><br><span class="line">32 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.java:950)</span><br></pre></td></tr></table></figure>

<p>根据以上的现场信息，可以发现关键就在 <code>AbstractCoordinator.ensureActiveGroup</code> 这一步，继续观察 jstack.pause.log 中的相关堆栈信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"pool-16-thread-14" #167 prio=5 os_prio=0 tid=0x00007f5b19dbf000 nid=0x7ac2 runnable [0x00007f5ae4ccb000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">        at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">        at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)</span><br><span class="line">        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">        - locked &lt;0x00000000c2e816b0&gt; (a sun.nio.ch.Util$2)</span><br><span class="line">        - locked &lt;0x00000000c2e816a0&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">        - locked &lt;0x00000000c2e742a0&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">        at org.apache.kafka.common.network.Selector.select(Selector.java:529)</span><br><span class="line">        at org.apache.kafka.common.network.Selector.poll(Selector.java:321)</span><br><span class="line">        at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:433)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:232)</span><br><span class="line">        - locked &lt;0x00000000c2f00da0&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:208)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:168)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.joinGroupIfNeeded(AbstractCoordinator.java:364)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:316)</span><br><span class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:297)</span><br><span class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:1078)</span><br><span class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1043)</span><br><span class="line">        at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:571)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<h1 id="卡顿原因分析"><a href="#卡顿原因分析" class="headerlink" title="卡顿原因分析"></a>卡顿原因分析</h1><h2 id="卡顿原因：Consumer-在-Region-Group"><a href="#卡顿原因：Consumer-在-Region-Group" class="headerlink" title="卡顿原因：Consumer 在 Region Group"></a>卡顿原因：Consumer 在 Region Group</h2><p>根据以上信息，结合 <code>org.apache.kafka.clients.consumer.internals.ConsumerCoordinator</code> 的代码可以发现在<br><code>ConsumerCoordinator#poll</code> 中判断 <code>needRejoin()</code> 为 true 时会调用 <code>ensureActiveGroup()</code> 函数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">long</span> remainingMs)</span> </span>&#123;</span><br><span class="line">        invokeCompletedOffsetCommitCallbacks();</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (needRejoin()) &#123;</span><br><span class="line">                ...</span><br><span class="line">                ensureActiveGroup();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pollHeartbeat(now);</span><br><span class="line">        maybeAutoCommitOffsetsAsync(now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Region-Group-原因：Consumer-Leave-Group"><a href="#Region-Group-原因：Consumer-Leave-Group" class="headerlink" title="Region Group 原因：Consumer Leave Group"></a>Region Group 原因：Consumer Leave Group</h2><p>那么问题就是什么情况下 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator#needRejoin 会返回 true，我们还是看看他的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptions.partitionsAutoAssigned())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need to rejoin if we performed the assignment and metadata has changed</span></span><br><span class="line">        <span class="keyword">if</span> (assignmentSnapshot != <span class="keyword">null</span> &amp;&amp; !assignmentSnapshot.equals(metadataSnapshot))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need to join if our subscription has changed since the last join</span></span><br><span class="line">        <span class="keyword">if</span> (joinedSubscription != <span class="keyword">null</span> &amp;&amp; !joinedSubscription.equals(subscriptions.subscription()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.needRejoin();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="kafka-metadata-什么时候变化？？？？"><a href="#kafka-metadata-什么时候变化？？？？" class="headerlink" title="kafka metadata 什么时候变化？？？？"></a>kafka metadata 什么时候变化？？？？</h2><p>可以看到，不是 metadataSnapshot 有变化，也不是 订阅者 subscriptions 有变化，那就是 super.needRejoin() 返回了 true，问题就转到了 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator#needRejoin</code> 这个函数，其实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rejoinNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上看 <code>rejoinNeeded</code> 的整个变化过程，初始化为 true，在 <code>initiateJoinGroup</code> 成功后，会赋值为 false，在 <code>maybeLeaveGroup</code> 时会赋值为 true，所以怀疑卡顿时是 consumer leave group 了。</p>
<h2 id="Consumer-Leave-Group-原因：pollTimeoutExpired"><a href="#Consumer-Leave-Group-原因：pollTimeoutExpired" class="headerlink" title="Consumer Leave Group 原因：pollTimeoutExpired"></a>Consumer Leave Group 原因：pollTimeoutExpired</h2><p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator.HeartbeatThread#run</code> 中调用了 <code>maybeLeaveGroup()</code> 函数，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Heartbeat thread for group &#123;&#125; started"</span>, groupId);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        client.pollNoWakeup();</span><br><span class="line">                        <span class="keyword">long</span> now = time.milliseconds();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) &#123;</span><br><span class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></span><br><span class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></span><br><span class="line">                            coordinatorDead();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) &#123;</span><br><span class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></span><br><span class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></span><br><span class="line">                            maybeLeaveGroup();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) &#123;</span><br><span class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></span><br><span class="line">                            <span class="comment">// coordinator disconnected</span></span><br><span class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            heartbeat.sentHeartbeat(now);</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125; <span class="comment">// end synchronized</span></span><br><span class="line">              &#125; <span class="comment">// end while</span></span><br><span class="line">          &#125; <span class="comment">//end try              </span></span><br><span class="line">&#125; <span class="comment">// end run</span></span><br></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以是 pollTimeoutExpired 引起了 leave group.</p>
<h2 id="根本原因：pollTimeoutExpired"><a href="#根本原因：pollTimeoutExpired" class="headerlink" title="根本原因：pollTimeoutExpired"></a>根本原因：pollTimeoutExpired</h2><p>pollTimeoutExpired 的原因是两次 poll 的时间间隔超过了设置的 maxPollInterval 值。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>调整以下参数</p>
<ul>
<li>max.poll.records：100 (默认值 500)</li>
<li>max.poll.interval.ms：600000 (默认值 300000，也就是5分钟)</li>
</ul>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>至此，问题已经解决了，但是有一些疑问。</p>
<ul>
<li>对于这两个参数值的设定， 是 <code>max.poll.records</code> 越小越好，<code>max.poll.interval.ms</code> 越大越好吗？</li>
<li>已经设置过的 <code>session.timeout.ms</code> 和 <code>heartbeat.interval.ms</code>难道没用吗？为什么有这么多超时参数的设置啊？</li>
<li>已经设置过的 <code>max.partition.fetch.bytes</code> 没用吗？为什么还要设置 <code>max.poll.records</code> 啊？</li>
<li>整体上还需要调哪些参数才可以让 consumer 运行正常，或者是性能达到最大呢？</li>
</ul>
<p>在下一篇博客「Kafka Consumer 的实现」中，将会继续分析 Kafka Consumer 的消费过程和参数配置，试图回答以上问题。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/" class="post-title-link" itemprop="url">Stanford Machine Learning - 5 广义线性模型</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 5 2017 23:20:39" itemprop="dateCreated datePublished" datetime="2017-11-05T23:20:39+08:00">11月 5 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:10:05" itemprop="dateModified" datetime="2019-08-25T21:10:05+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指数分布族-Exponential-Family"><a href="#指数分布族-Exponential-Family" class="headerlink" title="指数分布族(Exponential Family)"></a>指数分布族(Exponential Family)</h1><h2 id="指数分布族的定义"><a href="#指数分布族的定义" class="headerlink" title="指数分布族的定义"></a>指数分布族的定义</h2><p>若一类概率分布可以写成如下形式，那么它就属于指数分布族：<br>$$P(y;\eta) = b(y)exp(\eta^TT(y)-a(\eta))$$</p>
<ul>
<li>$\eta$: 自然参数，通常是一个实数</li>
<li>T(y): 充分统计量，通常，T(y)=y，实际上是一个概率分布的充分统计量（统计学知识）</li>
<li>a($\eta$) 被称为 log partition function</li>
</ul>
<p>对于给定的 a，b，T 三个函数，上式定义了一个以 $\eta$ 为参数的概率分布集合，即改变 $\eta$ 可以得到不同的概率分布，例如高斯分布和伯努利分布。</p>
<h2 id="指数分布族以及它们的特征"><a href="#指数分布族以及它们的特征" class="headerlink" title="指数分布族以及它们的特征"></a>指数分布族以及它们的特征</h2><ul>
<li>正态分布（高斯分布）——总体噪音（由中心极限定理得）</li>
<li>伯努利分布——逻辑回归（对01问题建模）</li>
<li>多项式分布——K种结果的事情进行建模</li>
<li>泊松分布——对计数过程进行建模（一个样本中放射性衰变的数目，网站的访客数目，商店的顾客数目）</li>
<li>伽马分布，指数分布——正数的分布，对间隔进行建模（在公交车站等车的时间）</li>
<li>β分布，Dirichlet分布——对小数进行分布，对概率分布进行建模</li>
<li>Wishart分布——协方差的分布</li>
</ul>
<h1 id="指数分布簇推导"><a href="#指数分布簇推导" class="headerlink" title="指数分布簇推导"></a>指数分布簇推导</h1><p>高斯分布(Gaussian)和伯努利(Bernoulli)分布都可以推导为指数分布族。</p>
<h2 id="伯努利分布的推导"><a href="#伯努利分布的推导" class="headerlink" title="伯努利分布的推导"></a>伯努利分布的推导</h2><p>伯努利分布的概率公式为：$P(y=1;\phi)=\phi; P(y=0;\phi)=1-\phi;$</p>
<p>公式可经如下变换：<br>$$P(y;\phi)=\phi^y(1-\phi)^y$$<br>$$=exp(log(\phi^y(1-\phi)^y))=exp(ylog(\phi)+ (1-y)log(1-\phi))$$<br>$$=exp(log(\frac\phi{1-\phi})y + log(1-\phi))$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = 1$<br>$\eta = log(\frac\phi{1-\phi}) =&gt; \phi=\frac1{1+e^{-n}}$<br>$a(\eta) = -log(1-\phi) = log(1+e^n)$</p>
<h2 id="高斯分布的推导"><a href="#高斯分布的推导" class="headerlink" title="高斯分布的推导"></a>高斯分布的推导</h2><p>在线性回归中，$\sigma$ 对于模型参数 $\theta$  的选择没有影响，为了推导方便我们令 $\sigma = 1$。<br>则有：<br>$$P(y;\mu)=\frac{1}{\sqrt{2\pi}}exp(-\frac12(y-\mu)^2)$$<br>$$=\frac{1}{\sqrt{2\pi}}exp(-\frac{1}{2}y^2) * exp({\mu}y-\frac{1}{2}\mu^2)$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = \frac{1}{\sqrt{2\pi}}exp(-\frac12y^2)$<br>$\eta = \mu$<br>$a(\eta) = \frac{ {\mu}^2}2 = \frac{ {\eta}^2}2$</p>
<h1 id="广义线性模型-Generalized-Linear-Model"><a href="#广义线性模型-Generalized-Linear-Model" class="headerlink" title="广义线性模型(Generalized Linear Model)"></a>广义线性模型(Generalized Linear Model)</h1><p>想用 广义线性模型对一般问题进行建模首先需要明确几个 假设：</p>
<ol>
<li>$y | x;θ \sim ExponentialFamily(\eta)$ y的条件概率属于指数分布族;</li>
<li>给定 x 广义线性模型的目标是求解 T(y) | x， 不过由于 很多情况下 T(y) = y  所以我们的目标变成了 y | x , 也即 我们希望拟合函数为 h(x) = E[y|x] (这个条件在线性回归和逻辑回归中都满足， 例如在逻辑回归中 $hθ(x) = p(y = 1|x;\theta) = 0 \cdot p(y = 0|x; \theta) + 1 \cdot  p(y = 1|x; \theta) = E[y|x;\theta])$</li>
<li>自然参数 $\eta$ 与 x 是线性关系：$\eta=\theta^Tx$ ($\eta 为向量时 \eta_{i} = \theta_{i}^Tx$)</li>
</ol>
<p>有了如上假设，就可以进行建模和求解了。</p>
<p>对于伯努利分布，可以推导出：<br>…<br>这也就是逻辑回归中 sigmod 函数的由来。</p>
<h1 id="多分类算法-Softmax-Regression"><a href="#多分类算法-Softmax-Regression" class="headerlink" title="多分类算法(Softmax Regression)"></a>多分类算法(Softmax Regression)</h1><p>y有多个可能的分类：{1, 2, …, k}</p>
<p>=======具体的公式略=======</p>
<p>最后求借寻找最佳参数时，跟最小二乘和逻辑回归的解法类似，可以用梯度下降法或者牛顿迭代法。</p>
<h1 id="Referecen"><a href="#Referecen" class="headerlink" title="Referecen"></a>Referecen</h1><p><a href="https://zhuanlan.zhihu.com/p/22876460" target="_blank" rel="noopener">广义线性模型(Generalized Linear Model)</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/" class="post-title-link" itemprop="url">Stanford Machine Learning - 4 逻辑回归</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 5 2017 23:06:43" itemprop="dateCreated datePublished" datetime="2017-11-05T23:06:43+08:00">11月 5 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:10:05" itemprop="dateModified" datetime="2019-08-25T21:10:05+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>对于逻辑回归而言，y 的取值不是 0 就是 1，所以 $h_θ(x)$ 可以写为<br>$$h_θ(x) = g(θ^{T}x)=\frac1{1+e^{-θ^{T}x}}$$</p>
<p>其中<br>$$g(z)=\frac1{1+e^{-z}}$$；</p>
<p>g(z) 被称为 logistic function 或 sigmoid function，其二维坐标下的曲线为:<br><img src="/img/sigmoid_function.png" alt="sigmoid function"></p>
<p>我们先取 g(z) 为 sigmoid function，如果有其他使得 y 值从 0 到 1 平滑递增的函数也可以使用。但由于一些列原因(在后续的一般化回归模型 GLM 中会谈到为什么选用这个函数)，g(z) is a fairly natural one.</p>
<p>g(z) 的导数我们可以先进行推导:<br>$$g’(z)=\frac{d}{dz}\frac{1}{1+e^{-z}}= \frac{1}{(1+e^{-z})^2}(e^{-z})$$<br>$$= \frac{1}{1+e^{-z}}*(1 - \frac{1}{1+e^{-z}})= g(z)(1-g(z))$$</p>
<h1 id="梯度上升法求解逻辑回归"><a href="#梯度上升法求解逻辑回归" class="headerlink" title="梯度上升法求解逻辑回归"></a>梯度上升法求解逻辑回归</h1><p>对于给定的逻辑回归函数，我们使用最小二乘法来推导出最大似然估计，假设:<br>$P(y=1|x;θ)=h_θ(x)$，代表对于给定的 θ，y 取值为 1 的概率。<br>$P(y=0|x;θ)=1-h_θ(x)$，代表对于给定的 θ，y 取值为 0 的概率。</p>
<p>以上两者可以合并为：<br>$$P(y|x;θ)=(h_θ(x))^y(1 − h_θ(x))^{(1−y)}$$</p>
<p>假设 m 个训练集是相互独立的，则似然估计为：<br>$$L(θ)=P(\overrightarrow{y}|X;θ)$$<br>$$= \prod^m_{i=1}P(y^i|x^i;θ)$$<br>$$= \prod^m_{i=1}{(h_θ(x^{(i)}))^{y^{(i)}}(1 − h_θ(x^{(i)}))^{(1−y^{(i)})}}$$</p>
<p>和之前一样，上式可以简化为：</p>
<p>
$l(θ) = logL(θ)
= \sum_{m}^{i=1}{y^{(i)}}log{h(x^{(i)}) + {(1−y^{(i)})}log(1 − h(x^{(i)}))}$

</p><p>那么，<br>如何去最大化似然函数呢，可以应用梯度上升法，因为我们要使 P 的取值足够大，也是就预测准确的概率最够大。</p>
<p>随机梯度上升的公式为：<br>$$θ:= θ + \alpha\Deltaθl(θ)$$</p>
<p>下面来求$\Deltaθl(θ)$的取值：</p>
<p>$$\frac\partial{\partial\theta_j}l(\theta)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)})\frac\partial{\partial\theta_j}g(\theta^Tx)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)}) g(\theta^Tx)(1-g(\theta^Tx))\frac\partial{\partial\theta_j}\theta^Tx$$<br>$$= ({y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)})x_j$$<br>$$= (y - h_{\theta}(x))x_j$$</p>
<p>附上手写的推导过程：<br><img src="/img/logistic_regression_delta_ljp_derived.png" alt="手写推导过程"></p>
<p>所以，最终随机梯度上升的公式为：<br>$$θ<em>j:=θ_j + \alpha\sum</em>{i=1}^{m}(y^{(i)} - h_{\theta}(x^{(i))})x_j^{(i)}$$</p>
<p>如何和线性回归的公式放在一起比较，</p>
<p>$$θ<em>j = θ_j - α \frac1m * \sum</em>{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}*x_j^{(i)}$$</p>
<p>会发现，这两者非常相似，实际上却不然，因为这里的 $(h_θ(x^{(i)})$ 定义的不是线性函数。后续我们谈到 GLM 时会发现这并不是巧合，而是有更深层次的原因。</p>
<h1 id="牛顿迭代法求解逻辑回归"><a href="#牛顿迭代法求解逻辑回归" class="headerlink" title="牛顿迭代法求解逻辑回归"></a>牛顿迭代法求解逻辑回归</h1><p>牛顿迭代法可以利用到曲线本身的信息，比梯度下降法更容易收敛，即迭代更少次数。</p>
<h2 id="牛顿迭代法简述"><a href="#牛顿迭代法简述" class="headerlink" title="牛顿迭代法简述"></a>牛顿迭代法简述</h2><p>假设我们要求解方程 f(x)=0 的根，首先随便找一个初始值 x0，如果 x0 不是解，做一个经过 (x0,f(x0))  这个点的切线，与 x 轴的交点为 x1。同样的道理，如果 x1 不是解，做一个经过 (x1,f(x1)) 这个点的切线，与 x 轴的交点为 x2。 以此类推。以这样的方式得到的 xi 会无限趋近于 f(x)=0 的解。</p>
<p>对于任意一点 $(x_n,y_n)$ 做切线，切线的斜率为 $f’(x_n)$，则有方程：<br>$$ y-f(x_n) = f’(x_n)(x-x_n) $$</p>
<h2 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h2><p>求解 $f(\theta)$ = 0 时 $\theta$ 的取值。<br>设下一次迭代时 $\theta^{(t+1)}$ 的取值与前一次迭代 $\theta^{(t)}$ 的取值(在 x 轴)距离为 $\Delta$。</p>
<p>则 $\theta^{(t+1)} = \theta^{(t)} - \Delta$，且 $\Delta = \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$，<br>所以有：<br>$$\theta^{(t+1)} = \theta^{(t)} - \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$$</p>
<h3 id="从泰勒展开到牛顿迭代"><a href="#从泰勒展开到牛顿迭代" class="headerlink" title="从泰勒展开到牛顿迭代"></a>从泰勒展开到牛顿迭代</h3><p>也可以由泰勒展开中推导牛顿迭代的公式。这次为了求解方程 f′=0 的根，把原函数 f(x) 的做泰勒展开，展开到二阶形式：<br>$$ f(x+\Delta x) = f(x)+f’(x)\Delta x+ \frac1{2}f’’(x)\Delta x^2 $$</p>
<p>当且仅当 $\Delta x$ 逼近 0 时，上式成立，此时忽略 1/2 系数的作用，所以有：<br>$$ f’(x)+ \frac1{2}f’’(x)\Delta x = 0 $$<br>故：<br>$$\Delta x = -\frac{f’(x)}{f’’(x)} $$</p>
<p><strong>对函数求极大值的方法</strong></p>
<blockquote>
<ol>
<li>将原函数y=f(x)，对x求一次导数，得到dy/dx；</li>
<li>令dy/dx = 0，解得一次导函数的零点；</li>
<li>将原函数对x求二次导函数；</li>
<li>将解得的零点坐标的x值代入二次导函数，<br>如果是正值，零点所在位置，就是极小值点，再将该x值代入原函数，得到极小值；<br>如果是值值，零点所在位置，就是极大值点，再将该x值代入原函数，得到极大值；<br>如果是0，零点所在位置，既不是极小值点，也不是极大值点，是拐点。</li>
</ol>
</blockquote>
<p>所以求 $l(\theta)$ 在极大值处 $\theta$ 的取值，则是求 $l’(\theta) = 0$ 时 $\theta$ 的值，应用牛顿迭代法则有：</p>
<p>$$\theta^{(t+1)} = \theta^{(t)} - \frac{l’(\theta^{(t)})}{l’’(\theta^{(t)})}$$</p>
<h2 id="多维向量的牛顿迭代"><a href="#多维向量的牛顿迭代" class="headerlink" title="多维向量的牛顿迭代"></a>多维向量的牛顿迭代</h2><p>对于多维向量 $\overrightarrow{X}$ 求解。<br>$$\theta := \theta - H^{-1} \nabla l(\theta)$$<br>其中<br>$\nabla l(\theta)$ 是对 $l(\theta)$ 求导的值。</p>
<p>H 是一个 n*n 的矩阵，n 是特征数量，元素的计算公式为：<br>$$H_ij= \frac{\partial^2{l({\theta)}}}{\partial{\theta_i}\partial{\theta_j}}$$</p>
<h2 id="牛顿迭代法的特点"><a href="#牛顿迭代法的特点" class="headerlink" title="牛顿迭代法的特点"></a>牛顿迭代法的特点</h2><h3 id="是否收敛"><a href="#是否收敛" class="headerlink" title="是否收敛"></a>是否收敛</h3><p>通常情况下是收敛的，但是需要满足一些条件，对于逻辑回归来讲，是收敛的。</p>
<h3 id="迭代速度"><a href="#迭代速度" class="headerlink" title="迭代速度"></a>迭代速度</h3><p>每次迭代后，有解数字的误差是成平方倍减小的，是二次收敛函数。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：收敛快<br>缺点：特征多(上千个)时，每次迭代成本大</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://blog.csdn.net/baimafujinji/article/details/51179381" target="_blank" rel="noopener">http://blog.csdn.net/baimafujinji/article/details/51179381</a><br><a href="http://blog.csdn.net/baimafujinji/article/details/51167852" target="_blank" rel="noopener">http://blog.csdn.net/baimafujinji/article/details/51167852</a><br><a href="https://www.jiqizhixin.com/articles/2017-08-09-3" target="_blank" rel="noopener">如何通过牛顿方法解决Logistic回归问题</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/" class="post-title-link" itemprop="url">Stanford Machine Learning - 3 线性回归的概率解释</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 5 2017 22:04:40" itemprop="dateCreated datePublished" datetime="2017-11-05T22:04:40+08:00">11月 5 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:10:06" itemprop="dateModified" datetime="2019-08-25T21:10:06+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h1><p>欠拟合：underfitting，与训练数据贴合的不够好，不能准确预测未来目标值。<br>过拟合：overfitting，与训练数据贴合的太好了，预测未来目标值的准确性有较大风险。</p>
<p><img src="/img/LR_underfitting_and_overfitting.png" alt></p>
<h1 id="线性模型的概率解释"><a href="#线性模型的概率解释" class="headerlink" title="线性模型的概率解释"></a>线性模型的概率解释</h1><p>思考：我们为什么要用最小二乘的指标作为 cost function？为什么不是绝对值或四次方？</p>
<blockquote>
<p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。<br>最小二乘是从函数形式上来看的，极大似然是从概率意义上来看的。事实上，最小二乘可以由高斯噪声假设+极大似然估计推导出来。当然极大似然估计还可以推导出其他的loss function， 比如logistic回归中，loss function是交叉熵。<br><a href="http://www.cnblogs.com/little-YTMM/p/5700226.html" target="_blank" rel="noopener">最大似然估计与最小二乘估计的区别</a></p>
</blockquote>
<p>一般的最小二乘法实际上是在假设误差项满足高斯分布且独立同分布的情况下，使似然性最大化。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>回到预测房价的例子，假设最终的预测函数，每一次预测都有误差，用$ε^{(i)}$表示误差，则预测函数可以写为：<br>$$y^{(i)}=\theta^Tx^{(i)} + ε^{(i)} $$</p>
<p>其中，误差是随机分布的，均值为 0，服从高斯分布 $N(0,σ^2)$。</p>
<blockquote>
<p>Andrew Ng 讲到在大多数情况下，线性回归的误差值如果综合来看，就是符合高斯分布的。并且根据中心极限定律，正态分布确实是对误差项分布的合理猜想。</p>
</blockquote>
<p>所以<br>$$P(y^{(i)}|x^{(i)}; θ) = \frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$$</p>
<p>$P(y^{(i)}|x^{(i)}; θ)$ 表示：在 θ 为给定的参数的情况下，概率 $y^{(i)}$ 以 $x^{(i)}$ 为随机变量的概率分布，注意 θ 不是随机变量。</p>
<p>由于 ε(i) 是独立的同分布（IID：independentlyidentically distribution），所以以 θ 为变量的似然函数为：<br>$$<br>L(θ)=L(θ;X,Y)=p(Y|X;θ) = \prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$</p>
<p>对 L(θ) 取对数有：<br>$$<br>l(\theta)=logL(\theta)<br>= log\prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$<br>$$<br>= m\sum_{i=1}^{m}log\frac{1}{\sqrt{2\pi}\sigma} - \frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2<br>$$</p>
<p>最大化 $l(\theta)$ 即是最小化 $\frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2$，这样就是 cost function.</p>
<p>由于目标变量服从正态分布，但分布的均值和方差都未知，对均值和方差两个参数的合理估计是选取两个参数使得在正态分布的前提下，抽到各样本中的 y 值的概率最大，这就是最大似然估计的思想。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.holehouse.org/mlclass/07_Regularization.html" target="_blank" rel="noopener">http://www.holehouse.org/mlclass/07_Regularization.html</a><br><a href="http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html" target="_blank" rel="noopener">http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html</a><br><a href="https://rpubs.com/badbye/ml03" target="_blank" rel="noopener">https://rpubs.com/badbye/ml03</a><br><a href="http://www.qiujiawei.com/linear-algebra-15/" target="_blank" rel="noopener">http://www.qiujiawei.com/linear-algebra-15/</a><br><a href="http://www.jianshu.com/p/f1d3906e4a3e" target="_blank" rel="noopener">最大似然估计</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/05/Stanford-Machine-Learning-2-Linear-Regression-with-multiple-features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/05/Stanford-Machine-Learning-2-Linear-Regression-with-multiple-features/" class="post-title-link" itemprop="url">Stanford Machine Learning - 2 线性回归进阶</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 5 2017 22:00:04" itemprop="dateCreated datePublished" datetime="2017-11-05T22:00:04+08:00">11月 5 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:08:25" itemprop="dateModified" datetime="2019-08-25T21:08:25+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/05/Stanford-Machine-Learning-2-Linear-Regression-with-multiple-features/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/05/Stanford-Machine-Learning-2-Linear-Regression-with-multiple-features/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多变量的线性回归"><a href="#多变量的线性回归" class="headerlink" title="多变量的线性回归"></a>多变量的线性回归</h1><p>n: 特征(features) 数量<br>m: 训练集数量<br>$x^{(i)}$: </p>
<ul>
<li>表示一条训练数据的向量</li>
<li>i is an index into the training set</li>
<li>So <ul>
<li>x is an n-dimensional feature vector</li>
<li>$x^{(3)}$ is, for example, the 3rd training data</li>
</ul>
</li>
</ul>
<p>$x^{(j)}_i$: The value of feature j in the ith training example</p>
<p>例如，当 n=4 时:<br>$$h_θ(x) = θ_0 + θ_1x_1 + θ_2x_2 + θ_3x_3 + θ_4x_4$$</p>
<p>For convenience of notation, $x_0$ = 1, 所以最后的特征向量的维度是 n+1，从 0 开始，记为”X”，<br>则有：<br>$$h_θ(x)=θ^TX$$<br>$θ^T$: [1 * (n+1)] matrix</p>
<h1 id="多变量的梯度下降"><a href="#多变量的梯度下降" class="headerlink" title="多变量的梯度下降"></a>多变量的梯度下降</h1><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>$$J(θ<em>0, θ_1, …,θ_n) =  \frac1{2m}\sum</em>{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2}$$</p>
<h2 id="Gradient-descent"><a href="#Gradient-descent" class="headerlink" title="Gradient descent"></a>Gradient descent</h2><p>Repeat {<br>  $$ θ_j = θ_j - α\frac\partial{\partial J(θ_0, θ_1, …,θ_n)} $$<br>}</p>
<p>every iterator</p>
<ul>
<li>θj = θj - learning rate (α) times the partial derivative of J(θ) with respect to θJ(…)</li>
<li>We do this through a simultaneous update of every θj value</li>
</ul>
<p>$$ \frac\partial{\partial J(θ<em>0, θ_1, …,θ_n)} $$<br>$$ = \frac1m * \sum</em>{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}*x_j^{(i)} $$</p>
<h1 id="Gradient-Decent-in-practice"><a href="#Gradient-Decent-in-practice" class="headerlink" title="Gradient Decent in practice"></a>Gradient Decent in practice</h1><h2 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h2><p>假设只有 $x_1$,$x_2$ 两个变量，其中：$x_1\in(0,2000), x_2\in(1,5)$，则最后的 J(θ) 图形是一个椭圆，在椭圆下用梯度下降法会比圆形要耗时更久，So we need to rescale this input so it’s more effective，有很多方式，一种是将各个 feature 除以其本身的最大值，缩小范围至[0,1]，一种是各个 feature 减去 mean 然后除以最大值，缩小范围至[-0.5,0.5]</p>
<h2 id="Learning-Rate-α"><a href="#Learning-Rate-α" class="headerlink" title="Learning Rate α"></a>Learning Rate α</h2><ul>
<li>working correctly: If gradient descent is working then J(θ) should decrease after every iteration</li>
<li>convergence: 收敛是指每经过一次迭代，J(θ)的值都变化甚小。</li>
<li>choose α<ol>
<li>When to use a smaller α<ul>
<li>If J(θ) is increasing, see below picture</li>
<li>If J(θ) looks like a series of waves, decreasing and increasing again</li>
<li>But if α is too small then rate is too slow</li>
</ul>
</li>
<li>Try a range of α values<ul>
<li>Plot J(θ) vs number of iterations for each version of alpha</li>
<li>Go for roughly threefold increases: 0.001, 0.003, 0.01, 0.03. 0.1, 0.3</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/img/gradient_descent_plot.jpg" alt></p>
<h1 id="Features-and-polynomial-regression"><a href="#Features-and-polynomial-regression" class="headerlink" title="Features and polynomial regression"></a>Features and polynomial regression</h1><h2 id="Can-create-new-features"><a href="#Can-create-new-features" class="headerlink" title="Can create new features"></a>Can create new features</h2><p>如何选择 features 和表达式尤为关键，例如房价与房子的长，房子的宽组成的表达式就会麻烦很多，若将房子的长乘以房子的宽得出面积，则有房价与房子面积的表达式，将会更容易拟合出房价的走势。</p>
<h2 id="Polynomial-regression"><a href="#Polynomial-regression" class="headerlink" title="Polynomial regression"></a>Polynomial regression</h2><p>例如房价的走势，如下图，横坐标 x 为房子的面积，纵坐标为房价，使用一元二次的方程，会得出下图的蓝色曲线。容易得到房价今后会有一个下降的过程，可实际上房价是不会随着面积的增大而下降的。所以需要重新选定 Polynomial regression，可以改为使用一元三次的方程或者使用平凡根的方程。</p>
<p><strong>所以选择合适的 Features 和 Polynomial regression 都非常重要。</strong></p>
<p><img src="/img/polynomial_regression_choose.jpg" alt></p>
<h1 id="Normal-equation-求解多变量线性回归"><a href="#Normal-equation-求解多变量线性回归" class="headerlink" title="Normal equation 求解多变量线性回归"></a>Normal equation 求解多变量线性回归</h1><h2 id="Normal-equation"><a href="#Normal-equation" class="headerlink" title="Normal equation"></a>Normal equation</h2><p>举例说明，假设 J(θ) 是一元二次方程，如：J(θ)=a$θ^2$+bθ+c，则令 $$ \frac{d}{dθ}J(θ)=2aθ+b=0$$ 即可，求出最终的 θ 则得到了线性回归方程，可以预测出今后的 y 值。</p>
<p>更普遍地，当 θ 是一个 n+1 维的向量时，θ $\in$ $R^{n+1}$，则 cost function 如下：<br>$$ J(θ<em>0, θ_1, …,θ_n) =  \frac1{2m}\sum</em>{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2} $$<br>只需要令：<br>$$ \frac\partial{\partial θ_j}J(θ_0, θ_1, …,θ_n) = … = 0 $$，其中 j = 0,1,2,…,n<br>设 X 代表训练集的 features 的值的矩阵，y 代表训练集的结果的值的矩阵，假设训练集数量为 m, features 个数为 n, 则 X 为 (m*n) 的矩阵，y 为 (m*1) 的矩阵，可以推导出求 θ 向量的公式如下：<br>$$θ = (X^TX)^{-1}X^Ty$$</p>
<h1 id="Gradient-descent-Vs-Normal-equation"><a href="#Gradient-descent-Vs-Normal-equation" class="headerlink" title="Gradient descent Vs Normal equation"></a>Gradient descent Vs Normal equation</h1><h2 id="Gradient-descent-1"><a href="#Gradient-descent-1" class="headerlink" title="Gradient descent"></a>Gradient descent</h2><ul>
<li>Need to chose learning rate</li>
<li>Needs many iterations - could make it slower</li>
<li>Works well even when n is massive (millions)</li>
<li>Better suited to big data</li>
<li>What is a big n though: 100 or even a 1000 is still (relativity) small, If n is 10000 then look at using gradient descent</li>
<li>适用于线性回归会逻辑回归</li>
</ul>
<h2 id="Normal-equation-1"><a href="#Normal-equation-1" class="headerlink" title="Normal equation"></a>Normal equation</h2><ul>
<li>No need to chose a learning rate</li>
<li>No need to iterate, check for convergence etc.</li>
<li>Normal equation needs to compute $(X^TX)^{-1}$<ul>
<li>This is the inverse of an n x n matrix</li>
<li>With most implementations computing a matrix inverse grows by O(n3), So not great</li>
</ul>
</li>
<li>Slow of n is large, Can be much slower</li>
<li>仅适用于线性回归</li>
</ul>
<h1 id="局部加权线性回归"><a href="#局部加权线性回归" class="headerlink" title="局部加权线性回归"></a>局部加权线性回归</h1><p>局部加权回归(locally weighted regression)简称 loess，其思想是，针对对某训练数据的每一个点，选取这个点及其临近的一批点做线性回归；同时也需要考虑整个训练数据，考虑的原则是距离该区域越近的点贡献越大，反之则贡献越小，这也正说明局部的思想。其 cost function 为：<br>$$J(\theta) = \sum_{i=1}^{m} w^{(i)}( y^{(i)}-\theta^Tx^{(i)} )^2$$</p>
<p>其中<br>$$ w^{(i)} =  exp (-\frac{(x^{(i)}-x)^2}{\tau^2})$$</p>
<p>$w^{(i)}$的形式跟正态分布很相似，但二者没有任何关系，仅仅只是便于计算。可以发现，$x^{(j)}$ 离 $x^{(i)}$ 非常近时，${w^{(i)}_j}$ 的值接近于1，此时 j 点的贡献很大，当 $x^{(j)}$ 离 $x^{(i)}$ 非常远时，${w^{(i)}_j}$ 的值接近于 0，此时 j 点的贡献很小。</p>
<p>$\tau^2$ 是波长函数(bandwidth)， 控制权重随距离下降的速度，τ 越小则 x 离 $x^{(i)}$ 越远时 $w^{(i)}$ 的值下降的越快。</p>
<p>所以，如果沿着 x 轴的每个点都进行局部直线拟合，那么你会发现对于这个数据集合来说，局部加权的预测结果，能够最终跟踪这条非线性的曲线。</p>
<p>但局部加权回归也有其缺点：</p>
<ul>
<li>每次对一个点的预测都需要整个数据集的参与，样本量大且需要多点预测时效率低。提高效率的方法参考 Andrew More’s KD Tree</li>
<li>不可外推，对样本所包含的区域外的点进行预测时效果不好，事实上这也是一般线性回归的弱点</li>
</ul>
<p>对于线性回归算法，一旦拟合出适合训练数据的参数θ，保存这些参数θ，对于之后的预测，不需要再使用原始训练数据集，所以是参数学习算法。</p>
<p>对于局部加权线性回归算法，每次进行预测都需要全部的训练数据（每次进行的预测得到不同的参数θ），没有固定的参数θ，所以是非参数算法(non-parametric algorithm)。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
</blockquote>
<p><a href="http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html" target="_blank" rel="noopener">http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/11/05/Stanford-Machine-Learning-1-Linear Regression with One Variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/05/Stanford-Machine-Learning-1-Linear Regression with One Variable/" class="post-title-link" itemprop="url">Stanford Machine Learning - 1 线性回归入门</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：11月 5 2017 21:55:04" itemprop="dateCreated datePublished" datetime="2017-11-05T21:55:04+08:00">11月 5 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:07:41" itemprop="dateModified" datetime="2019-08-25T21:07:41+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/11/05/Stanford-Machine-Learning-1-Linear Regression with One Variable/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/11/05/Stanford-Machine-Learning-1-Linear Regression with One Variable/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本系列的课程来源是 <a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="noopener">斯坦福大学公开课 CS229: 机器学习课程</a>，也可以看<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="noopener">网易公开课的资源</a>，是带字幕的。斯坦福的 CS229 课程相比于 Course 上的 <a href="https://zh.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Machine Learning</a> 课程，理论更强，讲解的也更深入，需要有一些的高数基础。两个课程都看了前半部分，更推荐前者，所以相关笔记对应的都是 CS229 课程。</p>
<h1 id="线性回归的定义"><a href="#线性回归的定义" class="headerlink" title="线性回归的定义"></a>线性回归的定义</h1><p>适用于监督学习，根据已有的数据集合(x, y)，来推断出将来的数据趋势。</p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><p>最后的函数应该是 y = ax + b，假设 hypothesis 为：</p>
<p>$$ h_{\theta}(x) = \theta_{0} + \theta_{1} $$</p>
<p>则问题转化为求 $\theta_{0}$ 和 $\theta_{1}$ 的值。要求这两个值需要转化上式，并根据已有的数据来求解。下面介绍损失函数，又叫代价函数的概念。</p>
<h1 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h1><p>针对每一组数据，公式的值是 $h_{\theta}$($x_{i}$), 实际的值是 $y_{i}$，我们要达到的效果则是公式能够尽量表达已有的 m 组数据集合，即 $( h_{\theta}(x^{(i)}) - y_{i})^{2}$ 的值尽量小。<br>所以，对于所有数据集合，需要求使得<br>$$ \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2}$$ 最小的 $\theta$ 值。</p>
<p>上式又称为 Cost Function，可以写为：</p>
<p>$$ J(\theta_0, \theta_1) =  \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2} $$</p>
<p>我们需要最小化这个 Cost Function。</p>
<h2 id="Cost-Function-的作用"><a href="#Cost-Function-的作用" class="headerlink" title="Cost Function 的作用"></a>Cost Function 的作用</h2><p>假设 $\theta_0$ = 0，则有 $\theta_1$ 和 J($\theta_1$) 的关系，且图形如下：<br><img src="/img/cost_function_theta1.jpg" alt></p>
<p>所以当 $\theta_1$ = 1 时，<br>$$ J(\theta_1)= \frac1{2m}\sum_{i=1}^{m}{(\theta_1x^{(i)} - y^{(i)})^2} $$<br>很容易看出，$J(\theta_1)$ 是关于 $\theta_1$ 的一元二次方程，对于所有的训练数据，每个 $\theta_1$ 的取值都会得到一个 $J(\theta_1)$ 值，而 $J(\theta_1)$ 和 $\theta_1$ 的对应关系根据一元二次方程可知，函数曲线如上图。<br>当 $J(\theta_1)$ 最小时，求得 $\theta_1$ 结果。</p>
<p>当 $\theta_0$ 和 $\theta_1$ 都不为 0 时，J($\theta_0$, $\theta_1$) 的图形如下：<br><img src="/img/cost_function_theta0_theta1.jpg" alt></p>
<p>对于两个系数的情况不如一个系数是一个二维坐标系的抛物线那么简单。下面将介绍梯度下降法。</p>
<h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul>
<li>Start with initial guesses</li>
<li>Start at 0,0 (or any other value)</li>
<li>Keeping changing $\theta_0$ and $\theta_1$ a little bit to try and reduce J($\theta_0$, $\theta_1$)</li>
<li>Each time you change the parameters, you select the gradient which reduces J($\theta_0$, $\theta_1$) the most possible </li>
<li>Repeat</li>
<li>Do so until you converge to a local minimum<br>Has an interesting property<ul>
<li>Where you start can determine which minimum you end up</li>
<li>Here we can see one initialization point led to one local minimum</li>
<li>The other led to a different one</li>
</ul>
</li>
</ul>
<p><img src="/img/gradient_descent_progress.jpg" alt></p>
<h2 id="具体的计算过程"><a href="#具体的计算过程" class="headerlink" title="具体的计算过程"></a>具体的计算过程</h2><p>$$ \theta_j := \theta_j - \alpha \frac\partial{\partial\theta_j}J(\theta_0, \theta_1)$$<br>(for j = 0 and j = 1)</p>
<h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><p><strong>$\alpha$</strong></p>
<ul>
<li>Is a number called the learning rate</li>
<li>Controls how big a step you take<ul>
<li>If α is big have an aggressive gradient descent</li>
<li>If α is small take tiny steps</li>
</ul>
</li>
<li>Too small<ul>
<li>Take baby steps</li>
<li>Takes too long</li>
</ul>
</li>
<li>Too large<ul>
<li>Can overshoot the minimum and fail to converge</li>
</ul>
</li>
</ul>
<h2 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h2><p>每次都是<strong>同时</strong>计算 $\theta_0, \theta_1$ 的值，如下：<br>$$ temp0:= \theta_0 - \alpha \frac\partial{\partial\theta_0}J(\theta_0, \theta_1)$$<br>$$ temp1:= \theta_1 - \alpha \frac\partial{\partial\theta_1}J(\theta_0, \theta_1)$$<br>$$ \theta_0 := temp0 $$<br>$$ \theta_1 := temp1 $$</p>
<p><img src="/img/gradient_descent_demo.jpg" alt></p>
<h3 id="利用梯度下降法求解线性回归问题"><a href="#利用梯度下降法求解线性回归问题" class="headerlink" title="利用梯度下降法求解线性回归问题"></a>利用梯度下降法求解线性回归问题</h3><p>$$ \frac\partial{\partial\theta_j}J(\theta_0, \theta_1) $$</p>
<p>$$ =\frac\partial{\partial\theta_j} * \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2} $$</p>
<p>$$ =\frac\partial{\partial\theta_j} * \frac1{2m}\sum_{i=1}^{m}{(\theta_0 +\theta_1x^{(i)} - y^{(i)})^2} $$</p>
<p>对于 j = 0 or 1 的情况有：<br>j = 0:<br>$$ \frac\partial{\partial\theta_0}J(\theta_0, \theta_1) = \frac1{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})$$<br>j = 1:<br>$$ \frac\partial{\partial\theta_1}J(\theta_0, \theta_1) = \frac1{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})*x^{(i)}$$</p>
<h2 id="梯度下降法的证明"><a href="#梯度下降法的证明" class="headerlink" title="梯度下降法的证明"></a>梯度下降法的证明</h2><p>1、如果优化函数存在解析解。例如我们求最值一般是对优化函数求导，找到导数为0的点。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数。</p>
<p>2、如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，互相依赖的情况。或者求导后式子得不到解释解，或者未知参数的个数大于方程组的个数等。这时候使用迭代算法来一步一步找到最优解。</p>
<ul>
<li>当目标函数是凸函数时，梯度下降法的解是全局最优解</li>
<li>一般情况下，其解不保证是全局最优解</li>
</ul>
<h3 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h3><p>凸函数就是一个定义在某个向量空间的凸子集C（区间）上的实值函数 f，而且对于凸子集C中任意两个向量 $x_1$, $x_2$ 有：<br>$$f(\frac{x_1+x_2}{2}) \le \frac{f(x_1)+f(x_2)}{2}$$<br>于是容易得出对于任意（0,1)中有理数 p，有：<br>$$f(px_1+(1-p)x_2) \le pf(x_1)+(1-p)f(x_2)$$<br>如果 f 连续，那么 p 可以改成任意（0,1）中实数。则 f 称为 I 上的凸函数，当且仅当其上境图（在函数图像上方的点集）为一个凸集。</p>
<h1 id="梯度下降法的使用"><a href="#梯度下降法的使用" class="headerlink" title="梯度下降法的使用"></a>梯度下降法的使用</h1><p>我们首先在函数上任选一点，计算其损失（即我们上面的L(w)） ，然后按照某一规则寻找更低的一点计算新的损失，只要新损失更小（最小化问题），我们就继续下降，直到达到一个可接受的优化目标。<br>梯度下降方法分为两个部分，第一部分是整体上，我们使用某步长不断下降求损失函数，第二部分是为了防止步长太长导致最后无法收敛，每次当损失上升的时候都调整步长。<br>通常实践中使用时，都是用一些开源算法，很少需要深度改进，比如使用 libsvm 可以直接求解逻辑回归。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
</blockquote>
<p><a href="http://www.cnblogs.com/yysblog/p/3268508.html" target="_blank" rel="noopener">http://www.cnblogs.com/yysblog/p/3268508.html</a><br><a href="http://52opencourse.com/125/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E8%AF%BE-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-logistic-regression" target="_blank" rel="noopener">http://52opencourse.com/125/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E8%AF%BE-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-logistic-regression</a><br><a href="http://www.cnblogs.com/chaoren399/p/4851658.html" target="_blank" rel="noopener">http://www.cnblogs.com/chaoren399/p/4851658.html</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/08/19/Jackson反序列化忽略为null的字段/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/19/Jackson反序列化忽略为null的字段/" class="post-title-link" itemprop="url">Jackson反序列化忽略为null的字段</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：8月 19 2017 23:02:30" itemprop="dateCreated datePublished" datetime="2017-08-19T23:02:30+08:00">8月 19 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:32:54" itemprop="dateModified" datetime="2019-08-25T21:32:54+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/08/19/Jackson反序列化忽略为null的字段/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/08/19/Jackson反序列化忽略为null的字段/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><p>json 反序列化 bean 时，当某个字段在 json 中为 null 时，使用 bean 中声明的默认值。</p>
<p>Person 类我们改造下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">// Address is a enum: &#123;CH, US, GZ&#125;</span></span><br><span class="line">  <span class="keyword">private</span> Region region = Region.GZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍然以 Person 类举例，如果 json 串是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"robert"</span>, <span class="string">"region"</span>:<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure>

<p>希望反序列化后的 bean 为 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(name=<span class="string">"robert"</span>, region=Region.GZ)</span><br></pre></td></tr></table></figure>

<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>在上一篇文章 <code>lombok 的 AllArgs 导致 Jackson 反序列化丢失字段默认值</code> 中可以看到 json 反序列化为 bean 的过程，一般情况下，是先调用默认构造函数生成 bean，然后根据 json 中出现的字段挨个赋值。<br>所以反序列化生成的 bean 的 region 肯定为 null。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="JsonInclude-Include-NON-NULL-可行吗？"><a href="#JsonInclude-Include-NON-NULL-可行吗？" class="headerlink" title="@JsonInclude(Include.NON_NULL) 可行吗？"></a>@JsonInclude(Include.NON_NULL) 可行吗？</h2><p>不可行，这个注解是序列化时忽略 null 值，反序列化时不生效，基本上反序列化时我们不能做什么事情。</p>
<h2 id="JsonCreator-可行吗？"><a href="#JsonCreator-可行吗？" class="headerlink" title="JsonCreator 可行吗？"></a>JsonCreator 可行吗？</h2><p>在 Region 枚举里写 JsonCreator:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Region <span class="title">getRegion</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Region region : Region.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (region.name().equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> region;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Region.GZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接将 <code>{&quot;region&quot;: null}</code> 反序列化为 Region 是可行的，会调用 JsonCreator，但是如果是反序列化 Person 则不会调用到 JsonCreator，为什么呢？</p>
<p>debug 过程：<br>如前文所述，会调用到 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserialize</code> 这个函数中，然后会调用到<br><code>com.fasterxml.jackson.databind.deser.SettableBeanProperty#deserialize</code>，这个函数的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonToken t = p.getCurrentToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == JsonToken.VALUE_NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> _valueDeserializer.getNullValue(ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_valueTypeDeserializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _valueDeserializer.deserialize(p, ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这里会把 null 值拦住，直接返回 getNullValue 的结果。</p>
<h2 id="自定义-deserializer"><a href="#自定义-deserializer" class="headerlink" title="自定义 deserializer"></a>自定义 deserializer</h2><p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegionDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Region</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Region <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonNode node = jsonParser.getCodec().readTree(jsonParser);</span><br><span class="line">        Region region = Region.GZ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(node.textValue())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Region.getRegion(node.textValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            type = Region.GZ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> region;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Region <span class="title">getNullValue</span><span class="params">(DeserializationContext ctxt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Region.GZ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person 类改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Address is a enum: &#123;CH, US, GZ&#125;</span></span><br><span class="line">  <span class="meta">@JsonDeserialize</span>(using = RegionDeserializer.class)</span><br><span class="line">  <span class="keyword">private</span> Region region = Region.GZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在<code>com.fasterxml.jackson.databind.deser.SettableBeanProperty#deserialize</code>这个方法里，碰到 null 值，就会返回 getNullValue 的结果，即 Region.GZ，如果不是 null 会进入 getRegion 函数处理，也能处理其他情况。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://luojinping.com/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jinping Luo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zane Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/" class="post-title-link" itemprop="url">lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：8月 19 2017 22:27:12" itemprop="dateCreated datePublished" datetime="2017-08-19T22:27:12+08:00">8月 19 2017</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：8月 25 2019 21:25:50" itemprop="dateModified" datetime="2019-08-25T21:25:50+08:00">8月 25 2019</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><p>希望在反序列化 json 到 bean 时，对于 json 中未出现的字段，在 bean 中赋上默认值。</p>
<p>例如<br>Person 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(ignoreUnknown = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String address = <span class="string">"beijing"</span>; <span class="comment">// default value if json missing the age field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>json: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;robert&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化后的 bean 为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(name=&quot;robert&quot;, address=&quot;beijing&quot;)</span><br></pre></td></tr></table></figure>

<p>但实际上，发序列化的结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(name=&quot;robert&quot;, address=null)</span><br></pre></td></tr></table></figure>

<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><h2 id="查看-maven-版本"><a href="#查看-maven-版本" class="headerlink" title="查看 maven 版本"></a>查看 maven 版本</h2><p>项目中 jackson 的配置如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Jackson dependency versions --&gt;</span><br><span class="line">&lt;jackson.version&gt;2.6.5&lt;/jackson.version&gt;</span><br></pre></td></tr></table></figure>

<p>配置升到最新后问题仍然存在。</p>
<h2 id="debug-json-反序列化过程，找到原因"><a href="#debug-json-反序列化过程，找到原因" class="headerlink" title="debug json 反序列化过程，找到原因"></a>debug json 反序列化过程，找到原因</h2><p>json 反序列化是从</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.ObjectMapper#_readMapAndClose</span><br></pre></td></tr></table></figure>

<p>这个方法调用开始的，里面的一段代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeserializationConfig cfg = getDeserializationConfig();</span><br><span class="line">DeserializationContext ctxt = createDeserializationContext(jp, cfg);</span><br><span class="line">JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType);</span><br><span class="line"><span class="keyword">if</span> (cfg.useRootWrapping()) &#123;</span><br><span class="line">    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = deser.deserialize(jp, ctxt);</span><br><span class="line">&#125;</span><br><span class="line">ctxt.checkUnresolvedObjectId();</span><br></pre></td></tr></table></figure>

<p>在第 3 行找到的 JsonDeserializer 是 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer</code><br>从第 7 行代表进入 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserialize(com.fasterxml.jackson.core.JsonParser, com.fasterxml.jackson.databind.DeserializationContext)</code></p>
<p>函数实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// common case first</span></span><br><span class="line">    <span class="keyword">if</span> (p.isExpectedStartObjectToken()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_vanillaProcessing) &#123;</span><br><span class="line">            <span class="keyword">return</span> vanillaDeserialize(p, ctxt, p.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">        p.nextToken();</span><br><span class="line">        <span class="keyword">if</span> (_objectIdReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> deserializeWithObjectId(p, ctxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserializeFromObject(p, ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    JsonToken t = p.getCurrentToken();</span><br><span class="line">    <span class="keyword">return</span> _deserializeOther(p, ctxt, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vanillaDeserialize 为 false，最后走到了第 11 行，最后到了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.deser.BeanDeserializer#_deserializeUsingPropertyBased</span><br></pre></td></tr></table></figure>

<p>然后到 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator#build</span><br></pre></td></tr></table></figure>

<p>在这个函数里有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_allProperties));</span><br></pre></td></tr></table></figure>

<p>调用的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.fasterxml.jackson.databind.deser.ValueInstantiator#createFromObjectWith(com.fasterxml.jackson.databind.DeserializationContext, java.lang.Object[])</span><br></pre></td></tr></table></figure>

<p>可以发现，createFromObjectWith 的第二个参数是数组，json 解出来的字段都放在了这个数组里。然后调用了 Person 类的全参构造函数，对于<br>缺失的字段自动补 null 值，这样就导致了 address 字段为 null。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>去掉 @AllArgsConstructor 时，没有问题了，因为此时找到的 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer</code> 的  vanillaDeserialize 字段为 true，会调用 <code>vanillaDeserialize(p, ctxt, p.nextToken());</code>，这个函数的实现非常明确：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">vanillaDeserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt, JsonToken t)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object bean = _valueInstantiator.createUsingDefault(ctxt);</span><br><span class="line">        <span class="comment">// [databind#631]: Assign current value, to be accessible by custom serializers</span></span><br><span class="line">        p.setCurrentValue(bean);</span><br><span class="line">        <span class="keyword">if</span> (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) &#123;</span><br><span class="line">            String propName = p.getCurrentName();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                p.nextToken();</span><br><span class="line">                SettableBeanProperty prop = _beanProperties.find(propName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (prop != <span class="keyword">null</span>) &#123; <span class="comment">// normal case</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        prop.deserializeAndSet(p, ctxt, bean);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        wrapAndThrow(e, bean, propName, ctxt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                handleUnknownVanilla(p, ctxt, bean, propName);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((propName = p.nextFieldName()) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先用默认构造函数生成 bean，此时的 bean 是有默认值的，然后将 json 中出现的字段的值赋值给 bean，这样 address 就有值了。</p>
<h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>看上去是声明了全参构造函数导致的，所以想尝试自己写全参构造函数，在 address 为 null 时给其赋默认值。<br>写完如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.address == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = <span class="string">"beijing"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续走刚才 debug 的流程，发现<strong>居然</strong>没有请求这个全参构造函数。</p>
<p>那问题就是 @AllArgsConstructor 生成的全参函数有不同之处，jackson 能够识别出来并用于反序列化。查看 jar 包中 Person 类的代码发现其全参构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"name"</span>, <span class="string">"address"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，区别就是 <code>@ConstructorProperties({&quot;name&quot;, &quot;address&quot;})</code> 这个注解，这个注解的作用是指定构造函数参数的名字，Spring 可根据参数的名字注入 bean。</p>
<p>(补充自 liwei)<br>jackson 调用了全参构造函数的原因在于@AllArgsConstructor 的构造函数有ConstructorProperties ,jackson在选择构造函数的时候会调用BasicDeserializerFactory._addDeserialzerContructors方法，他首先选择无参构造函数，并遍历所有的构造函数，如果存在具有@ConstructProperties注解的构造函数，则把该构造函数作为默认创建bean的构造函数，如下：<br><img src="/img/jackson_constructor.png" alt></p>
<p>可以通过设置 @AllArgsConstructor(suppressConstructorProperties=true) 来禁用 @ConstructorProperties.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Lombok 的 @AllArgsConstructor 注解导致 Jackson 反序列化时调用了全参构造函数，将没有出现的字段都赋值为 null 了。</p>
<p>修改方式：</p>
<ol>
<li>不使用 @AllArgsConstructor</li>
<li>使用 @AllArgsConstructor 但是不让其在全参构造函数上加入 ConstructorProperties 注解，声明方式改为 @AllArgsConstructor(suppressConstructorProperties = true)</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jinping Luo</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinping Luo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  








  <script src="/js/local-search.js?v=7.3.0"></script>














  

  
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'ryOfOXrbxUPrI2b60Dpm5aNc-gzGzoHsz',
    appKey: '1A5biSRB2pUQSDONfYJhK2l6',
    placeholder: '说点什么吧~',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
