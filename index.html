
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Zane Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Jinping Luo">
    
    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zane Blog">
<meta property="og:url" content="http://luojinping.com/">
<meta property="og:site_name" content="Zane Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zane Blog">
<meta name="twitter:description">


    
    <link rel="alternative" href="/atom.xml" title="Zane Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a2d87d3add52ff134d9fac6cc16e4800";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Zane Blog" title="Zane Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Zane Blog">Zane Blog</a></h1>
				<h2 class="blog-motto">业精于勤荒于嬉，形成思毁于随</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:luojinping.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/12/Kafka-Consumer-的实现/" title="Kafka Consumer 的实现" itemprop="url">Kafka Consumer 的实现</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-12T07:16:54.000Z" itemprop="datePublished"> Published Nov 12 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong><em>说明: kafka 版本号为 0.11.0</em></strong></p>
<h2 id="Consumer_拉取消息的实现">Consumer 拉取消息的实现</h2>
<p>在 Kafka Consumer 正常消费时，观察其调用堆栈。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pool-16-thread-7"</span> <span class="comment">#154 prio=5 os_prio=0 tid=0x00007ff581c8c000 nid=0x326d runnable [0x00007ff5468e7000]</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">        <span class="keyword">...</span></div><div class="line">        at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:<span class="number">433</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">232</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e04f90</span>&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</div><div class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">208</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:<span class="number">1096</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:<span class="number">1043</span>)</div><div class="line">        at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:<span class="number">571</span>)</div><div class="line">        <span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>对应的代码实现是 <code>org.apache.kafka.clients.consumer.KafkaConsumer#poll</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span>(<span class="keyword">long</span> timeout) {</div><div class="line">        ...</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ...</div><div class="line">            <span class="comment">// poll for new data until the timeout expires</span></div><div class="line">            <span class="keyword">long</span> start = time.milliseconds();</div><div class="line">            <span class="keyword">long</span> remaining = timeout;</div><div class="line">            do {</div><div class="line">                Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollOnce(remaining);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests())</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        </div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConsumerRecords&lt;&gt;(records);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</div><div class="line">                        </div><div class="line">                <span class="keyword">long</span> elapsed = time.milliseconds() - start;</div><div class="line">                remaining = timeout - elapsed;</div><div class="line">            } <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> ConsumerRecords.empty();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            release();</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>其中 <code>org.apache.kafka.clients.consumer.KafkaConsumer#pollOnce</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; <span class="title">pollOnce</span>(<span class="keyword">long</span> timeout) {</div><div class="line">        ...</div><div class="line">        <span class="comment">// ConsumerCoordinator coordinator;</span></div><div class="line">        coordinator.poll(time.milliseconds(), timeout);</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// if data is available already, return it immediately</span></div><div class="line">        Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">        <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">            <span class="keyword">return</span> records;</div><div class="line"></div><div class="line">        <span class="comment">// send any new fetches (won't resend pending fetches)</span></div><div class="line">        fetcher.sendFetches();</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>所以可以看到 consumer 每次 poll 时是先从 fetcher 中 fetchedRecords 的，如果拿不到结果，就新发起一个 sendFetches 请求。</p>
<h3 id="Consumer_拉取消息的数量">Consumer 拉取消息的数量</h3>
<p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#fetchedRecords</code> 可以看到 <code>maxPollRecords</code>(max.poll.records 配置) 变量限制了每次 poll 的消息条数，不管 consumer 对应多少个 partition，从所有 partition 拉取到的消息条数总和不会超过 <code>maxPollRecords</code>。</p>
<p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#sendFetches</code> 可以看到 <code>fetchSize</code>(max.partition.fetch.bytes 配置) 用于每次创建 FetchRequest 时的 <code>org.apache.kafka.common.requests.FetchRequest.PartitionData</code> 的参数设置。<code>fetchSize</code>限制了 consumer 每次从每个 partition 拉取的数据量。<br>不过，还是看代码中的 <code>ConsumerConfig#MAX_PARTITION_FETCH_BYTES_DOC</code> 说明吧：</p>
<blockquote>
<p>The maximum amount of data per-partition the server will return. Records are fetched in batches by the consumer. If the first record batch in the first non-empty partition of the fetch is larger than this limit, the batch will still be returned to ensure that the consumer can make progress. The maximum record batch size accepted by the broker is defined via <code>message.max.bytes</code> (broker config) or <code>max.message.bytes</code> (topic config). See “ + FETCH_MAX_BYTES_CONFIG + “ for limiting the consumer request size.</p>
</blockquote>
<h4 id="poll_和_fetch_的关系">poll 和 fetch 的关系</h4>
<p>在满足max.partition.fetch.bytes限制的情况下，假如fetch到了100个record，放到本地缓存后，由于max.poll.records限制每次只能poll出15个record。那么KafkaConsumer就需要执行7次才能将这一次通过网络发起的fetch请求所fetch到的这100个record消费完毕。其中前6次是每次pool中15个record，最后一次是poll出10个record。</p>
<h2 id="Consumer_的心跳机制">Consumer 的心跳机制</h2>
<p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinat</code> 中启动 <code>HeartbeatThread</code> 线程来定时发送心跳和检查 consumer 的状态。<br>每个 Consumer 都有一个 ConsumerCoordinator(继承 AbstractCoordinator)，每个 ConsumerCoordinator 都启动一个 <code>HeartbeatThread</code> 线程来维护心跳，心跳信息存放在 <code>org.apache.kafka.clients.consumer.internals.Heartbeat</code>。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">                log.debug(<span class="string">"Heartbeat thread for group {} started"</span>, groupId);</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) {</div><div class="line">                        ...</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) {</div><div class="line">                            ...</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></div><div class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></div><div class="line">                            coordinatorDead();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></div><div class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></div><div class="line">                            maybeLeaveGroup();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) {</div><div class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></div><div class="line">                            <span class="comment">// coordinator disconnected</span></div><div class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            heartbeat.sentHeartbeat(now);</div><div class="line">                            ...</div><div class="line">                        }</div><div class="line">                  } <span class="comment">// end synchronized</span></div><div class="line">              } <span class="comment">// end while</span></div><div class="line">          } <span class="comment">//end try              </span></div><div class="line">} <span class="comment">// end run</span></div></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="sessionTimeout">sessionTimeout</h3>
<p>如果是 sessionTimeout 则 Mark the current coordinator as dead，此时  会将 consumer 踢掉，重新分配 partition 和 consumer 的对应关系。</p>
<p>在 Kafka Server 端，Consumer 的 Group 定义了五个状态：：<br><img src="/img/kafka_consumer_state_in_server.png" alt="Consumer Group State"></p>
<p>

<h3 id="pollTimeout">pollTimeout</h3>
</p><p>如果是 pollTimeout 则 Reset the generation and memberId because we have fallen out of the group，此时 consumer 会退出 group，当再次 poll 时又会 rejoin group 触发 rebalance group。</p>
<h4 id="Rebalance_Generation">Rebalance Generation</h4>
<p>表示 rebalance 之后的一届成员，主要是用于保护 consumer group，隔离无效 offset 提交。每次 group 进行 rebalance 之后，generation 号都会加 1，表示 group 进入到了一个新的版本，下图所示为 consumer 2 退出后 consumer 4 加入时 Rebalance Generation 的过程：<br><img src="/img/Kafka_Rebalance_Generation.png" alt="Rebalance Generation"></p>
<h2 id="partition_的数量设置">partition 的数量设置</h2>
<ul>
<li><p>一个 partition 只能被 Consumer Group 中的一个 consumer 消费，因此，为了提高并发量，可以提高 partition 的数量，但是这会造成 replica 副本拷贝的网络请求增加，故障恢复时的耗时增加。因为 kafka 使用 batch pull 的方式，所以单个线程的消费速率还是有保障的。并且 partition 数量过多，zk 维护 ISR 列表负载较重。</p>
</li>
<li><p>partiton 数量最好是 consumer 数目的整数倍，比如取 24， consumer 数目的设置就会灵活很多。</p>
</li>
<li><p>consumer 消费消息时不时严格有序的。当从多个 partition 读数据时，kafka 只保证在一个 partition 上数据是有序的，多个 partition 的消息消费很可能就不是严格有序的了。</p>
</li>
</ul>
<h2 id="参数设置">参数设置</h2>
<h3 id="heartbeat-interval-ms">heartbeat.interval.ms</h3>
<p>心跳间隔。心跳是在 consumer 与 coordinator 之间进行的。心跳是确定 consumer 存活，加入或者退出 group 的有效手段。<br>这个值必须设置的小于 session.timeout.ms，因为：<br>当 consumer 由于某种原因不能发 heartbeat 到 coordinator 时，并且时间超过 session.timeout.ms 时，就会认为该 consumer 已退出，它所订阅的 partition 会分配到同一 group 内的其它的 consumer 上。</p>
<h4 id="参数值">参数值</h4>
<p>默认值：3000 (3s)，通常设置的值要低于session.timeout.ms的1/3。</p>
<p></p><p></p>
<h3 id="session-timeout-ms">session.timeout.ms</h3>
<p>consumer session 过期时间。如果超时时间范围内，没有收到消费者的心跳，broker 会把这个消费者置为失效，并触发消费者负载均衡。因为只有在调用 poll 方法时才会发送心跳，更大的 session 超时时间允许消费者在 poll 循环周期内处理消息内容，尽管这会有花费更长时间检测失效的代价。如果想控制消费者处理消息的时间，</p>
<h4 id="参数值-1">参数值</h4>
<p>默认值：10000 (10s)，这个值必须设置在 broker configuration 中的 group.min.session.timeout.ms 与 group.max.session.timeout.ms 之间。</p>
<p>

<h3 id="max-poll-interval-ms">max.poll.interval.ms</h3>
</p><p>This config sets the maximum delay between client calls to poll(). </p>
<p>When the timeout expires, the consumer will stop sending heartbeats and send an explicit LeaveGroup request. </p>
<p>As soon as the consumer resumes processing with another call to poll(), the consumer will <strong>rejoin the group</strong>. </p>
<p>By increasing the interval between expected polls, you can give the consumer more time to handle a batch of records returned frompoll(long). The drawback is that increasing this value may delay a group rebalance since the consumer will only join the rebalance inside the call to poll. You can use this setting to bound the time to finish a rebalance, but you risk slower progress if the consumer cannot actually call poll often enough.</p>
<p>参数设置大一点可以增加两次 poll 之间处理消息的时间。<br>当 consumer 一切正常(也就是保持着 heartbeat )，且参数的值小于消息处理的时长，会导致 consumer leave group 然后又 rejoin group，触发无谓的 group balance，出现 consumer livelock 现象。</p>
<p>但如果设置的太大，会延迟 group rebalance，因为消费者只会在调用 poll 时加入rebalance。</p>
<p>

<h3 id="max-poll-records">max.poll.records</h3>
</p><p>Use this setting to limit the total records returned from a single call to poll. This can make it easier to predict the maximum that must be handled within each poll interval. By tuning this value, you may be able to reduce the poll interval, which will reduce the impact of group rebalancing.</p>
<p>0.11.0 Kafka 的默认配置是 </p>
<ul>
<li>max.poll.interval.ms=5min</li>
<li>max.poll.records=500</li>
</ul>
<p>即平均 600ms 要处理完一条消息，如果消息的消费时间高于 600ms，则一定要调整 max.poll.records 或 max.poll.interval.ms。</p>
<h2 id="Kafka_Javadoc_-_Detecting_Consumer_Failures">Kafka Javadoc - Detecting Consumer Failures</h2>
<p>After subscribing to a set of topics, the consumer will automatically join the group when poll(long) is invoked. The poll API is designed to ensure consumer liveness. As long as you continue to call poll, the consumer will stay in the group and continue to receive messages from the partitions it was assigned. Underneath the covers, the consumer sends periodic heartbeats to the server. If the consumer crashes or is unable to send heartbeats for a duration of session.timeout.ms, then the consumer will be considered dead and its partitions will be reassigned.<br>It is also possible that the consumer could encounter a “livelock” situation where it is continuing to send heartbeats, but no progress is being made. To prevent the consumer from holding onto its partitions indefinitely in this case, we provide a liveness detection mechanism using the max.poll.interval.ms setting. Basically if you don’t call poll at least as frequently as the configured max interval, then the client will proactively leave the group so that another consumer can take over its partitions. When this happens, you may see an offset commit failure (as indicated by a CommitFailedException thrown from a call to commitSync()). This is a safety mechanism which guarantees that only active members of the group are able to commit offsets. So to stay in the group, you must continue to call poll. </p>
<h2 id="Reference">Reference</h2>
<p><a href="http://www.cnblogs.com/huxi2b/p/6223228.html" target="_blank" rel="external">Kafka消费组(consumer group)</a><br><a href="https://kafka.apache.org/0101/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="external">kafka.apache.org javadoc</a><br><a href="http://blog.leanote.com/post/zfb050/Coordinator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="external">Coordinator实现原理</a><br><a href="http://debugo.com/kafka-params/" target="_blank" rel="external">kafka params</a><br><a href="http://blog.csdn.net/u014393917/article/details/52043185" target="_blank" rel="external">kafka源码分析之kafka的consumer的负载均衡管理</a><br><a href="http://www.cnblogs.com/devos/p/5656232.html" target="_blank" rel="external">Group Management Protocol</a><br><a href="http://matt33.com/2017/01/16/kafka-group/" target="_blank" rel="external">Kafka 之 Group 状态变化分析及 Rebalance 过程</a><br><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-62%3A+Allow+consumer+to+send+heartbeats+from+a+background+thread" target="_blank" rel="external">KIP-62: Allow consumer to send heartbeats from a background thread</a><br><a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch04.html" target="_blank" rel="external">Kafka: The Definitive Guide Chapter 4 - Kafka Consumers</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/12/Kafka-Consumer-的实现/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/" title="解决 Kafka Consumer 卡顿的问题" itemprop="url">解决 Kafka Consumer 卡顿的问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-12T07:15:18.000Z" itemprop="datePublished"> Published Nov 12 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="运行环境说明">运行环境说明</h2>
<p><strong><em>kafka 版本号为 0.11.0</em></strong></p>
<p>Kafka Consumer 的参数配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getDefaultConsumerConfigs</span>() {</div><div class="line">        Map&lt;String, Object&gt; propsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 手动设置自动提交为false,交由 spring-kafka 启动的invoker执行提交</span></div><div class="line">        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        propsMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="string">"30000"</span>);</div><div class="line">        propsMap.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="string">"10000"</span>);</div><div class="line">        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line"></div><div class="line">        <span class="comment">// 从partition中获取消息最大大小</span></div><div class="line">        propsMap.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, <span class="string">"102400"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> propsMap;</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="Consumer_卡顿现象">Consumer 卡顿现象</h2>
<h3 id="Consumer_卡顿时的日志">Consumer 卡顿时的日志</h3>
<p>每次卡顿不消费时都出现以下日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset <span class="number">11429299</span> <span class="keyword">for</span> partition my_topic-<span class="number">27</span> returned fetch data (error=NONE, highWaterMark=<span class="number">11429299</span>, lastStableOffset = -<span class="number">1</span>, logStartOffset = <span class="number">10299493</span>, abortedTransactions = <span class="keyword">null</span>, recordsSizeInBytes=<span class="number">0</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Added READ_UNCOMMITTED fetch request <span class="keyword">for</span> partition my_topic-<span class="number">27</span> at offset <span class="number">11429299</span> to node p-kafka-host-<span class="number">03</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">6</span> rack: <span class="keyword">null</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Sending READ_UNCOMMITTED fetch <span class="keyword">for</span> partitions [my_topic-<span class="number">27</span>] to broker p-kafka-host-<span class="number">03</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">6</span> rack: <span class="keyword">null</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG kafka-coordinator-heartbeat-thread | myConsumerGroup org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending Heartbeat request <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup to coordinator p-kafka-host-<span class="number">02</span>:<span class="number">9092</span> (id: <span class="number">2147483642</span> rack: <span class="keyword">null</span>)</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup since it is rebalancing.</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-<span class="number">18</span>] <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">18</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">18</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup since it is rebalancing.</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-<span class="number">21</span>] <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">21</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">21</span>]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset <span class="number">11426689</span> <span class="keyword">for</span> partition my_topic-<span class="number">21</span> returned fetch data (error=NONE, highWaterMark=<span class="number">11426689</span>, lastStableOffset = -<span class="number">1</span>, logStartOffset = <span class="number">10552294</span>, abortedTransactions = <span class="keyword">null</span>, recordsSizeInBytes=<span class="number">0</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - <span class="keyword">Group</span> myConsumerGroup committed offset <span class="number">11429849</span> <span class="keyword">for</span> partition my_topic-<span class="number">18</span></div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining <span class="keyword">group</span> myConsumerGroup</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending JoinGroup ((type: JoinGroupRequest, groupId=myConsumerGroup, sessionTimeout=<span class="number">30000</span>, rebalanceTimeout=<span class="number">300000</span>, memberId=p-my-consumer-host-<span class="number">03</span>-<span class="number">12</span>-<span class="number">97</span>c12fb0-<span class="number">9</span>bb7-<span class="number">4762</span>-<span class="number">8478</span>-<span class="number">538</span>f06be9e90, protocolType=consumer, groupProtocols=org.apache.kafka.common.requests.JoinGroupRequest$ProtocolMetadata@<span class="number">54371</span>fac)) to coordinator p-kafka-<span class="number">02</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">2147483642</span> rack: <span class="keyword">null</span>)</div></pre></td></tr></table></figure>

<p>其中最重要的部分是：</p>
<blockquote>
<p><strong>2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed for group myConsumerGroup since it is rebalancing.<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-18] for group myConsumerGroup<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-18]<br>…<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining group myConsumerGroup</strong></p>
</blockquote>
<p>那为什么每次会这样呢？我们是有单独的线程在发起心跳的！!!</p>
<h3 id="Consumer_卡顿时的_jstack">Consumer 卡顿时的 jstack</h3>
<p>观察日志可以发现，卡顿时 ConsumerCoordinator 在不停地 rejoin group，并且做 rebalance，所以需要对比在正常和卡顿这两种情况下 ConsumerCoordinator 的行为。</p>
<h4 id="正常时的_ConsumerCoordinator">正常时的 ConsumerCoordinator</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> jstack.<span class="keyword">normal</span>.<span class="built_in">log</span> | <span class="keyword">grep</span> ConsumerCoordinator -B1 | <span class="keyword">grep</span> -<span class="keyword">v</span> ConsumerCoordinator | <span class="built_in">sort</span> | uniq -<span class="keyword">c</span></div><div class="line"><span class="number">32</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:931</span>)</div><div class="line"><span class="number">22</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:950</span>)</div></pre></td></tr></table></figure>

<h4 id="卡顿时的_ConsumerCoordinator">卡顿时的 ConsumerCoordinator</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> jstack.pause.<span class="built_in">log</span> | <span class="keyword">grep</span> ConsumerCoordinator -B1 | <span class="keyword">grep</span> -<span class="keyword">v</span> ConsumerCoordinator | <span class="built_in">sort</span> | uniq -<span class="keyword">c</span></div><div class="line"><span class="number">14</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.jav<span class="variable">a:316</span>)</div><div class="line"><span class="number">14</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:920</span>)</div><div class="line"><span class="number">8</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:931</span>)</div><div class="line"><span class="number">32</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:950</span>)</div></pre></td></tr></table></figure>

<p>根据以上的现场信息，可以发现关键就在 <code>AbstractCoordinator.ensureActiveGroup</code> 这一步，继续观察 jstack.pause.log 中的相关堆栈信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pool-16-thread-14"</span> #<span class="number">167</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f5b19dbf000</span> nid=<span class="number">0x7ac2</span> runnable [<span class="number">0x00007f5ae4ccb000</span>]</div><div class="line"><span class="label">   java.lang.Thread.State:</span> RUNNABLE</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollArrayWrapper.epollWait(Native Method)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollArrayWrapper.poll(EPollArrayWrapper.java:<span class="number">269</span>)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:<span class="number">79</span>)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.SelectorImpl.lockAndDoSelect(SelectorImpl.java:<span class="number">86</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e816b0</span>&gt; (a sun.nio.<span class="number">ch</span>.Util<span class="number">$2</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e816a0</span>&gt; (a java.util.Collections$UnmodifiableSet)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e742a0</span>&gt; (a sun.nio.<span class="number">ch</span>.EPollSelectorImpl)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.SelectorImpl.select(SelectorImpl.java:<span class="number">97</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.common.network.Selector.select(Selector.java:<span class="number">529</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.common.network.Selector.poll(Selector.java:<span class="number">321</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:<span class="number">433</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">232</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2f00da0</span>&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">208</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">168</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator.joinGroupIfNeeded(AbstractCoordinator.java:<span class="number">364</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:<span class="number">316</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:<span class="number">297</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:<span class="number">1078</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:<span class="number">1043</span>)</div><div class="line">        <span class="preprocessor">at</span> org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:<span class="number">571</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</div><div class="line">        <span class="preprocessor">at</span> java.lang.Thread.run(Thread.java:<span class="number">745</span>)</div></pre></td></tr></table></figure>

<h2 id="卡顿原因分析">卡顿原因分析</h2>
<h3 id="卡顿原因：Consumer_在_Region_Group">卡顿原因：Consumer 在 Region Group</h3>
<p>根据以上信息，结合 <code>org.apache.kafka.clients.consumer.internals.ConsumerCoordinator</code> 的代码可以发现在<br><code>ConsumerCoordinator#poll</code> 中判断 <code>needRejoin()</code> 为 true 时会调用 <code>ensureActiveGroup()</code> 函数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span>(<span class="keyword">long</span> now, <span class="keyword">long</span> remainingMs) {</div><div class="line">        invokeCompletedOffsetCommitCallbacks();</div><div class="line">        <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) {</div><div class="line">            ...</div><div class="line">            <span class="keyword">if</span> (needRejoin()) {</div><div class="line">                ...</div><div class="line">                ensureActiveGroup();</div><div class="line">                ...</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">             ...</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        pollHeartbeat(now);</div><div class="line">        maybeAutoCommitOffsetsAsync(now);</div><div class="line">    }</div></pre></td></tr></table></figure>

<h3 id="Region_Group_原因：Consumer_Leave_Group">Region Group 原因：Consumer Leave Group</h3>
<p>那么问题就是什么情况下 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator#needRejoin 会返回 true，我们还是看看他的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span>() {</div><div class="line">        <span class="keyword">if</span> (!subscriptions.partitionsAutoAssigned())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we need to rejoin if we performed the assignment and metadata has changed</span></div><div class="line">        <span class="keyword">if</span> (assignmentSnapshot != <span class="keyword">null</span> && !assignmentSnapshot.equals(metadataSnapshot))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we need to join if our subscription has changed since the last join</span></div><div class="line">        <span class="keyword">if</span> (joinedSubscription != <span class="keyword">null</span> && !joinedSubscription.equals(subscriptions.subscription()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.needRejoin();</div><div class="line">    }</div></pre></td></tr></table></figure>

<h1 id="kafka_metadata_什么时候变化？？？？">kafka metadata 什么时候变化？？？？</h1>
<p>可以看到，不是 metadataSnapshot 有变化，也不是 订阅者 subscriptions 有变化，那就是 super.needRejoin() 返回了 true，问题就转到了 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator#needRejoin</code> 这个函数，其实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span>() {</div><div class="line">    <span class="keyword">return</span> rejoinNeeded;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从代码上看 <code>rejoinNeeded</code> 的整个变化过程，初始化为 true，在 <code>initiateJoinGroup</code> 成功后，会赋值为 false，在 <code>maybeLeaveGroup</code> 时会赋值为 true，所以怀疑卡顿时是 consumer leave group 了。</p>
<h2 id="Consumer_Leave_Group_原因：pollTimeoutExpired">Consumer Leave Group 原因：pollTimeoutExpired</h2>
<p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator.HeartbeatThread#run</code> 中调用了 <code>maybeLeaveGroup()</code> 函数，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">                log.debug(<span class="string">"Heartbeat thread for group {} started"</span>, groupId);</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) {</div><div class="line">                        ...</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) {</div><div class="line">                            ...</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></div><div class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></div><div class="line">                            coordinatorDead();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></div><div class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></div><div class="line">                            maybeLeaveGroup();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) {</div><div class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></div><div class="line">                            <span class="comment">// coordinator disconnected</span></div><div class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            heartbeat.sentHeartbeat(now);</div><div class="line">                            ...</div><div class="line">                        }</div><div class="line">                  } <span class="comment">// end synchronized</span></div><div class="line">              } <span class="comment">// end while</span></div><div class="line">          } <span class="comment">//end try              </span></div><div class="line">} <span class="comment">// end run</span></div></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以是 pollTimeoutExpired 引起了 leave group.</p>
<h3 id="根本原因：pollTimeoutExpired">根本原因：pollTimeoutExpired</h3>
<p>pollTimeoutExpired 的原因是两次 poll 的时间间隔超过了设置的 maxPollInterval 值。</p>
<h2 id="解决方案">解决方案</h2>
<p>调整以下参数</p>
<ul>
<li>max.poll.records：100 (默认值 500)</li>
<li>max.poll.interval.ms：600000 (默认值 300000，也就是5分钟)</li>
</ul>
<h2 id="后续">后续</h2>
<p>至此，问题已经解决了，但是有一些疑问。</p>
<ul>
<li>对于这两个参数值的设定， 是 <code>max.poll.records</code> 越小越好，<code>max.poll.interval.ms</code> 越大越好吗？</li>
<li>已经设置过的 <code>session.timeout.ms</code> 和 <code>heartbeat.interval.ms</code>难道没用吗？为什么有这么多超时参数的设置啊？</li>
<li>已经设置过的 <code>max.partition.fetch.bytes</code> 没用吗？为什么还要设置 <code>max.poll.records</code> 啊？</li>
<li>整体上还需要调哪些参数才可以让 consumer 运行正常，或者是性能达到最大呢？</li>
</ul>
<p>在下一篇博客「Kafka Consumer 的实现」中，将会继续分析 Kafka Consumer 的消费过程和参数配置，试图回答以上问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/" title="Stanford Machine Learning - 5 广义线性模型" itemprop="url">Stanford Machine Learning - 5 广义线性模型</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T15:20:39.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_指数分布族(Exponential_Family)">1. 指数分布族(Exponential Family)</h2>
<h4 id="指数分布族的定义">指数分布族的定义</h4>
<p>若一类概率分布可以写成如下形式，那么它就属于指数分布族：<br>$$P(y;\eta) = b(y)exp(\eta^TT(y)-a(\eta))$$</p>
<ul>
<li>$\eta$: 自然参数，通常是一个实数</li>
<li>T(y): 充分统计量，通常，T(y)=y，实际上是一个概率分布的充分统计量（统计学知识）</li>
<li>a($\eta$) 被称为 log partition function</li>
</ul>
<p>对于给定的 a，b，T 三个函数，上式定义了一个以 $\eta$ 为参数的概率分布集合，即改变 $\eta$ 可以得到不同的概率分布，例如高斯分布和伯努利分布。</p>
<h4 id="指数分布族以及它们的特征">指数分布族以及它们的特征</h4>
<ul>
<li>正态分布（高斯分布）——总体噪音（由中心极限定理得）</li>
<li>伯努利分布——逻辑回归（对01问题建模）</li>
<li>多项式分布——K种结果的事情进行建模</li>
<li>泊松分布——对计数过程进行建模（一个样本中放射性衰变的数目，网站的访客数目，商店的顾客数目）</li>
<li>伽马分布，指数分布——正数的分布，对间隔进行建模（在公交车站等车的时间）</li>
<li>β分布，Dirichlet分布——对小数进行分布，对概率分布进行建模</li>
<li>Wishart分布——协方差的分布</li>
</ul>
<h2 id="2-_指数分布簇推导">2. 指数分布簇推导</h2>
<p>高斯分布(Gaussian)和伯努利(Bernoulli)分布都可以推导为指数分布族。</p>
<h3 id="2-1_伯努利分布的推导">2.1 伯努利分布的推导</h3>
<p>伯努利分布的概率公式为：$P(y=1;\phi)=\phi; P(y=0;\phi)=1-\phi;$</p>
<p>公式可经如下变换：<br>$$P(y;\phi)=\phi^y(1-\phi)^y$$<br>$$=exp(log(\phi^y(1-\phi)^y))=exp(ylog(\phi)+ (1-y)log(1-\phi))$$<br>$$=exp(log(\frac\phi{1-\phi})y + log(1-\phi))$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = 1$<br>$\eta = log(\frac\phi{1-\phi}) =&gt; \phi=\frac1{1+e^{-n}}$<br>$a(\eta) = -log(1-\phi) = log(1+e^n)$</p>
<h3 id="2-2_高斯分布的推导">2.2 高斯分布的推导</h3>
<p>在线性回归中，$\sigma$ 对于模型参数 $\theta$  的选择没有影响，为了推导方便我们令 $\sigma = 1$。<br>则有：<br>$$P(y;\mu)=\frac{1}{\sqrt{2\pi}}exp(-\frac12(y-\mu)^2)$$<br>$$=\frac{1}{\sqrt{2\pi}}exp(-\frac{1}{2}y^2) * exp({\mu}y-\frac{1}{2}\mu^2)$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = \frac{1}{\sqrt{2\pi}}exp(-\frac12y^2)$<br>$\eta = \mu$<br>$a(\eta) = \frac{{\mu}^2}2 = \frac{{\eta}^2}2$</p>
<h2 id="3-_广义线性模型(Generalized_Linear_Model)">3. 广义线性模型(Generalized Linear Model)</h2>
<p>想用 广义线性模型对一般问题进行建模首先需要明确几个 假设：</p>
<ol>
<li>$y | x;θ \sim ExponentialFamily(\eta)$ y的条件概率属于指数分布族;</li>
<li>给定 x 广义线性模型的目标是求解 T(y) | x， 不过由于 很多情况下 T(y) = y  所以我们的目标变成了 y | x , 也即 我们希望拟合函数为 h(x) = E[y|x] (这个条件在线性回归和逻辑回归中都满足， 例如在逻辑回归中 $hθ(x) = p(y = 1|x;\theta) = 0 \cdot p(y = 0|x; \theta) + 1 \cdot  p(y = 1|x; \theta) = E[y|x;\theta])$</li>
<li>自然参数 $\eta$ 与 x 是线性关系：$\eta=\theta^Tx$ ($\eta 为向量时 \eta_{i} = \theta_{i}^Tx$)</li>
</ol>
<p>有了如上假设，就可以进行建模和求解了。</p>
<p>对于伯努利分布，可以推导出：<br>…<br>这也就是逻辑回归中 sigmod 函数的由来。</p>
<h2 id="4-_多分类算法(Softmax_Regression)">4. 多分类算法(Softmax Regression)</h2>
<p>y有多个可能的分类：{1, 2, …, k}</p>
<p>=======具体的公式略=======</p>
<p>最后求借寻找最佳参数时，跟最小二乘和逻辑回归的解法类似，可以用梯度下降法或者牛顿迭代法。</p>
<h2 id="Referecen">Referecen</h2>
<p><a href="https://zhuanlan.zhihu.com/p/22876460" target="_blank" rel="external">广义线性模型(Generalized Linear Model)</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/" title="Stanford Machine Learning - 4 逻辑回归" itemprop="url">Stanford Machine Learning - 4 逻辑回归</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T15:06:43.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_逻辑回归">1. 逻辑回归</h2>
<p>对于逻辑回归而言，y 的取值不是 0 就是 1，所以 $h<em>θ(x)$ 可以写为<br>$$h</em>θ(x) = g(θ^{T}x)=\frac1{1+e^{-θ^{T}x}}$$</p>
<p>其中<br>$$g(z)=\frac1{1+e^{-z}}$$；</p>
<p>g(z) 被称为 logistic function 或 sigmoid function，其二维坐标下的曲线为:<br><img src="/img/sigmoid_function.png" alt="sigmoid function"></p>
<p>我们先取 g(z) 为 sigmoid function，如果有其他使得 y 值从 0 到 1 平滑递增的函数也可以使用。但由于一些列原因(在后续的一般化回归模型 GLM 中会谈到为什么选用这个函数)，g(z) is a fairly natural one.</p>
<p>g(z) 的导数我们可以先进行推导:<br>$$g’(z)=\frac{d}{dz}\frac{1}{1+e^{-z}}= \frac{1}{(1+e^{-z})^2}(e^{-z})$$<br>$$= \frac{1}{1+e^{-z}}*(1 - \frac{1}{1+e^{-z}})= g(z)(1-g(z))$$</p>
<h2 id="2-_梯度上升法求解逻辑回归">2. 梯度上升法求解逻辑回归</h2>
<p>对于给定的逻辑回归函数，我们使用最小二乘法来推导出最大似然估计，假设:<br>$P(y=1|x;θ)=h_θ(x)$，代表对于给定的 θ，y 取值为 1 的概率。<br>$P(y=0|x;θ)=1-h_θ(x)$，代表对于给定的 θ，y 取值为 0 的概率。</p>
<p>以上两者可以合并为：<br>$$P(y|x;θ)=(h_θ(x))^y(1 − h_θ(x))^{(1−y)}$$</p>
<p>假设 m 个训练集是相互独立的，则似然估计为：<br>$$L(θ)=P(\overrightarrow{y}|X;θ)$$<br>$$= \prod^m_{i=1}P(y^i|x^i;θ)$$<br>$$= \prod^m_{i=1}{(h_θ(x^{(i)}))^{y^{(i)}}(1 − h_θ(x^{(i)}))^{(1−y^{(i)})}}$$</p>
<p>和之前一样，上式可以简化为：</p>
<p></p><p><br>$l(θ) = logL(θ)<br>= \sum_{m}^{i=1}{y^{(i)}}log{h(x^{(i)}) + {(1−y^{(i)})}log(1 − h(x^{(i)}))}$</p>
<p>那么，<br>如何去最大化似然函数呢，可以应用梯度上升法，因为我们要使 P 的取值足够大，也是就预测准确的概率最够大。</p>
<p>随机梯度上升的公式为：<br>$$θ:= θ + \alpha\Deltaθl(θ)$$</p>
<p>下面来求$\Deltaθl(θ)$的取值：</p>
<p>$$\frac\partial{\partial\theta_j}l(\theta)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)})\frac\partial{\partial\theta_j}g(\theta^Tx)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)}) g(\theta^Tx)(1-g(\theta^Tx))\frac\partial{\partial\theta_j}\theta^Tx$$<br>$$= ({y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)})x_j$$<br>$$= (y - h_{\theta}(x))x_j$$</p>
<p>附上手写的推导过程：<br><img src="/img/logistic_regression_delta_ljp_derived.png" alt="手写推导过程"></p>
<p>所以，最终随机梯度上升的公式为：<br>$$θ_j:=θ_j + \alpha\sum_{i=1}^{m}(y^{(i)} - h_{\theta}(x^{(i))})x_j^{(i)}$$</p>
<p>如何和线性回归的公式放在一起比较，</p>
<p>$$θ_j = θ_j - α \frac1m <em> \sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}</em>x_j^{(i)}$$</p>
<p>会发现，这两者非常相似，实际上却不然，因为这里的 $(h_θ(x^{(i)})$ 定义的不是线性函数。后续我们谈到 GLM 时会发现这并不是巧合，而是有更深层次的原因。</p>
<h2 id="3-_牛顿迭代法求解逻辑回归">3. 牛顿迭代法求解逻辑回归</h2>
<p>牛顿迭代法可以利用到曲线本身的信息，比梯度下降法更容易收敛，即迭代更少次数。</p>
<h3 id="3-1_牛顿迭代法简述">3.1 牛顿迭代法简述</h3>
<p>假设我们要求解方程 f(x)=0 的根，首先随便找一个初始值 x0，如果 x0 不是解，做一个经过 (x0,f(x0))  这个点的切线，与 x 轴的交点为 x1。同样的道理，如果 x1 不是解，做一个经过 (x1,f(x1)) 这个点的切线，与 x 轴的交点为 x2。 以此类推。以这样的方式得到的 xi 会无限趋近于 f(x)=0 的解。</p>
<p>对于任意一点 $(x_n,y_n)$ 做切线，切线的斜率为 $f’(x_n)$，则有方程：<br>$$ y-f(x_n) = f’(x_n)(x-x_n) $$</p>
<h3 id="3-2_迭代过程">3.2 迭代过程</h3>
<p>求解 $f(\theta)$ = 0 时 $\theta$ 的取值。<br>设下一次迭代时 $\theta^{(t+1)}$ 的取值与前一次迭代 $\theta^{(t)}$ 的取值(在 x 轴)距离为 $\Delta$。</p>
<p>则 $\theta^{(t+1)} = \theta^{(t)} - \Delta$，且 $\Delta = \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$，<br>所以有：<br>$$\theta^{(t+1)} = \theta^{(t)} - \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$$</p>
<h4 id="从泰勒展开到牛顿迭代">从泰勒展开到牛顿迭代</h4>
<p>也可以由泰勒展开中推导牛顿迭代的公式。这次为了求解方程 f′=0 的根，把原函数 f(x) 的做泰勒展开，展开到二阶形式：<br>$$ f(x+\Delta x) = f(x)+f’(x)\Delta x+ \frac1{2}f’’(x)\Delta x^2 $$</p>
<p>当且仅当 $\Delta x$ 逼近 0 时，上式成立，此时忽略 1/2 系数的作用，所以有：<br>$$ f’(x)+ \frac1{2}f’’(x)\Delta x = 0 $$<br>故：<br>$$\Delta x = -\frac{f’(x)}{f’’(x)} $$</p>
<p><strong>对函数求极大值的方法</strong><br>&gt;</p>
<blockquote>
<ol>
<li>将原函数y=f(x)，对x求一次导数，得到dy/dx；</li>
<li>令dy/dx = 0，解得一次导函数的零点；</li>
<li>将原函数对x求二次导函数；</li>
<li>将解得的零点坐标的x值代入二次导函数，<br>如果是正值，零点所在位置，就是极小值点，再将该x值代入原函数，得到极小值；<br>如果是值值，零点所在位置，就是极大值点，再将该x值代入原函数，得到极大值；<br>如果是0，零点所在位置，既不是极小值点，也不是极大值点，是拐点。</li>
</ol>
</blockquote>
<p>所以求 $l(\theta)$ 在极大值处 $\theta$ 的取值，则是求 $l’(\theta) = 0$ 时 $\theta$ 的值，应用牛顿迭代法则有：</p>
<p>$$\theta^{(t+1)} = \theta^{(t)} - \frac{l’(\theta^{(t)})}{l’’(\theta^{(t)})}$$</p>
<h3 id="3-3_多维向量的牛顿迭代">3.3 多维向量的牛顿迭代</h3>
<p>对于多维向量 $\overrightarrow{X}$ 求解。<br>$$\theta := \theta - H^{-1} \nabla l(\theta)$$<br>其中<br>$\nabla l(\theta)$ 是对 $l(\theta)$ 求导的值。</p>
<p>H 是一个 n*n 的矩阵，n 是特征数量，元素的计算公式为：<br>$$H_ij= \frac{\partial^2{l({\theta)}}}{\partial{\theta_i}\partial{\theta_j}}$$</p>
<h3 id="3-4_牛顿迭代法的特点">3.4 牛顿迭代法的特点</h3>
<h4 id="是否收敛">是否收敛</h4>
<p>通常情况下是收敛的，但是需要满足一些条件，对于逻辑回归来讲，是收敛的。</p>
<h4 id="迭代速度">迭代速度</h4>
<p>每次迭代后，有解数字的误差是成平方倍减小的，是二次收敛函数。</p>
<h4 id="优缺点">优缺点</h4>
<p>优点：收敛快<br>缺点：特征多(上千个)时，每次迭代成本大</p>
<h2 id="Reference">Reference</h2>
<p><a href="http://blog.csdn.net/baimafujinji/article/details/51179381" target="_blank" rel="external">http://blog.csdn.net/baimafujinji/article/details/51179381</a><br><a href="http://blog.csdn.net/baimafujinji/article/details/51167852" target="_blank" rel="external">http://blog.csdn.net/baimafujinji/article/details/51167852</a><br><a href="https://www.jiqizhixin.com/articles/2017-08-09-3" target="_blank" rel="external">如何通过牛顿方法解决Logistic回归问题</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/" title="Stanford Machine Learning - 3 线性回归的概率解释" itemprop="url">Stanford Machine Learning - 3 线性回归的概率解释</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T14:04:40.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_欠拟合与过拟合">1. 欠拟合与过拟合</h2>
<p>欠拟合：underfitting，与训练数据贴合的不够好，不能准确预测未来目标值。<br>过拟合：overfitting，与训练数据贴合的太好了，预测未来目标值的准确性有较大风险。</p>
<p><img src="/img/LR_underfitting_and_overfitting.png" alt=""></p>
<h2 id="2-_线性模型的概率解释">2. 线性模型的概率解释</h2>
<p>思考：我们为什么要用最小二乘的指标作为 cost function？为什么不是绝对值或四次方？</p>
<blockquote>
<p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。<br>最小二乘是从函数形式上来看的，极大似然是从概率意义上来看的。事实上，最小二乘可以由高斯噪声假设+极大似然估计推导出来。当然极大似然估计还可以推导出其他的loss function， 比如logistic回归中，loss function是交叉熵。<br><a href="http://www.cnblogs.com/little-YTMM/p/5700226.html" target="_blank" rel="external">最大似然估计与最小二乘估计的区别</a></p>
</blockquote>
<p>一般的最小二乘法实际上是在假设误差项满足高斯分布且独立同分布的情况下，使似然性最大化。</p>
<h3 id="推导过程">推导过程</h3>
<p>回到预测房价的例子，假设最终的预测函数，每一次预测都有误差，用$ε^{(i)}$表示误差，则预测函数可以写为：<br>$$y^{(i)}=\theta^Tx^{(i)} + ε^{(i)} $$</p>
<p>其中，误差是随机分布的，均值为 0，服从高斯分布 $N(0,σ^2)$。</p>
<blockquote>
<p>Andrew Ng 讲到在大多数情况下，线性回归的误差值如果综合来看，就是符合高斯分布的。并且根据中心极限定律，正态分布确实是对误差项分布的合理猜想。</p>
</blockquote>
<p>所以<br>$$P(y^{(i)}|x^{(i)}; θ) = \frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$$</p>
<p>$P(y^{(i)}|x^{(i)}; θ)$ 表示：在 θ 为给定的参数的情况下，概率 $y^{(i)}$ 以 $x^{(i)}$ 为随机变量的概率分布，注意 θ 不是随机变量。</p>
<p>由于 ε(i) 是独立的同分布（IID：independentlyidentically distribution），所以以 θ 为变量的似然函数为：<br>$$<br>L(θ)=L(θ;X,Y)=p(Y|X;θ) = \prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$</p>
<p>对 L(θ) 取对数有：<br>$$<br>l(\theta)=logL(\theta)<br>= log\prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$<br>$$<br>= m\sum_{i=1}^{m}log\frac{1}{\sqrt{2\pi}\sigma} - \frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2<br>$$</p>
<p>最大化 $l(\theta)$ 即是最小化 $\frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2$，这样就是 cost function.</p>
<p>由于目标变量服从正态分布，但分布的均值和方差都未知，对均值和方差两个参数的合理估计是选取两个参数使得在正态分布的前提下，抽到各样本中的 y 值的概率最大，这就是最大似然估计的思想。</p>
<h1 id="Reference">Reference</h1>
<p><a href="http://www.holehouse.org/mlclass/07_Regularization.html" target="_blank" rel="external">http://www.holehouse.org/mlclass/07_Regularization.html</a><br><a href="http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html" target="_blank" rel="external">http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html</a><br><a href="https://rpubs.com/badbye/ml03" target="_blank" rel="external">https://rpubs.com/badbye/ml03</a><br><a href="http://www.qiujiawei.com/linear-algebra-15/" target="_blank" rel="external">http://www.qiujiawei.com/linear-algebra-15/</a><br><a href="http://www.jianshu.com/p/f1d3906e4a3e" target="_blank" rel="external">最大似然估计</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-Week-2-Linear-Regression-with-multiple-features/" title="Stanford Machine Learning - 2 线性回归进阶" itemprop="url">Stanford Machine Learning - 2 线性回归进阶</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T14:00:04.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_多变量的线性回归">1. 多变量的线性回归</h2>
<p>n: 特征(features) 数量<br>m: 训练集数量<br>$x^{(i)}$: </p>
<ul>
<li>表示一条训练数据的向量</li>
<li>i is an index into the training set</li>
<li>So <ul>
<li>x is an n-dimensional feature vector</li>
<li>$x^{(3)}$ is, for example, the 3rd training data</li>
</ul>
</li>
</ul>
<p>$x^{(j)}_i$: The value of feature j in the ith training example</p>
<p>例如，当 n=4 时:<br>$$h_θ(x) = θ_0 + θ_1x_1 + θ_2x_2 + θ_3x_3 + θ_4x_4$$</p>
<p>For convenience of notation, $x_0$ = 1, 所以最后的特征向量的维度是 n+1，从 0 开始，记为”X”，<br>则有：<br>$$h_θ(x)=θ^TX$$<br>$θ^T$: [1 * (n+1)] matrix</p>
<h3 id="1-1_多变量的梯度下降">1.1 多变量的梯度下降</h3>
<h3 id="Cost_Function">Cost Function</h3>
<p>$$J(θ_0, θ_1, …,θ_n) =  \frac1{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2}$$</p>
<h3 id="Gradient_descent">Gradient descent</h3>
<p>Repeat {<br>  $$ θ_j = θ_j - α\frac\partial{\partial J(θ_0, θ_1, …,θ_n)} $$<br>}</p>
<p>every iterator</p>
<ul>
<li>θj = θj - learning rate (α) times the partial derivative of J(θ) with respect to θJ(…)</li>
<li>We do this through a simultaneous update of every θj value</li>
</ul>
<p>$$ \frac\partial{\partial J(θ_0, θ_1, …,θ_n)} $$<br>$$ = \frac1m * \sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}*x_j^{(i)} $$</p>
<h2 id="2-_Gradient_Decent_in_practice">2. Gradient Decent in practice</h2>
<h3 id="2-1_Feature_Scaling">2.1 Feature Scaling</h3>
<p>假设只有 $x_1$,$x_2$ 两个变量，其中：$x_1\in(0,2000), x_2\in(1,5)$，则最后的 J(θ) 图形是一个椭圆，在椭圆下用梯度下降法会比圆形要耗时更久，So we need to rescale this input so it’s more effective，有很多方式，一种是将各个 feature 除以其本身的最大值，缩小范围至[0,1]，一种是各个 feature 减去 mean 然后除以最大值，缩小范围至[-0.5,0.5]</p>
<h3 id="Learning_Rate_α">Learning Rate α</h3>
<ul>
<li>working correctly: If gradient descent is working then J(θ) should decrease after every iteration</li>
<li>convergence: 收敛是指每经过一次迭代，J(θ)的值都变化甚小。</li>
<li>choose α<ol>
<li>When to use a smaller α<ul>
<li>If J(θ) is increasing, see below picture</li>
<li>If J(θ) looks like a series of waves, decreasing and increasing again</li>
<li>But if α is too small then rate is too slow</li>
</ul>
</li>
<li>Try a range of α values<ul>
<li>Plot J(θ) vs number of iterations for each version of alpha</li>
<li>Go for roughly threefold increases: 0.001, 0.003, 0.01, 0.03. 0.1, 0.3</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/img/gradient_descent_plot.jpg" alt=""></p>
<h2 id="2-2_Features_and_polynomial_regression">2.2 Features and polynomial regression</h2>
<h3 id="Can_create_new_features">Can create new features</h3>
<p>如何选择 features 和表达式尤为关键，例如房价与房子的长，房子的宽组成的表达式就会麻烦很多，若将房子的长乘以房子的宽得出面积，则有房价与房子面积的表达式，将会更容易拟合出房价的走势。</p>
<h3 id="Polynomial_regression">Polynomial regression</h3>
<p>例如房价的走势，如下图，横坐标 x 为房子的面积，纵坐标为房价，使用一元二次的方程，会得出下图的蓝色曲线。容易得到房价今后会有一个下降的过程，可实际上房价是不会随着面积的增大而下降的。所以需要重新选定 Polynomial regression，可以改为使用一元三次的方程或者使用平凡根的方程。</p>
<p><strong>所以选择合适的 Features 和 Polynomial regression 都非常重要。</strong></p>
<p><img src="/img/polynomial_regression_choose.jpg" alt=""></p>
<h2 id="3-_Normal_equation_求解多变量线性回归">3. Normal equation 求解多变量线性回归</h2>
<h3 id="3-1_Normal_equation">3.1 Normal equation</h3>
<p>举例说明，假设 J(θ) 是一元二次方程，如：J(θ)=a$θ^2$+bθ+c，则令 $$ \frac{d}{dθ}J(θ)=2aθ+b=0$$ 即可，求出最终的 θ 则得到了线性回归方程，可以预测出今后的 y 值。</p>
<p>更普遍地，当 θ 是一个 n+1 维的向量时，θ $\in$ $R^{n+1}$，则 cost function 如下：<br>$$ J(θ_0, θ_1, …,θ_n) =  \frac1{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2} $$<br>只需要令：<br>$$ \frac\partial{\partial θ_j}J(θ_0, θ_1, …,θ_n) = … = 0 $$，其中 j = 0,1,2,…,n<br>设 X 代表训练集的 features 的值的矩阵，y 代表训练集的结果的值的矩阵，假设训练集数量为 m, features 个数为 n, 则 X 为 (m*n) 的矩阵，y 为 (m*1) 的矩阵，可以推导出求 θ 向量的公式如下：<br>$$θ = (X^TX)^{-1}X^Ty$$</p>
<h2 id="4-_Gradient_descent_Vs_Normal_equation">4. Gradient descent Vs Normal equation</h2>
<h3 id="Gradient_descent-1">Gradient descent</h3>
<ul>
<li>Need to chose learning rate</li>
<li>Needs many iterations - could make it slower</li>
<li>Works well even when n is massive (millions)</li>
<li>Better suited to big data</li>
<li>What is a big n though: 100 or even a 1000 is still (relativity) small, If n is 10000 then look at using gradient descent</li>
<li>适用于线性回归会逻辑回归</li>
</ul>
<h3 id="Normal_equation">Normal equation</h3>
<ul>
<li>No need to chose a learning rate</li>
<li>No need to iterate, check for convergence etc.</li>
<li>Normal equation needs to compute $(X^TX)^{-1}$<ul>
<li>This is the inverse of an n x n matrix</li>
<li>With most implementations computing a matrix inverse grows by O(n3), So not great</li>
</ul>
</li>
<li>Slow of n is large, Can be much slower</li>
<li>仅适用于线性回归</li>
</ul>
<h2 id="5-_局部加权线性回归">5. 局部加权线性回归</h2>
<p>局部加权回归(locally weighted regression)简称 loess，其思想是，针对对某训练数据的每一个点，选取这个点及其临近的一批点做线性回归；同时也需要考虑整个训练数据，考虑的原则是距离该区域越近的点贡献越大，反之则贡献越小，这也正说明局部的思想。其 cost function 为：<br>$$J(\theta) = \sum_{i=1}^{m} w^{(i)}( y^{(i)}-\theta^Tx^{(i)} )^2$$</p>
<p>其中<br>$$ w^{(i)} =  exp (-\frac{(x^{(i)}-x)^2}{\tau^2})$$</p>
<p>$w^{(i)}$的形式跟正态分布很相似，但二者没有任何关系，仅仅只是便于计算。可以发现，$x^{(j)}$ 离 $x^{(i)}$ 非常近时，${w^{(i)}_j}$ 的值接近于1，此时 j 点的贡献很大，当 $x^{(j)}$ 离 $x^{(i)}$ 非常远时，${w^{(i)}_j}$ 的值接近于 0，此时 j 点的贡献很小。</p>
<p>$\tau^2$ 是波长函数(bandwidth)， 控制权重随距离下降的速度，τ 越小则 x 离 $x^{(i)}$ 越远时 $w^{(i)}$ 的值下降的越快。</p>
<p>所以，如果沿着 x 轴的每个点都进行局部直线拟合，那么你会发现对于这个数据集合来说，局部加权的预测结果，能够最终跟踪这条非线性的曲线。</p>
<p>但局部加权回归也有其缺点：</p>
<ul>
<li>每次对一个点的预测都需要整个数据集的参与，样本量大且需要多点预测时效率低。提高效率的方法参考 Andrew More’s KD Tree</li>
<li>不可外推，对样本所包含的区域外的点进行预测时效果不好，事实上这也是一般线性回归的弱点</li>
</ul>
<p>对于线性回归算法，一旦拟合出适合训练数据的参数θ，保存这些参数θ，对于之后的预测，不需要再使用原始训练数据集，所以是参数学习算法。</p>
<p>对于局部加权线性回归算法，每次进行预测都需要全部的训练数据（每次进行的预测得到不同的参数θ），没有固定的参数θ，所以是非参数算法(non-parametric algorithm)。</p>
<h2 id="Reference">Reference</h2>
<blockquote>
<p><a href="http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html" target="_blank" rel="external">http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-Week-2-Linear-Regression-with-multiple-features/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford Machine Learning-Week 1- Linear Regression with One Variable/" title="Stanford Machine Learning - 1 线性回归入门" itemprop="url">Stanford Machine Learning - 1 线性回归入门</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T13:55:04.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="引言">引言</h2>
<p>本系列的课程来源是 <a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="external">斯坦福大学公开课 CS229: 机器学习课程</a>，也可以看<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">网易公开课的资源</a>，是带字幕的。斯坦福的 CS229 课程相比于 Course 上的 <a href="https://zh.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a> 课程，理论更强，讲解的也更深入，需要有一些的高数基础。两个课程都看了前半部分，更推荐前者，所以相关笔记对应的都是 CS229 课程。</p>
<h2 id="1-_线性回归的定义">1. 线性回归的定义</h2>
<p>适用于监督学习，根据已有的数据集合(x, y)，来推断出将来的数据趋势。</p>
<h2 id="2-_单变量线性回归">2. 单变量线性回归</h2>
<p>最后的函数应该是 y = ax + b，假设 hypothesis 为：</p>
<p>$h_{\theta}$(x) = $\theta_{0}$ + $\theta_{1}$</p>
<p>则问题转化为求 $\theta_{0}$ 和 $\theta_{1}$ 的值。要求这两个值需要转化上式，并根据已有的数据来求解。下面介绍损失函数，又叫代价函数的概念。</p>
<h2 id="3-_Cost_Function">3. Cost Function</h2>
<p>针对每一组数据，公式的值是 $h_{\theta}$($x_{i}$), 实际的值是 $y_{i}$，我们要达到的效果则是公式能够尽量表达已有的 m 组数据集合，即 $( h_{\theta}(x^{(i)}) - y_{i})^{2}$ 的值尽量小。<br>所以，对于所有数据集合，需要求使得<br>$$ \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2}$$ 最小的 $\theta$ 值。</p>
<p>上式又称为 Cost Function，可以写为：</p>
<p>$$ J(\theta_0, \theta_1) =  \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2} $$</p>
<p>我们需要最小化这个 Cost Function。</p>
<h4 id="Cost_Function_的作用">Cost Function 的作用</h4>
<p>假设 $\theta_0$ = 0，则有 $\theta_1$ 和 J($\theta_1$) 的关系，且图形如下：<br><img src="/img/cost_function_theta1.jpg" alt=""></p>
<p>所以当 $\theta_1$ = 1 时，<br>$$ J(\theta_1)= \frac1{2m}\sum_{i=1}^{m}{(\theta_1x^{(i)} - y^{(i)})^2} $$<br>很容易看出，$J(\theta_1)$ 是关于 $\theta_1$ 的一元二次方程，对于所有的训练数据，每个 $\theta_1$ 的取值都会得到一个 $J(\theta_1)$ 值，而 $J(\theta_1)$ 和 $\theta_1$ 的对应关系根据一元二次方程可知，函数曲线如上图。<br>当 $J(\theta_1)$ 最小时，求得 $\theta_1$ 结果。</p>
<p>当 $\theta_0$ 和 $\theta_1$ 都不为 0 时，J($\theta_0$, $\theta_1$) 的图形如下：<br><img src="/img/cost_function_theta0_theta1.jpg" alt=""></p>
<p>对于两个系数的情况不如一个系数是一个二维坐标系的抛物线那么简单。下面将介绍梯度下降法。</p>
<h2 id="4-_梯度下降法">4. 梯度下降法</h2>
<ul>
<li>Start with initial guesses</li>
<li>Start at 0,0 (or any other value)</li>
<li>Keeping changing $\theta_0$ and $\theta_1$ a little bit to try and reduce J($\theta_0$, $\theta_1$)</li>
<li>Each time you change the parameters, you select the gradient which reduces J($\theta_0$, $\theta_1$) the most possible </li>
<li>Repeat</li>
<li>Do so until you converge to a local minimum<br>Has an interesting property<ul>
<li>Where you start can determine which minimum you end up</li>
<li>Here we can see one initialization point led to one local minimum</li>
<li>The other led to a different one</li>
</ul>
</li>
</ul>
<p><img src="/img/gradient_descent_progress.jpg" alt=""></p>
<h3 id="4-1_具体的计算过程">4.1 具体的计算过程</h3>
<p>$$ \theta_j := \theta_j - \alpha \frac\partial{\partial\theta_j}J(\theta_0, \theta_1)$$<br>(for j = 0 and j = 1)</p>
<h3 id="4-2_Notation">4.2 Notation</h3>
<p><strong>$\alpha$</strong></p>
<ul>
<li>Is a number called the learning rate</li>
<li>Controls how big a step you take<ul>
<li>If α is big have an aggressive gradient descent</li>
<li>If α is small take tiny steps</li>
</ul>
</li>
<li>Too small<ul>
<li>Take baby steps</li>
<li>Takes too long</li>
</ul>
</li>
<li>Too large<ul>
<li>Can overshoot the minimum and fail to converge</li>
</ul>
</li>
</ul>
<h3 id="4-3_Computer">4.3 Computer</h3>
<p>每次都是<strong>同时</strong>计算 $\theta_0, \theta_1$ 的值，如下：<br>$$ temp0:= \theta_0 - \alpha \frac\partial{\partial\theta_0}J(\theta_0, \theta_1)$$<br>$$ temp1:= \theta_1 - \alpha \frac\partial{\partial\theta_1}J(\theta_0, \theta_1)$$<br>$$ \theta_0 := temp0 $$<br>$$ \theta_1 := temp1 $$</p>
<p><img src="/img/gradient_descent_demo.jpg" alt=""></p>
<h4 id="4-4_利用梯度下降法求解线性回归问题">4.4 利用梯度下降法求解线性回归问题</h4>
<!-- $$
\begin{aligned}
& \frac\partial{\partial\theta\_j}J(\theta\_0, \theta\_1) \\
& = \frac\partial{\partial\theta\_j} * \frac1{2m}\sum\_{i=1}^{m}{(h\_{\theta}(x^{(i)}) - y^{(i)})^2} \\
& = \frac\partial{\partial\theta\_j} * \frac1{2m}\sum\_{i=1}^{m}{(\theta\_0 +\theta\_1x^{(i)} - y^{(i)})^2} \\
\end{aligned}
$$ -->


<p>$$ \frac\partial{\partial\theta_j}J(\theta_0, \theta_1) $$</p>
<p>$$ =\frac\partial{\partial\theta_j} * \frac1{2m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)}) - y^{(i)})^2} $$</p>
<p>$$ =\frac\partial{\partial\theta_j} * \frac1{2m}\sum_{i=1}^{m}{(\theta_0 +\theta_1x^{(i)} - y^{(i)})^2} $$</p>
<p>对于 j = 0 or 1 的情况有：<br>j = 0:<br>$$ \frac\partial{\partial\theta_0}J(\theta_0, \theta_1) = \frac1{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})$$<br>j = 1:<br>$$ \frac\partial{\partial\theta_1}J(\theta_0, \theta_1) = \frac1{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})*x^{(i)}$$</p>
<h3 id="4-5_梯度下降法的证明">4.5 梯度下降法的证明</h3>
<p>1、如果优化函数存在解析解。例如我们求最值一般是对优化函数求导，找到导数为0的点。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数。</p>
<p>2、如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，互相依赖的情况。或者求导后式子得不到解释解，或者未知参数的个数大于方程组的个数等。这时候使用迭代算法来一步一步找到最优解。</p>
<ul>
<li>当目标函数是凸函数时，梯度下降法的解是全局最优解</li>
<li>一般情况下，其解不保证是全局最优解</li>
</ul>
<h4 id="凸函数">凸函数</h4>
<p>凸函数就是一个定义在某个向量空间的凸子集C（区间）上的实值函数 f，而且对于凸子集C中任意两个向量 $x_1$, $x_2$ 有：<br>$$f(\frac{x_1+x_2}{2}) \le \frac{f(x_1)+f(x_2)}{2}$$<br>于是容易得出对于任意（0,1)中有理数 p，有：<br>$$f(px_1+(1-p)x_2) \le pf(x_1)+(1-p)f(x_2)$$<br>如果 f 连续，那么 p 可以改成任意（0,1）中实数。则 f 称为 I 上的凸函数，当且仅当其上境图（在函数图像上方的点集）为一个凸集。</p>
<h2 id="梯度下降法的使用">梯度下降法的使用</h2>
<p>我们首先在函数上任选一点，计算其损失（即我们上面的L(w)） ，然后按照某一规则寻找更低的一点计算新的损失，只要新损失更小（最小化问题），我们就继续下降，直到达到一个可接受的优化目标。<br>梯度下降方法分为两个部分，第一部分是整体上，我们使用某步长不断下降求损失函数，第二部分是为了防止步长太长导致最后无法收敛，每次当损失上升的时候都调整步长。<br>通常实践中使用时，都是用一些开源算法，很少需要深度改进，比如使用 libsvm 可以直接求解逻辑回归。</p>
<h2 id="Reference">Reference</h2>
<blockquote>
<p><a href="http://www.cnblogs.com/yysblog/p/3268508.html" target="_blank" rel="external">http://www.cnblogs.com/yysblog/p/3268508.html</a><br><a href="http://52opencourse.com/125/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E8%AF%BE-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-logistic-regression" target="_blank" rel="external">http://52opencourse.com/125/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E8%AF%BE-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-logistic-regression</a><br><a href="http://www.cnblogs.com/chaoren399/p/4851658.html" target="_blank" rel="external">http://www.cnblogs.com/chaoren399/p/4851658.html</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford Machine Learning-Week 1- Linear Regression with One Variable/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/19/Jackson反序列化忽略为null的字段/" title="Jackson反序列化忽略为null的字段" itemprop="url">Jackson反序列化忽略为null的字段</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-08-19T15:02:30.000Z" itemprop="datePublished"> Published Aug 19 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="要解决的问题">要解决的问题</h1>
<p>json 反序列化 bean 时，当某个字段在 json 中为 null 时，使用 bean 中声明的默认值。</p>
<p>Person 类我们改造下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Person {</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="comment">// Address is a enum: {CH, US, GZ}</span></div><div class="line">  <span class="keyword">private</span> Region region = Region.GZ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>仍然以 Person 类举例，如果 json 串是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">name</span>":<span class="value"><span class="string">"robert"</span></span>, "<span class="attribute">region</span>":<span class="value"><span class="literal">null</span></span>}</div></pre></td></tr></table></figure>

<p>希望反序列化后的 bean 为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person(<span class="variable">name=</span><span class="string">"robert"</span>, <span class="variable">region=</span>Region.GZ)</div></pre></td></tr></table></figure>

<h1 id="解决过程">解决过程</h1>
<p>在上一篇文章 <code>lombok 的 AllArgs 导致 Jackson 反序列化丢失字段默认值</code> 中可以看到 json 反序列化为 bean 的过程，一般情况下，是先调用默认构造函数生成 bean，然后根据 json 中出现的字段挨个赋值。<br>所以反序列化生成的 bean 的 region 肯定为 null。</p>
<h1 id="解决方案">解决方案</h1>
<h2 id="1-_@JsonInclude(Include-NON_NULL)_可行吗？">1. @JsonInclude(Include.NON_NULL) 可行吗？</h2>
<p>不可行，这个注解是序列化时忽略 null 值，反序列化时不生效，基本上反序列化时我们不能做什么事情。</p>
<h2 id="2-_JsonCreator_可行吗？">2. JsonCreator 可行吗？</h2>
<p>在 Region 枚举里写 JsonCreator:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@JsonCreator</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Region <span class="title">getRegion</span>(String <span class="keyword">value</span>) {</div><div class="line">    <span class="keyword">for</span> (Region region : Region.values()) {</div><div class="line">        <span class="keyword">if</span> (region.name().equals(<span class="keyword">value</span>)) {</div><div class="line">            <span class="keyword">return</span> region;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Region.GZ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接将 <code>{&quot;region&quot;: null}</code> 反序列化为 Region 是可行的，会调用 JsonCreator，但是如果是反序列化 Person 则不会调用到 JsonCreator，为什么呢？</p>
<p>debug 过程：<br>如前文所述，会调用到 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserialize</code> 这个函数中，然后会调用到<br><code>com.fasterxml.jackson.databind.deser.SettableBeanProperty#deserialize</code>，这个函数的实现是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">deserialize</span>(JsonParser p, DeserializationContext ctxt) <span class="keyword">throws</span> IOException {</div><div class="line">    JsonToken t = p.getCurrentToken();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (t == JsonToken.VALUE_NULL) {</div><div class="line">        <span class="keyword">return</span> _valueDeserializer.getNullValue(ctxt);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (_valueTypeDeserializer != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">return</span> _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> _valueDeserializer.deserialize(p, ctxt);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以在这里会把 null 值拦住，直接返回 getNullValue 的结果。</p>
<h2 id="3-自定义_deserializer">3.自定义 deserializer</h2>
<p>实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegionDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Region</span>&gt; </span>{</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Region <span class="title">deserialize</span>(JsonParser jsonParser, DeserializationContext deserializationContext)</div><div class="line">            <span class="keyword">throws</span> IOException {</div><div class="line">        JsonNode node = jsonParser.getCodec().readTree(jsonParser);</div><div class="line">        Region region = Region.GZ;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(node.textValue())) {</div><div class="line">                <span class="keyword">return</span> Region.getRegion(node.textValue());</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            type = Region.GZ;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> region;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Region <span class="title">getNullValue</span>(DeserializationContext ctxt) {</div><div class="line">        <span class="keyword">return</span> Region.GZ;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Person 类改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Person {</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  </div><div class="line">  <span class="comment">// Address is a enum: {CH, US, GZ}</span></div><div class="line">  @JsonDeserialize(<span class="keyword">using</span> = RegionDeserializer.class)</div><div class="line">  <span class="keyword">private</span> Region region = Region.GZ;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样，在<code>com.fasterxml.jackson.databind.deser.SettableBeanProperty#deserialize</code>这个方法里，碰到 null 值，就会返回 getNullValue 的结果，即 Region.GZ，如果不是 null 会进入 getRegion 函数处理，也能处理其他情况。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/08/19/Jackson反序列化忽略为null的字段/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/" title="lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值" itemprop="url">lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-08-19T14:27:12.000Z" itemprop="datePublished"> Published Aug 19 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="要解决的问题">要解决的问题</h1>
<p>希望在反序列化 json 到 bean 时，对于 json 中未出现的字段，在 bean 中赋上默认值。</p>
<p>例如<br>Person 类如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Data</span></div><div class="line"><span class="annotation">@AllArgsConstructor</span></div><div class="line"><span class="annotation">@NoArgsConstructor</span></div><div class="line"><span class="annotation">@JsonIgnoreProperties</span>(ignoreUnknown = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String address = <span class="string">"beijing"</span>; <span class="comment">// default value if json missing the age field</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>json: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">name</span>":<span class="value"><span class="string">"robert"</span></span>}</div></pre></td></tr></table></figure>

<p>反序列化后的 bean 为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person(<span class="variable">name=</span><span class="string">"robert"</span>, <span class="variable">address=</span><span class="string">"beijing"</span>)</div></pre></td></tr></table></figure>

<p>但实际上，发序列化的结果为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person(<span class="variable">name=</span><span class="string">"robert"</span>, <span class="variable">address=</span><span class="constant">null</span>)</div></pre></td></tr></table></figure>

<h1 id="解决过程">解决过程</h1>
<h2 id="1-_查看_maven_版本">1. 查看 maven 版本</h2>
<p>项目中 jackson 的配置如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${jackson.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${jackson.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>${jackson.version}<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Jackson dependency versions --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">jackson.version</span>&gt;</span>2.6.5<span class="tag">&lt;/<span class="title">jackson.version</span>&gt;</span></div></pre></td></tr></table></figure>

<p>配置升到最新后问题仍然存在。</p>
<h2 id="2-_debug_json_反序列化过程，找到原因">2. debug json 反序列化过程，找到原因</h2>
<p>json 反序列化是从</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">com</span>.fasterxml.jackson.databind.ObjectMapper<span class="preprocessor">#_readMapAndClose</span></div></pre></td></tr></table></figure>

<p>这个方法调用开始的，里面的一段代码为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="type">DeserializationConfig</span> cfg = getDeserializationConfig();</div><div class="line"><span class="type">DeserializationContext</span> ctxt = createDeserializationContext(jp, cfg);</div><div class="line"><span class="type">JsonDeserializer</span>&lt;<span class="type">Object</span>&gt; deser = _findRootDeserializer(ctxt, valueType);</div><div class="line"><span class="keyword">if</span> (cfg.useRootWrapping()) {</div><div class="line">    <span class="literal">result</span> = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="literal">result</span> = deser.deserialize(jp, ctxt);</div><div class="line">}</div><div class="line">ctxt.checkUnresolvedObjectId();</div></pre></td></tr></table></figure>

<p>在第 3 行找到的 JsonDeserializer 是 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer</code><br>从第 7 行代表进入 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserialize(com.fasterxml.jackson.core.JsonParser, com.fasterxml.jackson.databind.DeserializationContext)</code></p>
<p>函数实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object <span class="title">deserialize</span>(JsonParser p, DeserializationContext ctxt) <span class="keyword">throws</span> IOException {</div><div class="line">    <span class="comment">// common case first</span></div><div class="line">    <span class="keyword">if</span> (p.isExpectedStartObjectToken()) {</div><div class="line">        <span class="keyword">if</span> (_vanillaProcessing) {</div><div class="line">            <span class="keyword">return</span> vanillaDeserialize(p, ctxt, p.nextToken());</div><div class="line">        }</div><div class="line">        p.nextToken();</div><div class="line">        <span class="keyword">if</span> (_objectIdReader != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">return</span> deserializeWithObjectId(p, ctxt);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> deserializeFromObject(p, ctxt);</div><div class="line">    }</div><div class="line">    JsonToken t = p.getCurrentToken();</div><div class="line">    <span class="keyword">return</span> _deserializeOther(p, ctxt, t);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>vanillaDeserialize 为 false，最后走到了第 11 行，最后到了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">com</span>.fasterxml.jackson.databind.deser.BeanDeserializer<span class="preprocessor">#_deserializeUsingPropertyBased</span></div></pre></td></tr></table></figure>

<p>然后到 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">com</span>.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator<span class="preprocessor">#build</span></div></pre></td></tr></table></figure>

<p>在这个函数里有这样一段代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Object bean </span>=<span class="string"> _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_allProperties));</span></div></pre></td></tr></table></figure>

<p>调用的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">com</span>.fasterxml.jackson.databind.deser.ValueInstantiator#createFromObjectWith(<span class="keyword">com</span>.fasterxml.jackson.databind.DeserializationContext, java.lang.Object[])</div></pre></td></tr></table></figure>

<p>可以发现，createFromObjectWith 的第二个参数是数组，json 解出来的字段都放在了这个数组里。然后调用了 Person 类的全参构造函数，对于<br>缺失的字段自动补 null 值，这样就导致了 address 字段为 null。</p>
<h2 id="3-_解决方案">3. 解决方案</h2>
<p>去掉 @AllArgsConstructor 时，没有问题了，因为此时找到的 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer</code> 的  vanillaDeserialize 字段为 true，会调用 <code>vanillaDeserialize(p, ctxt, p.nextToken());</code>，这个函数的实现非常明确：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">vanillaDeserialize</span>(JsonParser p, DeserializationContext ctxt, JsonToken t) <span class="keyword">throws</span> IOException {</div><div class="line">        <span class="keyword">final</span> Object bean = _valueInstantiator.createUsingDefault(ctxt);</div><div class="line">        <span class="comment">// [databind#631]: Assign current value, to be accessible by custom serializers</span></div><div class="line">        p.setCurrentValue(bean);</div><div class="line">        <span class="keyword">if</span> (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {</div><div class="line">            String propName = p.getCurrentName();</div><div class="line">            do {</div><div class="line">                p.nextToken();</div><div class="line">                SettableBeanProperty prop = _beanProperties.find(propName);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (prop != <span class="keyword">null</span>) { <span class="comment">// normal case</span></div><div class="line">                    <span class="keyword">try</span> {</div><div class="line">                        prop.deserializeAndSet(p, ctxt, bean);</div><div class="line">                    } <span class="keyword">catch</span> (Exception e) {</div><div class="line">                        wrapAndThrow(e, bean, propName, ctxt);</div><div class="line">                    }</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">                handleUnknownVanilla(p, ctxt, bean, propName);</div><div class="line">            } <span class="keyword">while</span> ((propName = p.nextFieldName()) != <span class="keyword">null</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>先用默认构造函数生成 bean，此时的 bean 是有默认值的，然后将 json 中出现的字段的值赋值给 bean，这样 address 就有值了。</p>
<h2 id="4-_根本原因">4. 根本原因</h2>
<p>看上去是声明了全参构造函数导致的，所以想尝试自己写全参构造函数，在 address 为 null 时给其赋默认值。<br>写完如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Person</span>(String name, String address){</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.address == <span class="keyword">null</span>){</div><div class="line">            <span class="keyword">this</span>.address = <span class="string">"beijing"</span>;</div><div class="line">        }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>继续走刚才 debug 的流程，发现<strong>居然</strong>没有请求这个全参构造函数。</p>
<p>那问题就是 @AllArgsConstructor 生成的全参函数有不同之处，jackson 能够识别出来并用于反序列化。查看 jar 包中 Person 类的代码发现其全参构造函数如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@ConstructorProperties</span>({<span class="string">"name"</span>, <span class="string">"address"</span>})</div><div class="line"><span class="keyword">public</span> <span class="title">Person</span>(String name, String address){</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以，区别就是 <code>@ConstructorProperties({&quot;name&quot;, &quot;address&quot;})</code> 这个注解，这个注解的作用是指定构造函数参数的名字，Spring 可根据参数的名字注入 bean。<br>但最终为什么这样注解了，jackson 就调用了全参构造函数还不得而知，猜测是 jackson 在 <code>_findRootDeserializer</code> 这一步时，是找最适合的构造函数。</p>
<p>可以通过设置 @AllArgsConstructor(suppressConstructorProperties=true) 来禁用 @ConstructorProperties.</p>
<h1 id="结论">结论</h1>
<p>Lombok 的 @AllArgsConstructor 注解导致 Jackson 反序列化时调用了全参构造函数，将没有出现的字段都赋值为 null 了。</p>
<p>修改方式：</p>
<ol>
<li>不使用 @AllArgsConstructor</li>
<li>使用 @AllArgsConstructor 但是不让其在全参构造函数上加入 ConstructorProperties 注解，声明方式改为 @AllArgsConstructor(suppressConstructorProperties = true)</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/08/19/lombok的AllArgsConstructor注解导致Jackson反序列化后丢失字段默认值/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/13/服务调优/" title="服务调优" itemprop="url">服务调优</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-08-13T13:03:50.000Z" itemprop="datePublished"> Published Aug 13 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="目录">目录</h1>
<ol>
<li>服务异常的处理流程</li>
<li>负载</li>
<li>内存</li>
<li>服务指标</li>
<li>工具</li>
</ol>
<h1 id="1-_服务异常的处理流程">1. 服务异常的处理流程</h1>
<p><img src="/img/server_debug_online.jpg" alt=""></p>
<h1 id="2-_负载">2. 负载</h1>
<h2 id="2-1_查看机器_cpu_的负载">2.1 查看机器 cpu 的负载</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -b -n <span class="number">1</span> |grep java|awk '{<span class="literal">print</span> <span class="string">"VIRT:"</span><span class="variable">$5</span>,<span class="string">"RES:"</span><span class="variable">$6</span>,<span class="string">"cpu:"</span><span class="variable">$9</span><span class="string">"%"</span>,<span class="string">"mem:"</span><span class="variable">$10</span><span class="string">"%"</span>}'</div></pre></td></tr></table></figure>

<h2 id="2-2_查找_cpu_占用率高的线程">2.2 查找 cpu 占用率高的线程</h2>
<p>top -p 25603 -H<br>printf 0x%x 25842<br>jstack 25603 | grep 0x64f2</p>
<p>cat /proc/interrupts</p>
<p>（1）CPU<br>（2）Memory<br>（3）IO<br>（4）Network</p>
<p>可以从以下几个方面监控CPU的信息：<br>（1）中断；<br>（2）上下文切换；<br>（3）可运行队列；<br>（4）CPU 利用率。</p>
<h1 id="3-_内存">3. 内存</h1>
<h2 id="3-1_系统内存">3.1 系统内存</h2>
<p>free 命令<br>[root@server ~]# free</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:       3266180    3250000      10000          0     201000    3002000</div><div class="line">-<span class="ruby">/+ buffers/<span class="symbol">cache:</span>      <span class="number">47000</span>    <span class="number">3213000</span></span></div><div class="line">Swap:      2048276      80160    1968116</div></pre></td></tr></table></figure>

<p>这里的默认显示单位是kb。<br>各项指标解释</p>
<ul>
<li>total:总计物理内存的大小。</li>
<li>used:已使用多大。</li>
<li>free:可用有多少。</li>
<li>Shared:多个进程共享的内存总额。</li>
<li>buffers: 磁盘缓存的大小。</li>
<li>cache:磁盘缓存的大小。</li>
<li>-/+ buffers/cached): used:已使用多大，free:可用有多少。</li>
<li>已用内存 = 系统used memory - buffers - cached<br>（47000 = 3250000-201000-3002000）</li>
<li>可用内存 = 系统free memory + buffers + cached<br>（3213000 = 10000+201000+3002000）</li>
</ul>
<h4 id="什么是buffer/cache？">什么是buffer/cache？</h4>
<ul>
<li>buffer 指 Linux 内存的：Buffer cache，缓冲区缓</li>
<li>cache 指 Linux内存中的：Page cache，页面缓存</li>
</ul>
<p><strong>page cache</strong><br>page cache 主要用来作为<strong>文件系统上的文件数据的缓存</strong>来用，尤其是针对当进程对文件有 read／write 操作的时候。如果你仔细想想的话，作为可以映射文件到内存的系统调用：mmap是不是很自然的也应该用到 page cache？在当前的系统实现里，page cache 也被作为其它文件类型的缓存设备来用，所以事实上 page cache 也负责了大部分的块设备文件的缓存工作。</p>
<p><strong>buffer cache</strong><br>buffer cache 主要用来在<strong>系统对块设备进行读写</strong>的时候，对块进行数据缓存的系统来使用。这意味着某些对块的操作会使用 buffer cache 进行缓存，比如我们在格式化文件系统的时候。一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，page cache 的内容会被改变，而 buffer cache 则可以用来将 page 标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个 page 写回，而只需要写回修改的部分即可。</p>
<p>在当前的内核中，page cache 是针对内存页的缓存，说白了就是，如果有内存是以page进行分配管理的，都可以使用page cache作为其缓存来管理使用。<br>当然，不是所有的内存都是以页（page）进行管理的，也有很多是针对块（block）进行管理的，这部分内存使用如果要用到 cache 功能，则都集中到buffer cache中来使用。（从这个角度出发，是不是buffer cache改名叫做block cache更好？）然而，也不是所有块（block）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在X86上无论是32位还是64位都是4k。</p>
<h4 id="系统如何回收cache？">系统如何回收cache？</h4>
<p>Linux内核会在内存将要耗尽的时候，触发内存回收的工作，以便释放出内存给急需内存的进程使用。一般情况下，这个操作中主要的内存释放都来自于对buffer／cache的释放。尤其是被使用更多的cache空间。既然它主要用来做缓存，只是在内存够用的时候加快进程对文件的读写速度，那么在内存压力较大的情况下，当然有必要清空释放cache，作为free空间分给相关进程使用。所以一般情况下，我们认为buffer/cache空间可以被释放，这个理解是正确的。</p>
<p>但是这种清缓存的工作也并不是没有成本。理解cache是干什么的就可以明白清缓存必须保证cache中的数据跟对应文件中的数据一致，才能对cache进行释放。所以伴随着cache清除的行为的，一般都是系统IO飙高。因为内核要对比cache中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p>
<p>在系统中除了内存将被耗尽的时候可以清缓存以外，我们还可以人工触发缓存清除的操作。</p>
<h2 id="3-2_进程内存">3.2 进程内存</h2>
<h3 id="3-2-1_进程内存统计">3.2.1 进程内存统计</h3>
<p>/proc/[pid]/status<br>通过/proc/<pid>/status可以查看进程的内存使用情况，包括虚拟内存大小（VmSize），物理内存大小（VmRSS），数据段大小（VmData），栈的大小（VmStk），代码段的大小（VmExe），共享库的代码段大小（VmLib）等等。</pid></p>
<p>cat /proc/[pid]/status</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Name</span>: <span class="string">gedit /*进程的程序名*/</span></div><div class="line"><span class="attribute">State</span>: <span class="string">S (sleeping) /*进程的状态信息,具体参见http://blog.chinaunix.net/u2/73528/showart_1106510.html*/</span></div><div class="line"><span class="attribute">Tgid</span>: <span class="string">9744 /*线程组号*/</span></div><div class="line"><span class="attribute">Pid</span>: <span class="string">9744 /*进程pid*/</span></div><div class="line"><span class="attribute">PPid</span>: <span class="string">7672 /*父进程的pid*/</span></div><div class="line"><span class="attribute">TracerPid</span>: <span class="string">0 /*跟踪进程的pid*/</span></div><div class="line"><span class="attribute">VmPeak</span>: <span class="string">60184 kB /*进程地址空间的大小*/</span></div><div class="line"><span class="attribute">VmSize</span>: <span class="string">60180 kB /*进程虚拟地址空间的大小reserved_vm：进程在预留或特殊的内存间的物理页*/</span></div><div class="line"><span class="attribute">VmLck</span>: <span class="string">0 kB /*进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘*/</span></div><div class="line"><span class="attribute">VmHWM</span>: <span class="string">18020 kB /*文件内存映射和匿名内存映射的大小*/</span></div><div class="line"><span class="attribute">VmRSS</span>: <span class="string">18020 kB /*应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss)*/</span></div><div class="line"><span class="attribute">VmData</span>: <span class="string">12240 kB /*程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据*/</span></div><div class="line"><span class="attribute">VmStk</span>: <span class="string">84 kB /*进程在用户态的栈的大小*/</span></div><div class="line"><span class="attribute">VmExe</span>: <span class="string">576 kB /*程序所拥有的可执行虚拟内存的大小,代码段,不包括任务使用的库 */</span></div><div class="line"><span class="attribute">VmLib</span>: <span class="string">21072 kB /*被映像到任务的虚拟内存空间的库的大小*/</span></div><div class="line"><span class="attribute">VmPTE</span>: <span class="string">56 kB /*该进程的所有页表的大小*/</span></div><div class="line"><span class="attribute">Threads</span>: <span class="string">1 /*共享使用该信号描述符的任务的个数*/</span></div></pre></td></tr></table></figure>

<h3 id="3-2-2_JVM_内存分配">3.2.2 JVM 内存分配</h3>
<p>java内存组成介绍：堆(Heap)和非堆(Non-heap)内存</p>
<p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p>
<p><img src="quiver-image-url/590323FD2C5869E67568351DED266A03.jpg =501x363" alt="IMAGE"></p>
<ol>
<li>JVM本身需要的内存，包括其加载的第三方库以及这些库分配的内存</li>
<li>NIO的DirectBuffer是分配的native memory</li>
<li>内存映射文件，包括JVM加载的一些JAR和第三方库，以及程序内部用到的。上面 pmap 输出的内容里，有一些静态文件所占用的大小不在Java的heap里，因此作为一个Web服务器，赶紧把静态文件从这个Web服务器中人移开吧，放到nginx或者CDN里去吧。</li>
<li>JIT， JVM会将Class编译成native代码，这些内存也不会少，如果使用了Spring的AOP，CGLIB会生成更多的类，JIT的内存开销也会随之变大，而且Class本身JVM的GC会将其放到Perm Generation里去，很难被回收掉，面对这种情况，应该让JVM使用ConcurrentMarkSweep GC，并启用这个GC的相关参数允许将不使用的class从Perm Generation中移除， 参数配置： -XX:+UseConcMarkSweepGC -X:+CMSPermGenSweepingEnabled -X:+CMSClassUnloadingEnabled，如果不需要移除而Perm Generation空间不够，可以加大一点： -X:PermSize=256M -X:MaxPermSize=512M</li>
<li>JNI，一些JNI接口调用的native库也会分配一些内存，如果遇到JNI库的内存泄露，可以使用valgrind等内存泄露工具来检测</li>
<li>线程栈，每个线程都会有自己的栈空间，如果线程一多，这个的开销就很明显了</li>
<li>jmap/jstack 采样，频繁的采样也会增加内存占用，如果你有服务器健康监控，记得这个频率别太高，否则健康监控变成致病监控了。</li>
</ol>
<h4 id="1-方法区">1.方法区</h4>
<p>也称”永久代” 、“非堆”，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。</p>
<p>运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p>
<h4 id="2-虚拟机栈">2.虚拟机栈</h4>
<p>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p>
<h4 id="3-本地方法栈">3.本地方法栈</h4>
<p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
<h4 id="4-堆">4.堆</h4>
<p>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p>
<p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。</p>
<h4 id="5-程序计数器">5.程序计数器</h4>
<p>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h4 id="3-2-3_直接内存">3.2.3 直接内存</h4>
<p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>
<h3 id="3-2-4_JVM_内存分析">3.2.4 JVM 内存分析</h3>
<h4 id="查看_JVM_堆内存情况">查看 JVM 堆内存情况</h4>
<p>jmap -heap [pid]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">[root@server ~]$ jmap -heap <span class="number">837</span></div><div class="line">Attaching to process ID <span class="number">837</span>, please wait...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is <span class="number">24.71</span>-b01</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC <span class="keyword">with</span> <span class="number">4</span> thread(s)//GC 方式</div><div class="line"></div><div class="line">Heap Configuration: //堆内存初始化配置</div><div class="line">   <span class="variable">MinHeapFreeRatio =</span> <span class="number">0</span> //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default <span class="number">40</span>)</div><div class="line">   <span class="variable">MaxHeapFreeRatio =</span> <span class="number">100</span> //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default <span class="number">70</span>)</div><div class="line">   <span class="variable">MaxHeapSize      =</span> <span class="number">2082471936</span> (<span class="number">1986.0</span>MB) //对应jvm启动参数-XX:<span class="variable">MaxHeapSize=</span>设置JVM堆的最大大小</div><div class="line">   <span class="variable">NewSize          =</span> <span class="number">1310720</span> (<span class="number">1.25</span>MB)//对应jvm启动参数-XX:<span class="variable">NewSize=</span>设置JVM堆的‘新生代’的默认大小</div><div class="line">   <span class="variable">MaxNewSize       =</span> <span class="number">17592186044415</span> MB//对应jvm启动参数-XX:<span class="variable">MaxNewSize=</span>设置JVM堆的‘新生代’的最大大小</div><div class="line">   <span class="variable">OldSize          =</span> <span class="number">5439488</span> (<span class="number">5.1875</span>MB)//对应jvm启动参数-XX:<span class="variable">OldSize=</span>&lt;value&gt;:设置JVM堆的‘老生代’的大小</div><div class="line">   <span class="variable">NewRatio         =</span> <span class="number">2</span> //对应jvm启动参数-XX:<span class="variable">NewRatio=</span>:‘新生代’和‘老生代’的大小比率</div><div class="line">   <span class="variable">SurvivorRatio    =</span> <span class="number">8</span> //对应jvm启动参数-XX:<span class="variable">SurvivorRatio=</span>设置年轻代中Eden区与Survivor区的大小比值 </div><div class="line">   <span class="variable">PermSize         =</span> <span class="number">21757952</span> (<span class="number">20.75</span>MB)  //对应jvm启动参数-XX:<span class="variable">PermSize=</span>&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</div><div class="line">   <span class="variable">MaxPermSize      =</span> <span class="number">85983232</span> (<span class="number">82.0</span>MB)//对应jvm启动参数-XX:<span class="variable">MaxPermSize=</span>&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</div><div class="line">   <span class="variable">G1HeapRegionSize =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line"></div><div class="line">Heap Usage://堆内存使用情况</div><div class="line">PS Young Generation</div><div class="line">Eden Space://Eden区内存分布</div><div class="line">   <span class="variable">capacity =</span> <span class="number">33030144</span> (<span class="number">31.5</span>MB)//Eden区总容量</div><div class="line">   <span class="variable">used     =</span> <span class="number">1524040</span> (<span class="number">1.4534378051757812</span>MB)  //Eden区已使用</div><div class="line">   <span class="variable">free     =</span> <span class="number">31506104</span> (<span class="number">30.04656219482422</span>MB)  //Eden区剩余容量</div><div class="line">   <span class="number">4.614088270399305</span>% used //Eden区使用比率</div><div class="line">From Space:  //其中一个Survivor区的内存分布</div><div class="line">   <span class="variable">capacity =</span> <span class="number">5242880</span> (<span class="number">5.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">5242880</span> (<span class="number">5.0</span>MB)</div><div class="line">   <span class="number">0.0</span>% used</div><div class="line">To Space:  //另一个Survivor区的内存分布</div><div class="line">   <span class="variable">capacity =</span> <span class="number">5242880</span> (<span class="number">5.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">5242880</span> (<span class="number">5.0</span>MB)</div><div class="line">   <span class="number">0.0</span>% used</div><div class="line">PS Old Generation //当前的Old区内存分布</div><div class="line">   <span class="variable">capacity =</span> <span class="number">86507520</span> (<span class="number">82.5</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">0</span> (<span class="number">0.0</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">86507520</span> (<span class="number">82.5</span>MB)</div><div class="line">   <span class="number">0.0</span>% used</div><div class="line">PS Perm Generation//当前的 “永生代” 内存分布</div><div class="line">   <span class="variable">capacity =</span> <span class="number">22020096</span> (<span class="number">21.0</span>MB)</div><div class="line">   <span class="variable">used     =</span> <span class="number">2496528</span> (<span class="number">2.3808746337890625</span>MB)</div><div class="line">   <span class="variable">free     =</span> <span class="number">19523568</span> (<span class="number">18.619125366210938</span>MB)</div><div class="line">   <span class="number">11.337498256138392</span>% used</div><div class="line"></div><div class="line"><span class="number">670</span> interned Strings occupying <span class="number">43720</span> bytes.</div></pre></td></tr></table></figure>

<p>关于这里的几个generation网上资料一大把就不细说了，这里算一下求和可以得知前者总共给Java环境分配了644M的内存，而ps输出的VSZ和RSS分别是7.4G和2.9G，这到底是怎么回事呢？<br>前面jmap输出的内容里，MaxHeapSize 是在命令行上配的，-Xmx4096m，这个java程序可以用到的最大堆内存。<br>VSZ是指已分配的线性空间大小，这个大小通常并不等于程序实际用到的内存大小，产生这个的可能性很多，比如内存映射，共享的动态库，或者向系统申请了更多的堆，都会扩展线性空间大小，要查看一个进程有哪些内存映射，可以使用 pmap 命令来查看：<br>pmap -x [pid]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@server ~]$ pmap -x <span class="number">837</span></div><div class="line"><span class="number">837</span>:   java</div><div class="line">Address           Kbytes     RSS   Dirty Mode   Mapping</div><div class="line"><span class="number">0000000040000000</span>      <span class="number">36</span>       <span class="number">4</span>       <span class="number">0</span> r-x--  java</div><div class="line"><span class="number">0000000040108000</span>       <span class="number">8</span>       <span class="number">8</span>       <span class="number">8</span> rwx--  java</div><div class="line">00000000418c9000   <span class="number">13676</span>   <span class="number">13676</span>   <span class="number">13676</span> rwx--    [ anon ]</div><div class="line">00000006fae00000   <span class="number">83968</span>   <span class="number">83968</span>   <span class="number">83968</span> rwx--    [ anon ]</div><div class="line"><span class="number">0000000700000000</span>  <span class="number">527168</span>  <span class="number">451636</span>  <span class="number">451636</span> rwx--    [ anon ]</div><div class="line">00000007202d0000  <span class="number">127040</span>       <span class="number">0</span>       <span class="number">0</span> -----    [ anon ]</div><div class="line"><span class="keyword">...</span></div><div class="line"><span class="keyword">...</span></div><div class="line">00007f55ee124000       <span class="number">4</span>       <span class="number">4</span>       <span class="number">0</span> r-xs-  az.png</div><div class="line">00007fff017ff000       <span class="number">4</span>       <span class="number">4</span>       <span class="number">0</span> r-x--    [ anon ]</div><div class="line">ffffffffff600000       <span class="number">4</span>       <span class="number">0</span>       <span class="number">0</span> r-x--    [ anon ]</div><div class="line">----------------  ------  ------  ------</div><div class="line">total kB         <span class="number">7796020</span> <span class="number">3037264</span> <span class="number">3023928</span></div></pre></td></tr></table></figure>

<p>这里可以看到很多anon，这些表示这块内存是由mmap分配的。</p>
<p>RSZ是Resident Set Size，常驻内存大小，即进程实际占用的物理内存大小， 在现在这个例子当中，RSZ和实际堆内存占用差了2.3G，这2.3G的内存组成分别为：</p>
<h4 id="查看_JVM_堆各个分区的内存情况">查看 JVM 堆各个分区的内存情况</h4>
<p>jstat -gcutil [pid]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@server</span> ~]<span class="variable">$ </span>jstat -gcutil <span class="number">837</span> <span class="number">1000</span> <span class="number">20</span></div><div class="line">  <span class="constant">S0</span>     <span class="constant">S1</span>     <span class="constant">E</span>      <span class="constant">O</span>      <span class="constant">P</span>     <span class="constant">YGC</span>     <span class="constant">YGCT</span>    <span class="constant">FGC</span>    <span class="constant">FGCT</span>     <span class="constant">GCT</span>   </div><div class="line">  <span class="number">0</span>.<span class="number">00</span>  <span class="number">80.43</span>  <span class="number">24.62</span>  <span class="number">87.44</span>  <span class="number">98.29</span>   <span class="number">7101</span>  <span class="number">119.652</span>    <span class="number">40</span>   <span class="number">19.719</span>  <span class="number">139.371</span></div><div class="line">  <span class="number">0</span>.<span class="number">00</span>  <span class="number">80.43</span>  <span class="number">33.14</span>  <span class="number">87.44</span>  <span class="number">98.29</span>   <span class="number">7101</span>  <span class="number">119.652</span>    <span class="number">40</span>   <span class="number">19.719</span>  <span class="number">139.371</span></div></pre></td></tr></table></figure>

<h4 id="分析_JVM_堆内存中的对象">分析 JVM 堆内存中的对象</h4>
<p><strong>查看存活的对象统计</strong><br>jmap -histo:live [pid]</p>
<p><strong>dump 内存</strong><br>jmap -dump:format=b,file=heapDump [pid]</p>
<p>然后用jhat命令可以参看<br>jhat -port 5000 heapDump<br>在浏览器中访问：<a href="http://localhost:5000/" target="_blank" rel="external">http://localhost:5000/</a> 查看详细信息</p>
<h1 id="4-_服务指标">4. 服务指标</h1>
<h2 id="4-1_响应时间(RT)">4.1 响应时间(RT)</h2>
<p>响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p>
<p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。</p>
<h2 id="4-2_吞吐量(Throughput)">4.2 吞吐量(Throughput)</h2>
<p>吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。</p>
<p>对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p>
<h2 id="4-3_并发用户数">4.3 并发用户数</h2>
<p>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。</p>
<h2 id="4-4_QPS每秒查询率(Query_Per_Second)">4.4 QPS每秒查询率(Query Per Second)</h2>
<p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p>
<p>从以上概念来看吞吐量和响应时间是衡量系统性能的重要指标，QPS虽然和吞吐量的计量单位不同，但应该是成正比的，任何一个指标都可以含量服务器的并行处理能力。当然Throughput更关心数据量，QPS更关心处理笔数。</p>
<h2 id="4-5_CPU利用率">4.5 CPU利用率</h2>
<p>CPU Load Average &lt; CPU个数 <em> 核数 </em> 0.7 </p>
<p><strong>Context Switch Rate</strong><br>就是Process（Thread）的切换，如果切换过多，会让CPU忙于切换，也会导致影响吞吐量。《高性能服务器架构 》这篇文章的第2节就是说的是这个问题的。究竟多少算合适？google了一大圈，没有一个确切的解释。Context Switch大体上由两个部分组成：中断和进程(包括线程)切换，一次中断（Interrupt）会引起一次切换，进程（线程）的创建、激活之类的也会引起一次切换。CS的值也和TPS（Transaction Per Second）相关的，假设每次调用会引起N次CS，那么就可以得出</p>
<p>Context Switch Rate = Interrupt Rate + TPS* N</p>
<p>CSR减掉IR，就是进程/线程的切换，假如主进程收到请求交给线程处理，线程处理完毕归还给主进程，这里就是2次切换。也可以用CSR、IR、TPS的值代入公式中，得出每次事物导致的切换数。因此，要降低CSR，就必须在每个TPS引起的切换上下功夫，只有N这个值降下去，CSR就能降低，理想情况下N=0，但是无论如何如果N &gt;= 4，则要好好检查检查。另外网上说的CSR&lt;5000，我认为标准不该如此单一。</p>
<p>这三个指标在 LoadRunner 中可以监控到；另外，在 linux 中，也可以用 vmstat 查看r（Load Arerage），in（Interrupt）和cs（Context Switch）</p>
<h1 id="5-_工具">5. 工具</h1>
<p>uptime</p>
<p>dmesg</p>
<p>top<br>查看进程活动状态以及一些系统状况</p>
<p>vmstat<br>查看系统状态、硬件和系统信息等</p>
<p>iostat<br>查看CPU 负载，硬盘状况</p>
<p>sar<br>综合工具，查看系统状况</p>
<p>mpstat<br>查看多处理器状况</p>
<p>netstat<br>查看网络状况</p>
<p>iptraf<br>实时网络状况监测</p>
<p>tcpdump<br>抓取网络数据包，详细分析</p>
<p>mpstat<br>查看多处理器状况</p>
<p>tcptrace<br>数据包分析工具</p>
<p>netperf<br>网络带宽工具</p>
<p>dstat<br>综合工具，综合了 vmstat, iostat, ifstat, netstat 等多个信息</p>
<h1 id="Reference">Reference</h1>
<p><a href="http://tmq.qq.com/2016/07/it-is-necessary-to-know-the-background-performance-test/" target="_blank" rel="external">http://tmq.qq.com/2016/07/it-is-necessary-to-know-the-background-performance-test/</a><br><a href="https://www.ibm.com/developerworks/java/library/j-nativememory-linux/" target="_blank" rel="external">https://www.ibm.com/developerworks/java/library/j-nativememory-linux/</a><br><a href="http://www.oracle.com/technetwork/java/javase/index-137495.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/index-137495.html</a><br><a href="http://www.hollischuang.com/archives/303" target="_blank" rel="external">http://www.hollischuang.com/archives/303</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/调试/">调试</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/08/13/服务调优/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/java/" title="java">java<sup>15</sup></a></li>
		
			<li><a href="/tags/算法/" title="算法">算法<sup>8</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>6</sup></a></li>
		
			<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>5</sup></a></li>
		
			<li><a href="/tags/分布式/" title="分布式">分布式<sup>3</sup></a></li>
		
			<li><a href="/tags/调试/" title="调试">调试<sup>3</sup></a></li>
		
			<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		
			<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>2</sup></a></li>
		
			<li><a href="/tags/网络/" title="网络">网络<sup>2</sup></a></li>
		
			<li><a href="/tags/test/" title="test">test<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>1</sup></a></li>
		
			<li><a href="/tags/skill/" title="skill">skill<sup>1</sup></a></li>
		
			<li><a href="/tags/安全/" title="安全">安全<sup>1</sup></a></li>
		
			<li><a href="/tags/spark/" title="spark">spark<sup>1</sup></a></li>
		
			<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
		
			<li><a href="/tags/Spark/" title="Spark">Spark<sup>1</sup></a></li>
		
			<li><a href="/tags/promote/" title="promote">promote<sup>1</sup></a></li>
		
			<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>1</sup></a></li>
		
			<li><a href="/tags/总结/" title="总结">总结<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m ljp215 Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2017 
		
		<a href="http://luojinping.com/about" target="_blank" title="Jinping Luo">Jinping Luo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>





<script type="text/javascript">

var disqus_shortname = 'zane215';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>








<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fnull' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- MathJax End -->

  </body>
 </html>
