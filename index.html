
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Zane Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Jinping Luo">
    
    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zane Blog">
<meta property="og:url" content="http://luojinping.com/">
<meta property="og:site_name" content="Zane Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zane Blog">
<meta name="twitter:description">


    
    <link rel="alternative" href="/atom.xml" title="Zane Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a2d87d3add52ff134d9fac6cc16e4800";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Zane Blog" title="Zane Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Zane Blog">Zane Blog</a></h1>
				<h2 class="blog-motto">业精于勤荒于嬉，形成思毁于随</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:luojinping.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/02/25/概率论知识/" title="概率论知识" itemprop="url">概率论知识</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2018-02-25T02:34:09.000Z" itemprop="datePublished"> Published Feb 25 2018</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>概率论在机器学习中扮演着一个核心角色，因为机器学习算法的设计通常依赖于对数据的概率假设。</p>
<p>随机变量在概率论中扮演着一个重要角色。最重要的一个事实是，随机变量并不是变量，它们实际上是将（样本空间中的）结果映射到真值的函数。我们通常用一个大写字母来表示随机变量。 </p>
<h2 id="条件分布">条件分布</h2>
<p>条件分布为概率论中用于探讨不确定性的关键工具之一。它明确了在另一随机变量已知的情况下（或者更通俗来说，当已知某事件为真时）的某一随机变量的分布。 </p>
<p>正式地，给定$Y=b$时，$X=a$的条件概率定义为：<br>$$P(X=a|Y=b)= \frac{P(X=a,Y=b)}{P(Y=b)}$$</p>
<p>其中，$P(Y=b)&gt;0$</p>
<h2 id="独立性">独立性</h2>
<p>在概率论中，独立性是指随机变量的分布不因知道其它随机变量的值而改变。在机器学习中，我们通常都会对数据做这样的假设。例如，我们会假设训练样本是从某一底层空间独立提取；并且假设样例i的标签独立于样例j(i≠j)的特性。<br>从数学角度来说，随机变量X独立于Y，当： </p>
<p>P(X)=P(X|Y)</p>
<p>注意，上式没有标明X,Y的取值，也就是说该公式对任意X,Y可能的取值均成立。）<br>利用等式(2)，很容易可以证明如果X对Y独立，那么Y也独立于X。当X和Y相互独立时，记为X⊥Y。<br>对于随机变量X和Y的独立性，有一个等价的数学公式：<br>P(X,Y)=P(X)P(Y)</p>
<p>我们有时也会讨论条件独立，就是当我们当我们知道一个随机变量（或者更一般地，一组随机变量）的值时，那么其它随机变量之间相互独立。正式地，我们说“给定Z，X和Y条件独立”，如果：<br>P(X|Z)=P(X|Y,Z)</p>
<p>或者等价的：<br>P(X,Y|Z)=P(X|Z)P(Y|Z)</p>
<h2 id="链式法则">链式法则</h2>
<p>我们现在给出两个与联合分布和条件分布相关的，基础但是重要的可操作定理。第一个叫做链式法则，它可以看做等式(2)对于多变量的一般形式。<br>定理1（链式法则）： </p>
<p>P(X1,X2,…,Xn)=P(X1)P(X2|X1)…P(Xn|X1,X2,…,Xn−1)…………(3)</p>
<p>链式法则通常用于计算多个随机变量的联合概率，特别是在变量之间相互为（条件）独立时会非常有用。注意，在使用链式法则时，我们可以选择展开随机变量的顺序；选择正确的顺序通常可以让概率的计算变得更加简单。<br>第二个要介绍的是贝叶斯定理。利用贝叶斯定理，我们可以通过条件概率P(Y|X)计算出P(X|Y)，从某种意义上说，就是“交换”条件。它也可以通过等式(2)推导出。</p>
<h2 id="条件概率">条件概率</h2>
<h4 id="条件概率-1">条件概率</h4>
<p>如果 A，B 是条件组 S 下的随机事件，事件 A 发生的概率随事件 B 是否发生而变化，同样，事件 B 发生的概率也随事件 A 是否发生而变化。<br>事件 A 在另外一个事件 B 已经发生条件下的发生概率称为条件概率，表示为P(A|B)，读作「在 B 条件下 A 的概率」。<br>当 P(B) &gt; 0 时，有：<br>$$P(A|B)= \frac{P(AB)}{P(B)}$$</p>
<p>P.S. 如果 A，B 是独立事件，则 A 发生的概率与 B 无关，那么 $P(A|B) = P(A)$，并且 $P(AB)=P(A)P(B)$。</p>
<h4 id="联合概率">联合概率</h4>
<p>联合概率表示两个事件共同发生的概率。A 与 B 的联合概率表示为<br>$P(A\cap B)$ 或者 ${\displaystyle P(A,B)}$ 或者 $P(A,B)$。</p>
<h4 id="边缘概率">边缘概率</h4>
<p>边缘概率是某个事件发生的概率。边缘概率是这样得到的：在联合概率中，把最终结果中不需要的那些事件合并成其事件的全概率而消失（对离散随机变量用求和得全概率，对连续随机变量用积分得全概率）。这称为边缘化（marginalization）。A的边缘概率表示为$P(A)$，B的边缘概率表示为$P(B)$。</p>
<h2 id="全概率公式">全概率公式</h2>
<p><img src="/img/law_of_total_probability.jpg" alt="law of total probability"> </p>
<h2 id="贝叶斯定理">贝叶斯定理</h2>
<p>$$P(X|Y)=\frac{P(Y|X)P(X)}{P(Y)}$$</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87</a><br><a href="http://blog.csdn.net/u012566895/article/details/51220127" target="_blank" rel="external">http://blog.csdn.net/u012566895/article/details/51220127</a><br><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2018/02/25/概率论知识/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/02/25/Stanford-Machine-Learning-6-生成学习算法/" title="Stanford Machine Learning - 6 生成学习算法" itemprop="url">Stanford Machine Learning - 6 生成学习算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2018-02-25T02:24:02.000Z" itemprop="datePublished"> Published Feb 25 2018</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="生成学习算法介绍">生成学习算法介绍</h2>
<p>有监督机器学习可以分为判别学习算法(generative learning algorithm)和生成学习算法(discriminative learning algorithm)。</p>
<ul>
<li>判别学习算法常见的有：逻辑回顾，支持向量机等。</li>
<li>生成学习算法常见的有：混合高斯模型、朴素贝叶斯法和隐形马尔科夫模型等。</li>
</ul>
<p>判别学习算法是直接学习 p(y|x) 或者是从输入直接映射到输出的算法。</p>
<p>生成学习算法是计算变量x在变量y上的条件分布p(x|y)和变量y的分布p(y) ，然后使用贝叶斯公式:  $p(y|x)=\frac{p(x,y)}{p(x)}=\frac{p(y)*p(x|y)}{p(x)}$ 计算出p(y|x)。</p>
<p>针对课程中提到的两种生成学习算法中，高斯判别分析(Gaussian Discriminant Analysis)和朴素贝叶斯(Navie Bayes)分别解决了两种场景下的问题。<br>GDA 是针对的是特征向量 X 为连续值时的问题，而 Navie Bayes 则针对的是特征向量为离散值时的问题。</p>
<h2 id="高斯判别分析">高斯判别分析</h2>
<h3 id="多维正态分布(The_multivariate_normal_distribution)">多维正态分布(The multivariate normal distribution)</h3>
<p>假设随机变量 $X$ 满足 $n$ 维的多项正态分布，参数为均值向量 $μ ∈ R^{n} $，协方差矩阵$Σ ∈ R^{n×n}$，记为 $N(μ,Σ)$ 其概率密度表示为：</p>
<p>$$p(x;μ,Σ)=\frac{1}{(2π)^{\frac{n}2}(detΣ)^{\frac12}}exp(−\frac12(x−μ)^TΣ^{−1}(x−μ))$$</p>
<p>$detΣ$ 表示矩阵 $Σ$ 的行列式(determinant)。<br>均值向量: $μ$<br>协方差矩阵: $Σ=E[(X−E[X])(X−E[X])T]=E[(x−μ)(x−μ)T]$</p>
<h3 id="高斯判别分析-1">高斯判别分析</h3>
<p>GDA 模型针对的是输入特征为连续值时的分类问题，这个模型的基本假设是目标值 y 服从伯努利分布(0-1分布)，条件概率 P(x|y) 服从多元正态分布((multivariate normal distribution))，即:<br>$y∼Bernoulli(\phi)$<br>$P(x|y=0)∼N(μ_0,\Sigma)$<br>$P(x|y=1)∼N(μ_1,\Sigma)$</p>
<p>它们的概率密度为：<br>$$p(y)=\phi^y(1−\phi)^{1−y}$$<br>$$p(x|y=0)=\frac1{(2π)^{n/2}|\Sigma|^{1/2}}exp(−\frac12(x−μ_0)^T\Sigma^{−1}(x−μ_0))$$<br>$$p(x|y=1)=\frac1{(2π)^{n/2}|\Sigma|^{1/2}}exp(−\frac12(x−μ_1)^T\Sigma^{−1}(x−μ_1))$$</p>
<p>我们模型的参数包括，$\phi,\Sigma,μ_0,μ_1$ 注意到，我们使用了两种不同的均值向量$μ_0$和$μ_1$，但是使用了同一种协方差矩阵 $\Sigma$, 则我们的极大似然函数的对数如下所示：<br>$$L(\phi,μ_0,μ_1,\Sigma)=log\Pi_{i=1}^mp(x^{(i)},y^{(i)};\phi,μ_0,μ_1,\Sigma)$$<br>$$=log\Pi_{i=1}^mp(x^{(i)}|y^{(i)};\phi,μ_0,μ_1,\Sigma)p(y^{(i)};\phi)$$</p>
<p>对极大似然函数对数最大化，我们就得到了GDA模型各参数的极大虽然估计(略)。</p>
<h2 id="GDA_与_LR">GDA 与 LR</h2>
<p>前面我们提到：<br>$${argmax}_yp(y|x)={argmax}_y\frac{p(x|y)p(y)}{p(x)}={argmax}_yp(x|y)p(y)$$<br>我们有：<br>$$p(y=1|x)=\frac{p(x|y=1)p(y=1)}{p(x|y=1)p(y=1)+p(x|y=0)p(y=0)}$$<br>上式实际上可以表示成logistic函数的形式：<br>$$p(y=1|x;ϕ,μ0,μ1,Σ)=\frac1{1+exp(−θ^TX)}$$<br>其中，θ是参数ϕ,μ0,μ1,Σθ是参数ϕ,μ0,μ1,Σ某种形式的函数。GDA的后验分布可以表示logistic函数的形式。<br>　<br>下图为用 GDA 对两类样本分别拟合高斯概率密度函数p(x|y=0)和p(x|y=1)，得到两个钟形曲线。沿x轴遍历样本，在x轴上方画出相应的p(y=1|x)。如选x轴靠左的点，那么它属于1的概率几乎为0，p(y=1|x)=0，两条钟形曲线交点处，属于0或1的概率相同，p(y=1|x)=0.5，x轴靠右的点，输出1的概率几乎为1，p(y=1|x)=1。最终发现，得到的曲线和sigmoid函数曲线很相似。<br><img src="/img/gaussian_discriminant_analysis_probability_distribution.jpg" alt="gaussian discriminant analysis probability distribution"><br>　<br>　<br>实际上，可以证明，不仅仅当先验概率分布服从多变量正态分布时可以推导出逻辑回归的模型，当先验分布属于指数分布簇中的任何一个分布，如泊松分布时，都可以推导出逻辑回归模型。而反之不成立，逻辑回归的先验概率分布不一定必须得是指数分布簇中的成员。基于这些原因，在实践中使用逻辑回归比使用GDA更普遍。</p>
<p>生成学习算法比判决学习算法需要更少的数据。如GDA的假设较强，所以用较少的数据能拟合出不错的模型。而逻辑回归的假设较弱，对模型的假设更为健壮，拟合数据需要更多的样本。</p>
<h2 id="朴素贝叶斯">朴素贝叶斯</h2>
<p>考虑自变量比较多的情况，比如垃圾邮件的识别需要检测成百上千甚至上万的字符是否出现，如有<em>免费</em>、<em>购买</em>等类似的词出现的邮件很大可能是垃圾邮件。这种情况下若有k个自变量，考虑各变量之间的交互作用就需要计算$2^k$次，为了简化计算量对模型作一个更强的假设：<br><strong>给定因变量 y 的值，各自变量之间相互独立.</strong></p>
<p>所以有<br>$$p(x_1,…,x_n|y)=p(x_1|y)p(x_2|y,x_1)p(x_3|y,x_1,x_2)…p(x_n|y,x_1,x_2,…,x_{n-1})$$<br>$$=p(x_1|y)p(x_2|y)p(x_3|y)…p(x_n|y)=\Pi_{i=1}^np(x_i|y)$$</p>
<p>第一个等式是根据通常的概率论得到的，第二个等式是根据贝叶斯假设得到的。虽然贝叶斯假设是个很强的假设，但是实践证明在许多问题上都表现得很好。</p>
<p>参数的极大似然估计及p(y|x)的推导过程略。</p>
<h2 id="拉普拉斯平滑">拉普拉斯平滑</h2>
<p>拉普拉斯平滑(Laplace Smoothing)又称为加1平滑。平滑方法的存在是为了解决零概率问题。</p>
<p>所谓的零概率问题，就是在计算新实例的概率时，如果某个分量在训练集中从没出现过，会导致整个实例的概率计算结果为０，针对文本分类问题就是当一个词语在训练集中没有出现过，那么该词语的概率为０，使用连乘计算文本出现的概率时，整个文本出现的概率也为０，这显然不合理，因为不能因为一个事件没有观测到就判断该事件的概率为０.</p>
<h2 id="Reference">Reference</h2>
<p><a href="http://xtf615.com/2017/03/25/%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/" target="_blank" rel="external">http://xtf615.com/2017/03/25/%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</a><br><a href="http://blog.csdn.net/v1_vivian/article/details/52190572" target="_blank" rel="external">http://blog.csdn.net/v1_vivian/article/details/52190572</a><br><a href="http://www.cnblogs.com/mikewolf2002/p/7763475.html" target="_blank" rel="external">http://www.cnblogs.com/mikewolf2002/p/7763475.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2018/02/25/Stanford-Machine-Learning-6-生成学习算法/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/31/LeetCode-Binary-Tree-Maximum-Path-Sum/" title="LeetCode-Binary-Tree-Maximum-Path-Sum" itemprop="url">LeetCode-Binary-Tree-Maximum-Path-Sum</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2018-01-31T00:13:03.000Z" itemprop="datePublished"> Published Jan 31 2018</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Problem_Description">Problem Description</h2>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  1</div><div class="line"> / <span class="command">\</span></div><div class="line">2   3</div></pre></td></tr></table></figure>

<p>Return 6.</p>
<p><strong> problem link: </strong><br><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-maximum-path-sum/description/</a></p>
<h2 id="Solution">Solution</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">int</span> maxValue;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span>(TreeNode root) {</div><div class="line">        maxValue = Integer.MIN_VALUE;</div><div class="line">        maxPathDown(root);</div><div class="line">        <span class="keyword">return</span> maxValue;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span>(TreeNode node) {</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</div><div class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</div><div class="line">        maxValue = Math.max(maxValue, left + right + node.val);</div><div class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="解题思路">解题思路</h2>
<p>每一个结点可以选和不选，处理方法就是：<code>int left = Math.max(0, maxPathDown(node.left));</code>，其中的 Math.max(0, x)，当取值为 0 时就是不取这个结点。</p>
<p>全局变量 maxValue 就覆盖了子树中的 ^ 这种类型，例如子树如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">       x</div><div class="line">   a     y</div><div class="line">b    <span class="built_in">c</span></div></pre></td></tr></table></figure>

<p>则 b-&gt;a-&gt;c 这种路径的最大值被 maxValue 保存了。而 b-&gt;a-&gt;x-&gt;y 这种经过根节点的路径被 <code>Math.max(left, right) + node.val;</code> 覆盖了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2018/01/31/LeetCode-Binary-Tree-Maximum-Path-Sum/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/31/LeetCode-Trapping-Rain-Water/" title="LeetCode-Trapping-Rain-Water" itemprop="url">LeetCode-Trapping-Rain-Water</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2018-01-31T00:10:48.000Z" itemprop="datePublished"> Published Jan 31 2018</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Problem_Description">Problem Description</h2>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><strong> problem link: </strong><br><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="external">https://leetcode.com/problems/trapping-rain-water</a></p>
<p><img src="/img/LeetCode_Trapping_Rain_Water.jpg" alt=""></p>
<h2 id="Solution">Solution</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater_42</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] height) {</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> b = height.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (a &lt;= b) {</div><div class="line">            leftMax = Math.max(leftMax, height[a]);</div><div class="line">            rightMax = Math.max(rightMax, height[b]);</div><div class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) {</div><div class="line">                <span class="comment">// leftMax is smaller than rightMax, so the (leftMax-A[a]) water can be stored</span></div><div class="line">                max += (leftMax - height[a]);</div><div class="line">                a++;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                max += (rightMax - height[b]);</div><div class="line">                b--;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="算法解释">算法解释</h2>
<p>对任意位置 i，在 i 上的积水，由左右两边最高的 bar 决定。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2018/01/31/LeetCode-Trapping-Rain-Water/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/12/Kafka-Consumer-的实现/" title="Kafka Consumer 的实现" itemprop="url">Kafka Consumer 的实现</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-12T07:16:54.000Z" itemprop="datePublished"> Published Nov 12 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong><em>说明: kafka 版本号为 0.11.0</em></strong></p>
<h2 id="Consumer_拉取消息的实现">Consumer 拉取消息的实现</h2>
<p>在 Kafka Consumer 正常消费时，观察其调用堆栈。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pool-16-thread-7"</span> <span class="comment">#154 prio=5 os_prio=0 tid=0x00007ff581c8c000 nid=0x326d runnable [0x00007ff5468e7000]</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">        <span class="keyword">...</span></div><div class="line">        at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:<span class="number">433</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">232</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e04f90</span>&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</div><div class="line">        at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">208</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:<span class="number">1096</span>)</div><div class="line">        at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:<span class="number">1043</span>)</div><div class="line">        at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:<span class="number">571</span>)</div><div class="line">        <span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>对应的代码实现是 <code>org.apache.kafka.clients.consumer.KafkaConsumer#poll</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span>(<span class="keyword">long</span> timeout) {</div><div class="line">        ...</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ...</div><div class="line">            <span class="comment">// poll for new data until the timeout expires</span></div><div class="line">            <span class="keyword">long</span> start = time.milliseconds();</div><div class="line">            <span class="keyword">long</span> remaining = timeout;</div><div class="line">            do {</div><div class="line">                Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollOnce(remaining);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests())</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        </div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConsumerRecords&lt;&gt;(records);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</div><div class="line">                        </div><div class="line">                <span class="keyword">long</span> elapsed = time.milliseconds() - start;</div><div class="line">                remaining = timeout - elapsed;</div><div class="line">            } <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> ConsumerRecords.empty();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            release();</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>其中 <code>org.apache.kafka.clients.consumer.KafkaConsumer#pollOnce</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; <span class="title">pollOnce</span>(<span class="keyword">long</span> timeout) {</div><div class="line">        ...</div><div class="line">        <span class="comment">// ConsumerCoordinator coordinator;</span></div><div class="line">        coordinator.poll(time.milliseconds(), timeout);</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// if data is available already, return it immediately</span></div><div class="line">        Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">        <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">            <span class="keyword">return</span> records;</div><div class="line"></div><div class="line">        <span class="comment">// send any new fetches (won't resend pending fetches)</span></div><div class="line">        fetcher.sendFetches();</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>所以可以看到 consumer 每次 poll 时是先从 fetcher 中 fetchedRecords 的，如果拿不到结果，就新发起一个 sendFetches 请求。</p>
<h3 id="Consumer_拉取消息的数量">Consumer 拉取消息的数量</h3>
<p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#fetchedRecords</code> 可以看到 <code>maxPollRecords</code>(max.poll.records 配置) 变量限制了每次 poll 的消息条数，不管 consumer 对应多少个 partition，从所有 partition 拉取到的消息条数总和不会超过 <code>maxPollRecords</code>。</p>
<p>在 <code>org.apache.kafka.clients.consumer.internals.Fetcher#sendFetches</code> 可以看到 <code>fetchSize</code>(max.partition.fetch.bytes 配置) 用于每次创建 FetchRequest 时的 <code>org.apache.kafka.common.requests.FetchRequest.PartitionData</code> 的参数设置。<code>fetchSize</code>限制了 consumer 每次从每个 partition 拉取的数据量。<br>不过，还是看代码中的 <code>ConsumerConfig#MAX_PARTITION_FETCH_BYTES_DOC</code> 说明吧：</p>
<blockquote>
<p>The maximum amount of data per-partition the server will return. Records are fetched in batches by the consumer. If the first record batch in the first non-empty partition of the fetch is larger than this limit, the batch will still be returned to ensure that the consumer can make progress. The maximum record batch size accepted by the broker is defined via <code>message.max.bytes</code> (broker config) or <code>max.message.bytes</code> (topic config). See “ + FETCH_MAX_BYTES_CONFIG + “ for limiting the consumer request size.</p>
</blockquote>
<h4 id="poll_和_fetch_的关系">poll 和 fetch 的关系</h4>
<p>在满足max.partition.fetch.bytes限制的情况下，假如fetch到了100个record，放到本地缓存后，由于max.poll.records限制每次只能poll出15个record。那么KafkaConsumer就需要执行7次才能将这一次通过网络发起的fetch请求所fetch到的这100个record消费完毕。其中前6次是每次pool中15个record，最后一次是poll出10个record。</p>
<h2 id="Consumer_的心跳机制">Consumer 的心跳机制</h2>
<p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinat</code> 中启动 <code>HeartbeatThread</code> 线程来定时发送心跳和检查 consumer 的状态。<br>每个 Consumer 都有一个 ConsumerCoordinator(继承 AbstractCoordinator)，每个 ConsumerCoordinator 都启动一个 <code>HeartbeatThread</code> 线程来维护心跳，心跳信息存放在 <code>org.apache.kafka.clients.consumer.internals.Heartbeat</code>。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">                log.debug(<span class="string">"Heartbeat thread for group {} started"</span>, groupId);</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) {</div><div class="line">                        ...</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) {</div><div class="line">                            ...</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></div><div class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></div><div class="line">                            coordinatorDead();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></div><div class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></div><div class="line">                            maybeLeaveGroup();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) {</div><div class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></div><div class="line">                            <span class="comment">// coordinator disconnected</span></div><div class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            heartbeat.sentHeartbeat(now);</div><div class="line">                            ...</div><div class="line">                        }</div><div class="line">                  } <span class="comment">// end synchronized</span></div><div class="line">              } <span class="comment">// end while</span></div><div class="line">          } <span class="comment">//end try              </span></div><div class="line">} <span class="comment">// end run</span></div></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="sessionTimeout">sessionTimeout</h3>
<p>如果是 sessionTimeout 则 Mark the current coordinator as dead，此时  会将 consumer 踢掉，重新分配 partition 和 consumer 的对应关系。</p>
<p>在 Kafka Server 端，Consumer 的 Group 定义了五个状态：：<br><img src="/img/kafka_consumer_state_in_server.png" alt="Consumer Group State"></p>
<p>

<h3 id="pollTimeout">pollTimeout</h3>
</p><p>如果是 pollTimeout 则 Reset the generation and memberId because we have fallen out of the group，此时 consumer 会退出 group，当再次 poll 时又会 rejoin group 触发 rebalance group。</p>
<h4 id="Rebalance_Generation">Rebalance Generation</h4>
<p>表示 rebalance 之后的一届成员，主要是用于保护 consumer group，隔离无效 offset 提交。每次 group 进行 rebalance 之后，generation 号都会加 1，表示 group 进入到了一个新的版本，下图所示为 consumer 2 退出后 consumer 4 加入时 Rebalance Generation 的过程：<br><img src="/img/Kafka_Rebalance_Generation.png" alt="Rebalance Generation"></p>
<h2 id="partition_的数量设置">partition 的数量设置</h2>
<ul>
<li><p>一个 partition 只能被 Consumer Group 中的一个 consumer 消费，因此，为了提高并发量，可以提高 partition 的数量，但是这会造成 replica 副本拷贝的网络请求增加，故障恢复时的耗时增加。因为 kafka 使用 batch pull 的方式，所以单个线程的消费速率还是有保障的。并且 partition 数量过多，zk 维护 ISR 列表负载较重。</p>
</li>
<li><p>partiton 数量最好是 consumer 数目的整数倍，比如取 24， consumer 数目的设置就会灵活很多。</p>
</li>
<li><p>consumer 消费消息时不时严格有序的。当从多个 partition 读数据时，kafka 只保证在一个 partition 上数据是有序的，多个 partition 的消息消费很可能就不是严格有序的了。</p>
</li>
</ul>
<h2 id="参数设置">参数设置</h2>
<h3 id="heartbeat-interval-ms">heartbeat.interval.ms</h3>
<p>心跳间隔。心跳是在 consumer 与 coordinator 之间进行的。心跳是确定 consumer 存活，加入或者退出 group 的有效手段。<br>这个值必须设置的小于 session.timeout.ms，因为：<br>当 consumer 由于某种原因不能发 heartbeat 到 coordinator 时，并且时间超过 session.timeout.ms 时，就会认为该 consumer 已退出，它所订阅的 partition 会分配到同一 group 内的其它的 consumer 上。</p>
<h4 id="参数值">参数值</h4>
<p>默认值：3000 (3s)，通常设置的值要低于session.timeout.ms的1/3。</p>
<p></p><p></p>
<h3 id="session-timeout-ms">session.timeout.ms</h3>
<p>consumer session 过期时间。如果超时时间范围内，没有收到消费者的心跳，broker 会把这个消费者置为失效，并触发消费者负载均衡。因为只有在调用 poll 方法时才会发送心跳，更大的 session 超时时间允许消费者在 poll 循环周期内处理消息内容，尽管这会有花费更长时间检测失效的代价。如果想控制消费者处理消息的时间，</p>
<h4 id="参数值-1">参数值</h4>
<p>默认值：10000 (10s)，这个值必须设置在 broker configuration 中的 group.min.session.timeout.ms 与 group.max.session.timeout.ms 之间。</p>
<p>

<h3 id="max-poll-interval-ms">max.poll.interval.ms</h3>
</p><p>This config sets the maximum delay between client calls to poll(). </p>
<p>When the timeout expires, the consumer will stop sending heartbeats and send an explicit LeaveGroup request. </p>
<p>As soon as the consumer resumes processing with another call to poll(), the consumer will <strong>rejoin the group</strong>. </p>
<p>By increasing the interval between expected polls, you can give the consumer more time to handle a batch of records returned frompoll(long). The drawback is that increasing this value may delay a group rebalance since the consumer will only join the rebalance inside the call to poll. You can use this setting to bound the time to finish a rebalance, but you risk slower progress if the consumer cannot actually call poll often enough.</p>
<p>参数设置大一点可以增加两次 poll 之间处理消息的时间。<br>当 consumer 一切正常(也就是保持着 heartbeat )，且参数的值小于消息处理的时长，会导致 consumer leave group 然后又 rejoin group，触发无谓的 group balance，出现 consumer livelock 现象。</p>
<p>但如果设置的太大，会延迟 group rebalance，因为消费者只会在调用 poll 时加入rebalance。</p>
<p>

<h3 id="max-poll-records">max.poll.records</h3>
</p><p>Use this setting to limit the total records returned from a single call to poll. This can make it easier to predict the maximum that must be handled within each poll interval. By tuning this value, you may be able to reduce the poll interval, which will reduce the impact of group rebalancing.</p>
<p>0.11.0 Kafka 的默认配置是 </p>
<ul>
<li>max.poll.interval.ms=5min</li>
<li>max.poll.records=500</li>
</ul>
<p>即平均 600ms 要处理完一条消息，如果消息的消费时间高于 600ms，则一定要调整 max.poll.records 或 max.poll.interval.ms。</p>
<h2 id="Kafka_Javadoc_-_Detecting_Consumer_Failures">Kafka Javadoc - Detecting Consumer Failures</h2>
<p>After subscribing to a set of topics, the consumer will automatically join the group when poll(long) is invoked. The poll API is designed to ensure consumer liveness. As long as you continue to call poll, the consumer will stay in the group and continue to receive messages from the partitions it was assigned. Underneath the covers, the consumer sends periodic heartbeats to the server. If the consumer crashes or is unable to send heartbeats for a duration of session.timeout.ms, then the consumer will be considered dead and its partitions will be reassigned.<br>It is also possible that the consumer could encounter a “livelock” situation where it is continuing to send heartbeats, but no progress is being made. To prevent the consumer from holding onto its partitions indefinitely in this case, we provide a liveness detection mechanism using the max.poll.interval.ms setting. Basically if you don’t call poll at least as frequently as the configured max interval, then the client will proactively leave the group so that another consumer can take over its partitions. When this happens, you may see an offset commit failure (as indicated by a CommitFailedException thrown from a call to commitSync()). This is a safety mechanism which guarantees that only active members of the group are able to commit offsets. So to stay in the group, you must continue to call poll. </p>
<h2 id="Reference">Reference</h2>
<p><a href="http://www.cnblogs.com/huxi2b/p/6223228.html" target="_blank" rel="external">Kafka消费组(consumer group)</a><br><a href="https://kafka.apache.org/0101/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="external">kafka.apache.org javadoc</a><br><a href="http://blog.leanote.com/post/zfb050/Coordinator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="external">Coordinator实现原理</a><br><a href="http://debugo.com/kafka-params/" target="_blank" rel="external">kafka params</a><br><a href="http://blog.csdn.net/u014393917/article/details/52043185" target="_blank" rel="external">kafka源码分析之kafka的consumer的负载均衡管理</a><br><a href="http://www.cnblogs.com/devos/p/5656232.html" target="_blank" rel="external">Group Management Protocol</a><br><a href="http://matt33.com/2017/01/16/kafka-group/" target="_blank" rel="external">Kafka 之 Group 状态变化分析及 Rebalance 过程</a><br><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-62%3A+Allow+consumer+to+send+heartbeats+from+a+background+thread" target="_blank" rel="external">KIP-62: Allow consumer to send heartbeats from a background thread</a><br><a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch04.html" target="_blank" rel="external">Kafka: The Definitive Guide Chapter 4 - Kafka Consumers</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/12/Kafka-Consumer-的实现/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/" title="解决 Kafka Consumer 卡顿的问题" itemprop="url">解决 Kafka Consumer 卡顿的问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-12T07:15:18.000Z" itemprop="datePublished"> Published Nov 12 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="运行环境说明">运行环境说明</h2>
<p><strong><em>kafka 版本号为 0.11.0</em></strong></p>
<p>Kafka Consumer 的参数配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getDefaultConsumerConfigs</span>() {</div><div class="line">        Map&lt;String, Object&gt; propsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 手动设置自动提交为false,交由 spring-kafka 启动的invoker执行提交</span></div><div class="line">        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        propsMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="string">"30000"</span>);</div><div class="line">        propsMap.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="string">"10000"</span>);</div><div class="line">        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line"></div><div class="line">        <span class="comment">// 从partition中获取消息最大大小</span></div><div class="line">        propsMap.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, <span class="string">"102400"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> propsMap;</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="Consumer_卡顿现象">Consumer 卡顿现象</h2>
<h3 id="Consumer_卡顿时的日志">Consumer 卡顿时的日志</h3>
<p>每次卡顿不消费时都出现以下日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset <span class="number">11429299</span> <span class="keyword">for</span> partition my_topic-<span class="number">27</span> returned fetch data (error=NONE, highWaterMark=<span class="number">11429299</span>, lastStableOffset = -<span class="number">1</span>, logStartOffset = <span class="number">10299493</span>, abortedTransactions = <span class="keyword">null</span>, recordsSizeInBytes=<span class="number">0</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Added READ_UNCOMMITTED fetch request <span class="keyword">for</span> partition my_topic-<span class="number">27</span> at offset <span class="number">11429299</span> to node p-kafka-host-<span class="number">03</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">6</span> rack: <span class="keyword">null</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">10</span> org.apache.kafka.clients.consumer.internals.Fetcher - Sending READ_UNCOMMITTED fetch <span class="keyword">for</span> partitions [my_topic-<span class="number">27</span>] to broker p-kafka-host-<span class="number">03</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">6</span> rack: <span class="keyword">null</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG kafka-coordinator-heartbeat-thread | myConsumerGroup org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending Heartbeat request <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup to coordinator p-kafka-host-<span class="number">02</span>:<span class="number">9092</span> (id: <span class="number">2147483642</span> rack: <span class="keyword">null</span>)</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup since it is rebalancing.</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-<span class="number">18</span>] <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">18</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">18</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup since it is rebalancing.</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-<span class="number">21</span>] <span class="keyword">for</span> <span class="keyword">group</span> myConsumerGroup</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">21</span>]</div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">4</span> org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-<span class="number">21</span>]</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">4</span> org.apache.kafka.clients.consumer.internals.Fetcher - Fetch READ_UNCOMMITTED at offset <span class="number">11426689</span> <span class="keyword">for</span> partition my_topic-<span class="number">21</span> returned fetch data (error=NONE, highWaterMark=<span class="number">11426689</span>, lastStableOffset = -<span class="number">1</span>, logStartOffset = <span class="number">10552294</span>, abortedTransactions = <span class="keyword">null</span>, recordsSizeInBytes=<span class="number">0</span>)</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - <span class="keyword">Group</span> myConsumerGroup committed offset <span class="number">11429849</span> <span class="keyword">for</span> partition my_topic-<span class="number">18</span></div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:INFO pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining <span class="keyword">group</span> myConsumerGroup</div><div class="line"> <span class="number">2017</span><span class="regexp">/11/</span><span class="number">09</span> <span class="number">19</span>:<span class="number">35</span>:<span class="number">29</span>:DEBUG pool-<span class="number">16</span>-thread-<span class="number">13</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Sending JoinGroup ((type: JoinGroupRequest, groupId=myConsumerGroup, sessionTimeout=<span class="number">30000</span>, rebalanceTimeout=<span class="number">300000</span>, memberId=p-my-consumer-host-<span class="number">03</span>-<span class="number">12</span>-<span class="number">97</span>c12fb0-<span class="number">9</span>bb7-<span class="number">4762</span>-<span class="number">8478</span>-<span class="number">538</span>f06be9e90, protocolType=consumer, groupProtocols=org.apache.kafka.common.requests.JoinGroupRequest$ProtocolMetadata@<span class="number">54371</span>fac)) to coordinator p-kafka-<span class="number">02</span>.ali.keep:<span class="number">9092</span> (id: <span class="number">2147483642</span> rack: <span class="keyword">null</span>)</div></pre></td></tr></table></figure>

<p>其中最重要的部分是：</p>
<blockquote>
<p><strong>2017/11/09 19:35:29:DEBUG pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - Attempt to heartbeat failed for group myConsumerGroup since it is rebalancing.<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator - Revoking previously assigned partitions [my_topic-18] for group myConsumerGroup<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.springframework.kafka.listener.ConcurrentMessageListenerContainer - partitions revoked: [my_topic-18]<br>…<br>2017/11/09 19:35:29:INFO pool-16-thread-13 org.apache.kafka.clients.consumer.internals.AbstractCoordinator - (Re-)joining group myConsumerGroup</strong></p>
</blockquote>
<p>那为什么每次会这样呢？我们是有单独的线程在发起心跳的！!!</p>
<h3 id="Consumer_卡顿时的_jstack">Consumer 卡顿时的 jstack</h3>
<p>观察日志可以发现，卡顿时 ConsumerCoordinator 在不停地 rejoin group，并且做 rebalance，所以需要对比在正常和卡顿这两种情况下 ConsumerCoordinator 的行为。</p>
<h4 id="正常时的_ConsumerCoordinator">正常时的 ConsumerCoordinator</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> jstack.<span class="keyword">normal</span>.<span class="built_in">log</span> | <span class="keyword">grep</span> ConsumerCoordinator -B1 | <span class="keyword">grep</span> -<span class="keyword">v</span> ConsumerCoordinator | <span class="built_in">sort</span> | uniq -<span class="keyword">c</span></div><div class="line"><span class="number">32</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:931</span>)</div><div class="line"><span class="number">22</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:950</span>)</div></pre></td></tr></table></figure>

<h4 id="卡顿时的_ConsumerCoordinator">卡顿时的 ConsumerCoordinator</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> jstack.pause.<span class="built_in">log</span> | <span class="keyword">grep</span> ConsumerCoordinator -B1 | <span class="keyword">grep</span> -<span class="keyword">v</span> ConsumerCoordinator | <span class="built_in">sort</span> | uniq -<span class="keyword">c</span></div><div class="line"><span class="number">14</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.jav<span class="variable">a:316</span>)</div><div class="line"><span class="number">14</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:920</span>)</div><div class="line"><span class="number">8</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:931</span>)</div><div class="line"><span class="number">32</span> 	at org.apache.kafka.clients.consumer.internals.AbstractCoordinator$HeartbeatThread.run(AbstractCoordinator.jav<span class="variable">a:950</span>)</div></pre></td></tr></table></figure>

<p>根据以上的现场信息，可以发现关键就在 <code>AbstractCoordinator.ensureActiveGroup</code> 这一步，继续观察 jstack.pause.log 中的相关堆栈信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pool-16-thread-14"</span> #<span class="number">167</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f5b19dbf000</span> nid=<span class="number">0x7ac2</span> runnable [<span class="number">0x00007f5ae4ccb000</span>]</div><div class="line"><span class="label">   java.lang.Thread.State:</span> RUNNABLE</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollArrayWrapper.epollWait(Native Method)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollArrayWrapper.poll(EPollArrayWrapper.java:<span class="number">269</span>)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:<span class="number">79</span>)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.SelectorImpl.lockAndDoSelect(SelectorImpl.java:<span class="number">86</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e816b0</span>&gt; (a sun.nio.<span class="number">ch</span>.Util<span class="number">$2</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e816a0</span>&gt; (a java.util.Collections$UnmodifiableSet)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2e742a0</span>&gt; (a sun.nio.<span class="number">ch</span>.EPollSelectorImpl)</div><div class="line">        <span class="preprocessor">at</span> sun.nio.<span class="number">ch</span>.SelectorImpl.select(SelectorImpl.java:<span class="number">97</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.common.network.Selector.select(Selector.java:<span class="number">529</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.common.network.Selector.poll(Selector.java:<span class="number">321</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:<span class="number">433</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">232</span>)</div><div class="line">        - locked &lt;<span class="number">0x00000000c2f00da0</span>&gt; (a org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">208</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:<span class="number">168</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator.joinGroupIfNeeded(AbstractCoordinator.java:<span class="number">364</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:<span class="number">316</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:<span class="number">297</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:<span class="number">1078</span>)</div><div class="line">        <span class="preprocessor">at</span> org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:<span class="number">1043</span>)</div><div class="line">        <span class="preprocessor">at</span> org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:<span class="number">571</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</div><div class="line">        <span class="preprocessor">at</span> java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</div><div class="line">        <span class="preprocessor">at</span> java.lang.Thread.run(Thread.java:<span class="number">745</span>)</div></pre></td></tr></table></figure>

<h2 id="卡顿原因分析">卡顿原因分析</h2>
<h3 id="卡顿原因：Consumer_在_Region_Group">卡顿原因：Consumer 在 Region Group</h3>
<p>根据以上信息，结合 <code>org.apache.kafka.clients.consumer.internals.ConsumerCoordinator</code> 的代码可以发现在<br><code>ConsumerCoordinator#poll</code> 中判断 <code>needRejoin()</code> 为 true 时会调用 <code>ensureActiveGroup()</code> 函数，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span>(<span class="keyword">long</span> now, <span class="keyword">long</span> remainingMs) {</div><div class="line">        invokeCompletedOffsetCommitCallbacks();</div><div class="line">        <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) {</div><div class="line">            ...</div><div class="line">            <span class="keyword">if</span> (needRejoin()) {</div><div class="line">                ...</div><div class="line">                ensureActiveGroup();</div><div class="line">                ...</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">             ...</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        pollHeartbeat(now);</div><div class="line">        maybeAutoCommitOffsetsAsync(now);</div><div class="line">    }</div></pre></td></tr></table></figure>

<h3 id="Region_Group_原因：Consumer_Leave_Group">Region Group 原因：Consumer Leave Group</h3>
<p>那么问题就是什么情况下 org.apache.kafka.clients.consumer.internals.ConsumerCoordinator#needRejoin 会返回 true，我们还是看看他的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span>() {</div><div class="line">        <span class="keyword">if</span> (!subscriptions.partitionsAutoAssigned())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we need to rejoin if we performed the assignment and metadata has changed</span></div><div class="line">        <span class="keyword">if</span> (assignmentSnapshot != <span class="keyword">null</span> && !assignmentSnapshot.equals(metadataSnapshot))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we need to join if our subscription has changed since the last join</span></div><div class="line">        <span class="keyword">if</span> (joinedSubscription != <span class="keyword">null</span> && !joinedSubscription.equals(subscriptions.subscription()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.needRejoin();</div><div class="line">    }</div></pre></td></tr></table></figure>

<h1 id="kafka_metadata_什么时候变化？？？？">kafka metadata 什么时候变化？？？？</h1>
<p>可以看到，不是 metadataSnapshot 有变化，也不是 订阅者 subscriptions 有变化，那就是 super.needRejoin() 返回了 true，问题就转到了 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator#needRejoin</code> 这个函数，其实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">needRejoin</span>() {</div><div class="line">    <span class="keyword">return</span> rejoinNeeded;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从代码上看 <code>rejoinNeeded</code> 的整个变化过程，初始化为 true，在 <code>initiateJoinGroup</code> 成功后，会赋值为 false，在 <code>maybeLeaveGroup</code> 时会赋值为 true，所以怀疑卡顿时是 consumer leave group 了。</p>
<h2 id="Consumer_Leave_Group_原因：pollTimeoutExpired">Consumer Leave Group 原因：pollTimeoutExpired</h2>
<p>在 <code>org.apache.kafka.clients.consumer.internals.AbstractCoordinator.HeartbeatThread#run</code> 中调用了 <code>maybeLeaveGroup()</code> 函数，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">                log.debug(<span class="string">"Heartbeat thread for group {} started"</span>, groupId);</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</div><div class="line">                    <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) {</div><div class="line">                        ...</div><div class="line">                        client.pollNoWakeup();</div><div class="line">                        <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (coordinatorUnknown()) {</div><div class="line">                            ...</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.sessionTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the session timeout has expired without seeing a successful heartbeat, so we should</span></div><div class="line">                            <span class="comment">// probably make sure the coordinator is still healthy.</span></div><div class="line">                            coordinatorDead();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (heartbeat.pollTimeoutExpired(now)) {</div><div class="line">                            <span class="comment">// the poll timeout has expired, which means that the foreground thread has stalled</span></div><div class="line">                            <span class="comment">// in between calls to poll(), so we explicitly leave the group.</span></div><div class="line">                            maybeLeaveGroup();</div><div class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (!heartbeat.shouldHeartbeat(now)) {</div><div class="line">                            <span class="comment">// poll again after waiting for the retry backoff in case the heartbeat failed or the</span></div><div class="line">                            <span class="comment">// coordinator disconnected</span></div><div class="line">                            AbstractCoordinator.<span class="keyword">this</span>.wait(retryBackoffMs);</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            heartbeat.sentHeartbeat(now);</div><div class="line">                            ...</div><div class="line">                        }</div><div class="line">                  } <span class="comment">// end synchronized</span></div><div class="line">              } <span class="comment">// end while</span></div><div class="line">          } <span class="comment">//end try              </span></div><div class="line">} <span class="comment">// end run</span></div></pre></td></tr></table></figure>

<p>其中最重要的两个 timeout 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sessionTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - Math.max(lastSessionReset, lastHeartbeatReceive) &gt; sessionTimeout;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pollTimeoutExpired</span>(<span class="keyword">long</span> now) {</div><div class="line">    <span class="keyword">return</span> now - lastPoll &gt; maxPollInterval;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以是 pollTimeoutExpired 引起了 leave group.</p>
<h3 id="根本原因：pollTimeoutExpired">根本原因：pollTimeoutExpired</h3>
<p>pollTimeoutExpired 的原因是两次 poll 的时间间隔超过了设置的 maxPollInterval 值。</p>
<h2 id="解决方案">解决方案</h2>
<p>调整以下参数</p>
<ul>
<li>max.poll.records：100 (默认值 500)</li>
<li>max.poll.interval.ms：600000 (默认值 300000，也就是5分钟)</li>
</ul>
<h2 id="后续">后续</h2>
<p>至此，问题已经解决了，但是有一些疑问。</p>
<ul>
<li>对于这两个参数值的设定， 是 <code>max.poll.records</code> 越小越好，<code>max.poll.interval.ms</code> 越大越好吗？</li>
<li>已经设置过的 <code>session.timeout.ms</code> 和 <code>heartbeat.interval.ms</code>难道没用吗？为什么有这么多超时参数的设置啊？</li>
<li>已经设置过的 <code>max.partition.fetch.bytes</code> 没用吗？为什么还要设置 <code>max.poll.records</code> 啊？</li>
<li>整体上还需要调哪些参数才可以让 consumer 运行正常，或者是性能达到最大呢？</li>
</ul>
<p>在下一篇博客「Kafka Consumer 的实现」中，将会继续分析 Kafka Consumer 的消费过程和参数配置，试图回答以上问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/12/解决-Kafka-Consumer-卡顿的问题/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/" title="Stanford Machine Learning - 5 广义线性模型" itemprop="url">Stanford Machine Learning - 5 广义线性模型</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T15:20:39.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_指数分布族(Exponential_Family)">1. 指数分布族(Exponential Family)</h2>
<h4 id="指数分布族的定义">指数分布族的定义</h4>
<p>若一类概率分布可以写成如下形式，那么它就属于指数分布族：<br>$$P(y;\eta) = b(y)exp(\eta^TT(y)-a(\eta))$$</p>
<ul>
<li>$\eta$: 自然参数，通常是一个实数</li>
<li>T(y): 充分统计量，通常，T(y)=y，实际上是一个概率分布的充分统计量（统计学知识）</li>
<li>a($\eta$) 被称为 log partition function</li>
</ul>
<p>对于给定的 a，b，T 三个函数，上式定义了一个以 $\eta$ 为参数的概率分布集合，即改变 $\eta$ 可以得到不同的概率分布，例如高斯分布和伯努利分布。</p>
<h4 id="指数分布族以及它们的特征">指数分布族以及它们的特征</h4>
<ul>
<li>正态分布（高斯分布）——总体噪音（由中心极限定理得）</li>
<li>伯努利分布——逻辑回归（对01问题建模）</li>
<li>多项式分布——K种结果的事情进行建模</li>
<li>泊松分布——对计数过程进行建模（一个样本中放射性衰变的数目，网站的访客数目，商店的顾客数目）</li>
<li>伽马分布，指数分布——正数的分布，对间隔进行建模（在公交车站等车的时间）</li>
<li>β分布，Dirichlet分布——对小数进行分布，对概率分布进行建模</li>
<li>Wishart分布——协方差的分布</li>
</ul>
<h2 id="2-_指数分布簇推导">2. 指数分布簇推导</h2>
<p>高斯分布(Gaussian)和伯努利(Bernoulli)分布都可以推导为指数分布族。</p>
<h3 id="2-1_伯努利分布的推导">2.1 伯努利分布的推导</h3>
<p>伯努利分布的概率公式为：$P(y=1;\phi)=\phi; P(y=0;\phi)=1-\phi;$</p>
<p>公式可经如下变换：<br>$$P(y;\phi)=\phi^y(1-\phi)^y$$<br>$$=exp(log(\phi^y(1-\phi)^y))=exp(ylog(\phi)+ (1-y)log(1-\phi))$$<br>$$=exp(log(\frac\phi{1-\phi})y + log(1-\phi))$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = 1$<br>$\eta = log(\frac\phi{1-\phi}) =&gt; \phi=\frac1{1+e^{-n}}$<br>$a(\eta) = -log(1-\phi) = log(1+e^n)$</p>
<h3 id="2-2_高斯分布的推导">2.2 高斯分布的推导</h3>
<p>在线性回归中，$\sigma$ 对于模型参数 $\theta$  的选择没有影响，为了推导方便我们令 $\sigma = 1$。<br>则有：<br>$$P(y;\mu)=\frac{1}{\sqrt{2\pi}}exp(-\frac12(y-\mu)^2)$$<br>$$=\frac{1}{\sqrt{2\pi}}exp(-\frac{1}{2}y^2) * exp({\mu}y-\frac{1}{2}\mu^2)$$</p>
<p>对应的指数分布族的参数为：<br>$T(y) = y$<br>$b(y) = \frac{1}{\sqrt{2\pi}}exp(-\frac12y^2)$<br>$\eta = \mu$<br>$a(\eta) = \frac{{\mu}^2}2 = \frac{{\eta}^2}2$</p>
<h2 id="3-_广义线性模型(Generalized_Linear_Model)">3. 广义线性模型(Generalized Linear Model)</h2>
<p>想用 广义线性模型对一般问题进行建模首先需要明确几个 假设：</p>
<ol>
<li>$y | x;θ \sim ExponentialFamily(\eta)$ y的条件概率属于指数分布族;</li>
<li>给定 x 广义线性模型的目标是求解 T(y) | x， 不过由于 很多情况下 T(y) = y  所以我们的目标变成了 y | x , 也即 我们希望拟合函数为 h(x) = E[y|x] (这个条件在线性回归和逻辑回归中都满足， 例如在逻辑回归中 $hθ(x) = p(y = 1|x;\theta) = 0 \cdot p(y = 0|x; \theta) + 1 \cdot  p(y = 1|x; \theta) = E[y|x;\theta])$</li>
<li>自然参数 $\eta$ 与 x 是线性关系：$\eta=\theta^Tx$ ($\eta 为向量时 \eta_{i} = \theta_{i}^Tx$)</li>
</ol>
<p>有了如上假设，就可以进行建模和求解了。</p>
<p>对于伯努利分布，可以推导出：<br>…<br>这也就是逻辑回归中 sigmod 函数的由来。</p>
<h2 id="4-_多分类算法(Softmax_Regression)">4. 多分类算法(Softmax Regression)</h2>
<p>y有多个可能的分类：{1, 2, …, k}</p>
<p>=======具体的公式略=======</p>
<p>最后求借寻找最佳参数时，跟最小二乘和逻辑回归的解法类似，可以用梯度下降法或者牛顿迭代法。</p>
<h2 id="Referecen">Referecen</h2>
<p><a href="https://zhuanlan.zhihu.com/p/22876460" target="_blank" rel="external">广义线性模型(Generalized Linear Model)</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-5-广义线性模型/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/" title="Stanford Machine Learning - 4 逻辑回归" itemprop="url">Stanford Machine Learning - 4 逻辑回归</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T15:06:43.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_逻辑回归">1. 逻辑回归</h2>
<p>对于逻辑回归而言，y 的取值不是 0 就是 1，所以 $h<em>θ(x)$ 可以写为<br>$$h</em>θ(x) = g(θ^{T}x)=\frac1{1+e^{-θ^{T}x}}$$</p>
<p>其中<br>$$g(z)=\frac1{1+e^{-z}}$$；</p>
<p>g(z) 被称为 logistic function 或 sigmoid function，其二维坐标下的曲线为:<br><img src="/img/sigmoid_function.png" alt="sigmoid function"></p>
<p>我们先取 g(z) 为 sigmoid function，如果有其他使得 y 值从 0 到 1 平滑递增的函数也可以使用。但由于一些列原因(在后续的一般化回归模型 GLM 中会谈到为什么选用这个函数)，g(z) is a fairly natural one.</p>
<p>g(z) 的导数我们可以先进行推导:<br>$$g’(z)=\frac{d}{dz}\frac{1}{1+e^{-z}}= \frac{1}{(1+e^{-z})^2}(e^{-z})$$<br>$$= \frac{1}{1+e^{-z}}*(1 - \frac{1}{1+e^{-z}})= g(z)(1-g(z))$$</p>
<h2 id="2-_梯度上升法求解逻辑回归">2. 梯度上升法求解逻辑回归</h2>
<p>对于给定的逻辑回归函数，我们使用最小二乘法来推导出最大似然估计，假设:<br>$P(y=1|x;θ)=h_θ(x)$，代表对于给定的 θ，y 取值为 1 的概率。<br>$P(y=0|x;θ)=1-h_θ(x)$，代表对于给定的 θ，y 取值为 0 的概率。</p>
<p>以上两者可以合并为：<br>$$P(y|x;θ)=(h_θ(x))^y(1 − h_θ(x))^{(1−y)}$$</p>
<p>假设 m 个训练集是相互独立的，则似然估计为：<br>$$L(θ)=P(\overrightarrow{y}|X;θ)$$<br>$$= \prod^m_{i=1}P(y^i|x^i;θ)$$<br>$$= \prod^m_{i=1}{(h_θ(x^{(i)}))^{y^{(i)}}(1 − h_θ(x^{(i)}))^{(1−y^{(i)})}}$$</p>
<p>和之前一样，上式可以简化为：</p>
<p></p><p><br>$l(θ) = logL(θ)<br>= \sum_{m}^{i=1}{y^{(i)}}log{h(x^{(i)}) + {(1−y^{(i)})}log(1 − h(x^{(i)}))}$</p>
<p>那么，<br>如何去最大化似然函数呢，可以应用梯度上升法，因为我们要使 P 的取值足够大，也是就预测准确的概率最够大。</p>
<p>随机梯度上升的公式为：<br>$$θ:= θ + \alpha\Deltaθl(θ)$$</p>
<p>下面来求$\Deltaθl(θ)$的取值：</p>
<p>$$\frac\partial{\partial\theta_j}l(\theta)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)})\frac\partial{\partial\theta_j}g(\theta^Tx)$$<br>$$= (y\frac1{g(\theta^Tx)} - (1-y)\frac1{1-g(\theta^Tx)}) g(\theta^Tx)(1-g(\theta^Tx))\frac\partial{\partial\theta_j}\theta^Tx$$<br>$$= ({y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)})x_j$$<br>$$= (y - h_{\theta}(x))x_j$$</p>
<p>附上手写的推导过程：<br><img src="/img/logistic_regression_delta_ljp_derived.png" alt="手写推导过程"></p>
<p>所以，最终随机梯度上升的公式为：<br>$$θ_j:=θ_j + \alpha\sum_{i=1}^{m}(y^{(i)} - h_{\theta}(x^{(i))})x_j^{(i)}$$</p>
<p>如何和线性回归的公式放在一起比较，</p>
<p>$$θ_j = θ_j - α \frac1m <em> \sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}</em>x_j^{(i)}$$</p>
<p>会发现，这两者非常相似，实际上却不然，因为这里的 $(h_θ(x^{(i)})$ 定义的不是线性函数。后续我们谈到 GLM 时会发现这并不是巧合，而是有更深层次的原因。</p>
<h2 id="3-_牛顿迭代法求解逻辑回归">3. 牛顿迭代法求解逻辑回归</h2>
<p>牛顿迭代法可以利用到曲线本身的信息，比梯度下降法更容易收敛，即迭代更少次数。</p>
<h3 id="3-1_牛顿迭代法简述">3.1 牛顿迭代法简述</h3>
<p>假设我们要求解方程 f(x)=0 的根，首先随便找一个初始值 x0，如果 x0 不是解，做一个经过 (x0,f(x0))  这个点的切线，与 x 轴的交点为 x1。同样的道理，如果 x1 不是解，做一个经过 (x1,f(x1)) 这个点的切线，与 x 轴的交点为 x2。 以此类推。以这样的方式得到的 xi 会无限趋近于 f(x)=0 的解。</p>
<p>对于任意一点 $(x_n,y_n)$ 做切线，切线的斜率为 $f’(x_n)$，则有方程：<br>$$ y-f(x_n) = f’(x_n)(x-x_n) $$</p>
<h3 id="3-2_迭代过程">3.2 迭代过程</h3>
<p>求解 $f(\theta)$ = 0 时 $\theta$ 的取值。<br>设下一次迭代时 $\theta^{(t+1)}$ 的取值与前一次迭代 $\theta^{(t)}$ 的取值(在 x 轴)距离为 $\Delta$。</p>
<p>则 $\theta^{(t+1)} = \theta^{(t)} - \Delta$，且 $\Delta = \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$，<br>所以有：<br>$$\theta^{(t+1)} = \theta^{(t)} - \frac{f(\theta^{(t)})}{f’(\theta^{(t)})}$$</p>
<h4 id="从泰勒展开到牛顿迭代">从泰勒展开到牛顿迭代</h4>
<p>也可以由泰勒展开中推导牛顿迭代的公式。这次为了求解方程 f′=0 的根，把原函数 f(x) 的做泰勒展开，展开到二阶形式：<br>$$ f(x+\Delta x) = f(x)+f’(x)\Delta x+ \frac1{2}f’’(x)\Delta x^2 $$</p>
<p>当且仅当 $\Delta x$ 逼近 0 时，上式成立，此时忽略 1/2 系数的作用，所以有：<br>$$ f’(x)+ \frac1{2}f’’(x)\Delta x = 0 $$<br>故：<br>$$\Delta x = -\frac{f’(x)}{f’’(x)} $$</p>
<p><strong>对函数求极大值的方法</strong><br>&gt;</p>
<blockquote>
<ol>
<li>将原函数y=f(x)，对x求一次导数，得到dy/dx；</li>
<li>令dy/dx = 0，解得一次导函数的零点；</li>
<li>将原函数对x求二次导函数；</li>
<li>将解得的零点坐标的x值代入二次导函数，<br>如果是正值，零点所在位置，就是极小值点，再将该x值代入原函数，得到极小值；<br>如果是值值，零点所在位置，就是极大值点，再将该x值代入原函数，得到极大值；<br>如果是0，零点所在位置，既不是极小值点，也不是极大值点，是拐点。</li>
</ol>
</blockquote>
<p>所以求 $l(\theta)$ 在极大值处 $\theta$ 的取值，则是求 $l’(\theta) = 0$ 时 $\theta$ 的值，应用牛顿迭代法则有：</p>
<p>$$\theta^{(t+1)} = \theta^{(t)} - \frac{l’(\theta^{(t)})}{l’’(\theta^{(t)})}$$</p>
<h3 id="3-3_多维向量的牛顿迭代">3.3 多维向量的牛顿迭代</h3>
<p>对于多维向量 $\overrightarrow{X}$ 求解。<br>$$\theta := \theta - H^{-1} \nabla l(\theta)$$<br>其中<br>$\nabla l(\theta)$ 是对 $l(\theta)$ 求导的值。</p>
<p>H 是一个 n*n 的矩阵，n 是特征数量，元素的计算公式为：<br>$$H_ij= \frac{\partial^2{l({\theta)}}}{\partial{\theta_i}\partial{\theta_j}}$$</p>
<h3 id="3-4_牛顿迭代法的特点">3.4 牛顿迭代法的特点</h3>
<h4 id="是否收敛">是否收敛</h4>
<p>通常情况下是收敛的，但是需要满足一些条件，对于逻辑回归来讲，是收敛的。</p>
<h4 id="迭代速度">迭代速度</h4>
<p>每次迭代后，有解数字的误差是成平方倍减小的，是二次收敛函数。</p>
<h4 id="优缺点">优缺点</h4>
<p>优点：收敛快<br>缺点：特征多(上千个)时，每次迭代成本大</p>
<h2 id="Reference">Reference</h2>
<p><a href="http://blog.csdn.net/baimafujinji/article/details/51179381" target="_blank" rel="external">http://blog.csdn.net/baimafujinji/article/details/51179381</a><br><a href="http://blog.csdn.net/baimafujinji/article/details/51167852" target="_blank" rel="external">http://blog.csdn.net/baimafujinji/article/details/51167852</a><br><a href="https://www.jiqizhixin.com/articles/2017-08-09-3" target="_blank" rel="external">如何通过牛顿方法解决Logistic回归问题</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-4-逻辑回归/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/" title="Stanford Machine Learning - 3 线性回归的概率解释" itemprop="url">Stanford Machine Learning - 3 线性回归的概率解释</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T14:04:40.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_欠拟合与过拟合">1. 欠拟合与过拟合</h2>
<p>欠拟合：underfitting，与训练数据贴合的不够好，不能准确预测未来目标值。<br>过拟合：overfitting，与训练数据贴合的太好了，预测未来目标值的准确性有较大风险。</p>
<p><img src="/img/LR_underfitting_and_overfitting.png" alt=""></p>
<h2 id="2-_线性模型的概率解释">2. 线性模型的概率解释</h2>
<p>思考：我们为什么要用最小二乘的指标作为 cost function？为什么不是绝对值或四次方？</p>
<blockquote>
<p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。<br>最小二乘是从函数形式上来看的，极大似然是从概率意义上来看的。事实上，最小二乘可以由高斯噪声假设+极大似然估计推导出来。当然极大似然估计还可以推导出其他的loss function， 比如logistic回归中，loss function是交叉熵。<br><a href="http://www.cnblogs.com/little-YTMM/p/5700226.html" target="_blank" rel="external">最大似然估计与最小二乘估计的区别</a></p>
</blockquote>
<p>一般的最小二乘法实际上是在假设误差项满足高斯分布且独立同分布的情况下，使似然性最大化。</p>
<h3 id="推导过程">推导过程</h3>
<p>回到预测房价的例子，假设最终的预测函数，每一次预测都有误差，用$ε^{(i)}$表示误差，则预测函数可以写为：<br>$$y^{(i)}=\theta^Tx^{(i)} + ε^{(i)} $$</p>
<p>其中，误差是随机分布的，均值为 0，服从高斯分布 $N(0,σ^2)$。</p>
<blockquote>
<p>Andrew Ng 讲到在大多数情况下，线性回归的误差值如果综合来看，就是符合高斯分布的。并且根据中心极限定律，正态分布确实是对误差项分布的合理猜想。</p>
</blockquote>
<p>所以<br>$$P(y^{(i)}|x^{(i)}; θ) = \frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})$$</p>
<p>$P(y^{(i)}|x^{(i)}; θ)$ 表示：在 θ 为给定的参数的情况下，概率 $y^{(i)}$ 以 $x^{(i)}$ 为随机变量的概率分布，注意 θ 不是随机变量。</p>
<p>由于 ε(i) 是独立的同分布（IID：independentlyidentically distribution），所以以 θ 为变量的似然函数为：<br>$$<br>L(θ)=L(θ;X,Y)=p(Y|X;θ) = \prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$</p>
<p>对 L(θ) 取对数有：<br>$$<br>l(\theta)=logL(\theta)<br>= log\prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})<br>$$<br>$$<br>= m\sum_{i=1}^{m}log\frac{1}{\sqrt{2\pi}\sigma} - \frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2<br>$$</p>
<p>最大化 $l(\theta)$ 即是最小化 $\frac1{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2$，这样就是 cost function.</p>
<p>由于目标变量服从正态分布，但分布的均值和方差都未知，对均值和方差两个参数的合理估计是选取两个参数使得在正态分布的前提下，抽到各样本中的 y 值的概率最大，这就是最大似然估计的思想。</p>
<h1 id="Reference">Reference</h1>
<p><a href="http://www.holehouse.org/mlclass/07_Regularization.html" target="_blank" rel="external">http://www.holehouse.org/mlclass/07_Regularization.html</a><br><a href="http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html" target="_blank" rel="external">http://rstudio-pubs-static.s3.amazonaws.com/4810_06e3d8fd26ed40eb8c31aff35eae81ae.html</a><br><a href="https://rpubs.com/badbye/ml03" target="_blank" rel="external">https://rpubs.com/badbye/ml03</a><br><a href="http://www.qiujiawei.com/linear-algebra-15/" target="_blank" rel="external">http://www.qiujiawei.com/linear-algebra-15/</a><br><a href="http://www.jianshu.com/p/f1d3906e4a3e" target="_blank" rel="external">最大似然估计</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-3-线性回归的概率解释/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/05/Stanford-Machine-Learning-Week-2-Linear-Regression-with-multiple-features/" title="Stanford Machine Learning - 2 线性回归进阶" itemprop="url">Stanford Machine Learning - 2 线性回归进阶</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://luojinping.com/about" title="Jinping Luo" target="_blank" itemprop="author">Jinping Luo</a>
		
  <p class="article-time">
    <time datetime="2017-11-05T14:00:04.000Z" itemprop="datePublished"> Published Nov 5 2017</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-_多变量的线性回归">1. 多变量的线性回归</h2>
<p>n: 特征(features) 数量<br>m: 训练集数量<br>$x^{(i)}$: </p>
<ul>
<li>表示一条训练数据的向量</li>
<li>i is an index into the training set</li>
<li>So <ul>
<li>x is an n-dimensional feature vector</li>
<li>$x^{(3)}$ is, for example, the 3rd training data</li>
</ul>
</li>
</ul>
<p>$x^{(j)}_i$: The value of feature j in the ith training example</p>
<p>例如，当 n=4 时:<br>$$h_θ(x) = θ_0 + θ_1x_1 + θ_2x_2 + θ_3x_3 + θ_4x_4$$</p>
<p>For convenience of notation, $x_0$ = 1, 所以最后的特征向量的维度是 n+1，从 0 开始，记为”X”，<br>则有：<br>$$h_θ(x)=θ^TX$$<br>$θ^T$: [1 * (n+1)] matrix</p>
<h3 id="1-1_多变量的梯度下降">1.1 多变量的梯度下降</h3>
<h3 id="Cost_Function">Cost Function</h3>
<p>$$J(θ_0, θ_1, …,θ_n) =  \frac1{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2}$$</p>
<h3 id="Gradient_descent">Gradient descent</h3>
<p>Repeat {<br>  $$ θ_j = θ_j - α\frac\partial{\partial J(θ_0, θ_1, …,θ_n)} $$<br>}</p>
<p>every iterator</p>
<ul>
<li>θj = θj - learning rate (α) times the partial derivative of J(θ) with respect to θJ(…)</li>
<li>We do this through a simultaneous update of every θj value</li>
</ul>
<p>$$ \frac\partial{\partial J(θ_0, θ_1, …,θ_n)} $$<br>$$ = \frac1m * \sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})}*x_j^{(i)} $$</p>
<h2 id="2-_Gradient_Decent_in_practice">2. Gradient Decent in practice</h2>
<h3 id="2-1_Feature_Scaling">2.1 Feature Scaling</h3>
<p>假设只有 $x_1$,$x_2$ 两个变量，其中：$x_1\in(0,2000), x_2\in(1,5)$，则最后的 J(θ) 图形是一个椭圆，在椭圆下用梯度下降法会比圆形要耗时更久，So we need to rescale this input so it’s more effective，有很多方式，一种是将各个 feature 除以其本身的最大值，缩小范围至[0,1]，一种是各个 feature 减去 mean 然后除以最大值，缩小范围至[-0.5,0.5]</p>
<h3 id="Learning_Rate_α">Learning Rate α</h3>
<ul>
<li>working correctly: If gradient descent is working then J(θ) should decrease after every iteration</li>
<li>convergence: 收敛是指每经过一次迭代，J(θ)的值都变化甚小。</li>
<li>choose α<ol>
<li>When to use a smaller α<ul>
<li>If J(θ) is increasing, see below picture</li>
<li>If J(θ) looks like a series of waves, decreasing and increasing again</li>
<li>But if α is too small then rate is too slow</li>
</ul>
</li>
<li>Try a range of α values<ul>
<li>Plot J(θ) vs number of iterations for each version of alpha</li>
<li>Go for roughly threefold increases: 0.001, 0.003, 0.01, 0.03. 0.1, 0.3</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/img/gradient_descent_plot.jpg" alt=""></p>
<h2 id="2-2_Features_and_polynomial_regression">2.2 Features and polynomial regression</h2>
<h3 id="Can_create_new_features">Can create new features</h3>
<p>如何选择 features 和表达式尤为关键，例如房价与房子的长，房子的宽组成的表达式就会麻烦很多，若将房子的长乘以房子的宽得出面积，则有房价与房子面积的表达式，将会更容易拟合出房价的走势。</p>
<h3 id="Polynomial_regression">Polynomial regression</h3>
<p>例如房价的走势，如下图，横坐标 x 为房子的面积，纵坐标为房价，使用一元二次的方程，会得出下图的蓝色曲线。容易得到房价今后会有一个下降的过程，可实际上房价是不会随着面积的增大而下降的。所以需要重新选定 Polynomial regression，可以改为使用一元三次的方程或者使用平凡根的方程。</p>
<p><strong>所以选择合适的 Features 和 Polynomial regression 都非常重要。</strong></p>
<p><img src="/img/polynomial_regression_choose.jpg" alt=""></p>
<h2 id="3-_Normal_equation_求解多变量线性回归">3. Normal equation 求解多变量线性回归</h2>
<h3 id="3-1_Normal_equation">3.1 Normal equation</h3>
<p>举例说明，假设 J(θ) 是一元二次方程，如：J(θ)=a$θ^2$+bθ+c，则令 $$ \frac{d}{dθ}J(θ)=2aθ+b=0$$ 即可，求出最终的 θ 则得到了线性回归方程，可以预测出今后的 y 值。</p>
<p>更普遍地，当 θ 是一个 n+1 维的向量时，θ $\in$ $R^{n+1}$，则 cost function 如下：<br>$$ J(θ_0, θ_1, …,θ_n) =  \frac1{2m}\sum_{i=1}^{m}{(h_θ(x^{(i)}) - y^{(i)})^2} $$<br>只需要令：<br>$$ \frac\partial{\partial θ_j}J(θ_0, θ_1, …,θ_n) = … = 0 $$，其中 j = 0,1,2,…,n<br>设 X 代表训练集的 features 的值的矩阵，y 代表训练集的结果的值的矩阵，假设训练集数量为 m, features 个数为 n, 则 X 为 (m*n) 的矩阵，y 为 (m*1) 的矩阵，可以推导出求 θ 向量的公式如下：<br>$$θ = (X^TX)^{-1}X^Ty$$</p>
<h2 id="4-_Gradient_descent_Vs_Normal_equation">4. Gradient descent Vs Normal equation</h2>
<h3 id="Gradient_descent-1">Gradient descent</h3>
<ul>
<li>Need to chose learning rate</li>
<li>Needs many iterations - could make it slower</li>
<li>Works well even when n is massive (millions)</li>
<li>Better suited to big data</li>
<li>What is a big n though: 100 or even a 1000 is still (relativity) small, If n is 10000 then look at using gradient descent</li>
<li>适用于线性回归会逻辑回归</li>
</ul>
<h3 id="Normal_equation">Normal equation</h3>
<ul>
<li>No need to chose a learning rate</li>
<li>No need to iterate, check for convergence etc.</li>
<li>Normal equation needs to compute $(X^TX)^{-1}$<ul>
<li>This is the inverse of an n x n matrix</li>
<li>With most implementations computing a matrix inverse grows by O(n3), So not great</li>
</ul>
</li>
<li>Slow of n is large, Can be much slower</li>
<li>仅适用于线性回归</li>
</ul>
<h2 id="5-_局部加权线性回归">5. 局部加权线性回归</h2>
<p>局部加权回归(locally weighted regression)简称 loess，其思想是，针对对某训练数据的每一个点，选取这个点及其临近的一批点做线性回归；同时也需要考虑整个训练数据，考虑的原则是距离该区域越近的点贡献越大，反之则贡献越小，这也正说明局部的思想。其 cost function 为：<br>$$J(\theta) = \sum_{i=1}^{m} w^{(i)}( y^{(i)}-\theta^Tx^{(i)} )^2$$</p>
<p>其中<br>$$ w^{(i)} =  exp (-\frac{(x^{(i)}-x)^2}{\tau^2})$$</p>
<p>$w^{(i)}$的形式跟正态分布很相似，但二者没有任何关系，仅仅只是便于计算。可以发现，$x^{(j)}$ 离 $x^{(i)}$ 非常近时，${w^{(i)}_j}$ 的值接近于1，此时 j 点的贡献很大，当 $x^{(j)}$ 离 $x^{(i)}$ 非常远时，${w^{(i)}_j}$ 的值接近于 0，此时 j 点的贡献很小。</p>
<p>$\tau^2$ 是波长函数(bandwidth)， 控制权重随距离下降的速度，τ 越小则 x 离 $x^{(i)}$ 越远时 $w^{(i)}$ 的值下降的越快。</p>
<p>所以，如果沿着 x 轴的每个点都进行局部直线拟合，那么你会发现对于这个数据集合来说，局部加权的预测结果，能够最终跟踪这条非线性的曲线。</p>
<p>但局部加权回归也有其缺点：</p>
<ul>
<li>每次对一个点的预测都需要整个数据集的参与，样本量大且需要多点预测时效率低。提高效率的方法参考 Andrew More’s KD Tree</li>
<li>不可外推，对样本所包含的区域外的点进行预测时效果不好，事实上这也是一般线性回归的弱点</li>
</ul>
<p>对于线性回归算法，一旦拟合出适合训练数据的参数θ，保存这些参数θ，对于之后的预测，不需要再使用原始训练数据集，所以是参数学习算法。</p>
<p>对于局部加权线性回归算法，每次进行预测都需要全部的训练数据（每次进行的预测得到不同的参数θ），没有固定的参数θ，所以是非参数算法(non-parametric algorithm)。</p>
<h2 id="Reference">Reference</h2>
<blockquote>
<p><a href="http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html" target="_blank" rel="external">http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables.html</a></p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/11/05/Stanford-Machine-Learning-Week-2-Linear-Regression-with-multiple-features/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/java/" title="java">java<sup>15</sup></a></li>
		
			<li><a href="/tags/算法/" title="算法">算法<sup>10</sup></a></li>
		
			<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>7</sup></a></li>
		
			<li><a href="/tags/多线程/" title="多线程">多线程<sup>6</sup></a></li>
		
			<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>4</sup></a></li>
		
			<li><a href="/tags/分布式/" title="分布式">分布式<sup>3</sup></a></li>
		
			<li><a href="/tags/调试/" title="调试">调试<sup>3</sup></a></li>
		
			<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		
			<li><a href="/tags/网络/" title="网络">网络<sup>2</sup></a></li>
		
			<li><a href="/tags/test/" title="test">test<sup>1</sup></a></li>
		
			<li><a href="/tags/shell/" title="shell">shell<sup>1</sup></a></li>
		
			<li><a href="/tags/skill/" title="skill">skill<sup>1</sup></a></li>
		
			<li><a href="/tags/安全/" title="安全">安全<sup>1</sup></a></li>
		
			<li><a href="/tags/spark/" title="spark">spark<sup>1</sup></a></li>
		
			<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
		
			<li><a href="/tags/Spark/" title="Spark">Spark<sup>1</sup></a></li>
		
			<li><a href="/tags/promote/" title="promote">promote<sup>1</sup></a></li>
		
			<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>1</sup></a></li>
		
			<li><a href="/tags/总结/" title="总结">总结<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m ljp215 Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Pacman">Jacman</a> © 2018 
		
		<a href="http://luojinping.com/about" target="_blank" title="Jinping Luo">Jinping Luo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>





<script type="text/javascript">

var disqus_shortname = 'zane215';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>








<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fnull' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- MathJax End -->

  </body>
 </html>
